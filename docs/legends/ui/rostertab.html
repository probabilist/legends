<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>legends.ui.rostertab API documentation</title>
<meta name="description" content="The `legends.ui.rostertab.RosterTab` class and related objects." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>legends.ui.rostertab</code></h1>
</header>
<section id="section-intro">
<p>The <code><a title="legends.ui.rostertab.RosterTab" href="#legends.ui.rostertab.RosterTab">RosterTab</a></code> class and related objects.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;The `legends.ui.rostertab.RosterTab` class and related objects.

&#34;&#34;&#34;

import tkinter as tk
from tkinter import ttk
from csv import DictWriter
from getpass import getuser
from legends.utils.scrollframe import ScrollFrame
# pylint: disable-next=no-name-in-module
from legends.constants import (
    ENABLED, POWER_AT_ORIGIN, RARITIES, ROLES, STAT_INITIALS, SUMMON_POOL
)
from legends.ui.charcard import CharCard
from legends.ui.dialogs import asksaveasfilename, ModalDialog, ModalMessage

__all__ = [
    &#39;AskRosterFilter&#39;,
    &#39;OptimalSummons&#39;,
    &#39;RosterFilter&#39;,
    &#39;RosterInfoBar&#39;,
    &#39;RosterTab&#39;
]

class AskRosterFilter(ModalDialog):
    &#34;&#34;&#34;A modal dialog used for adjusting `RosterFilter` objects.

    The constructor must be given a `RosterFilter` object. That object
    will be used to initialize the window, but will not be modified.

    Attributes:
        filt (RosterFilter): The `RosterFilter` object controlled and
            modified by the dialog window.
        result (RosterFilter or None): Inherited from `ModalDialog`,
            which inherited it from `tk.simpledialog.Dialog`. Defaults
            to `None`. Is set by the `AskRosterFilter.apply` method to
            the value of the `filt` attribute.

    &#34;&#34;&#34;
    def __init__(self, root, rosterFilter, parent=None):
        &#34;&#34;&#34;The constructor sets the `filt` attribute, then calls the
        `ModalDialog` constructor.

        Args:
            root (legends.ui.stlplanner.STLPlanner): The currently
                running `legends.ui.stlplanner.STLPlanner` instance.
                Passed to the `ModalDialog` constructor.
            rosterFilter (RosterFilter): The instance&#39;s `filt` attribute
                is assigned a copy of this argument.

        &#34;&#34;&#34;
        self.filt = RosterFilter(rosterFilter)
        ModalDialog.__init__(self, root, parent, &#39;Filter characters&#39;)

    def body(self, master):
        &#34;&#34;&#34;Create the body of the dialog.

        &#34;&#34;&#34;
        widgets = {}

        # create the rarity and role checkboxes
        widgets[&#39;rarityCheckboxes&#39;] = tk.Frame(master)
        for rarity in RARITIES:
            tk.Checkbutton(
                widgets[&#39;rarityCheckboxes&#39;], text=rarity,
                variable=self.filt.rarities[rarity]
            ).pack(side=tk.LEFT)
        widgets[&#39;roleCheckboxes&#39;] = tk.Frame(master)
        for role in ROLES:
            tk.Checkbutton(
                widgets[&#39;roleCheckboxes&#39;], text=role,
                variable=self.filt.roles[role]
            ).pack(side=tk.LEFT)

        # create the rank and level linked scales
        widgets[&#39;rankMinScale&#39;], widgets[&#39;rankMaxScale&#39;] = (
            self.makeLinkedScales(master, &#39;ranks&#39;, 9)
        )
        widgets[&#39;levelMinScale&#39;], widgets[&#39;levelMaxScale&#39;] = (
            self.makeLinkedScales(master, &#39;levels&#39;, 99)
        )

        # grid the body content
        labels = [
            &#39;Rarity:&#39;, &#39;Role:&#39;,
            &#39;Min rank:&#39;, &#39;Max rank:&#39;, &#39;Min level:&#39;, &#39;Max level:&#39;
        ]
        for row, label, widget in zip(range(6), labels, widgets.values()):
            tk.Label(master, text=label, font=(None, 13, &#39;bold&#39;)).grid(
                row=row, column=0, sticky=tk.E
            )
            widget.grid(row=row, column=1, sticky=tk.W)

    def makeLinkedScales(self, master, attrName, maxVal):
        &#34;&#34;&#34;Creates and returns a pair of linked Scale widgets. Each
        scale has values from 1 to `maxVal`. If `attrName` is &#39;ranks&#39;,
        the scales are associated with the `tkinter` variables stored in
        the `ranks` attribute of the calling instance&#39;s `filt`
        attribute. Similarly if `attrName` is &#39;levels&#39;.

        The first scale controls the minimum value; the second controls
        the maximum. The scales are configured so that the minimum value
        cannot exceed the maximum.

        The given `master` argument is assigned as the parent of both
        scales.

        Args:
            master (obj): The tkinter object to assign as parent.
            attrName (str): One of &#39;ranks&#39; or &#39;levels&#39;
            maxVal (int): The maximum value of the linked scales.

        Returns:
            list of tk.Scale: The two linked scales.

        &#34;&#34;&#34;
        varTuple = getattr(self.filt, attrName)
        funcs = [min, max]
        scales = [None, None]
        for j in (0, 1):
            k = 1 - j
            scales[j] = tk.Scale(
                master, variable=varTuple[j], from_=1, to=maxVal,
                length=400, orient=tk.HORIZONTAL
            )
            scales[j].config(command=lambda val, k=k: varTuple[k].set(
                funcs[k](int(val), varTuple[k].get()))
            )
        return scales

    def buttonbox(self):
        &#34;&#34;&#34;Add a &#39;Clear All&#39; button to the button box.

        &#34;&#34;&#34;
        ModalDialog.buttonbox(self)
        self.box.pack_forget()
        tk.Button(
            self.box, text=&#34;Clear All&#34;, width=10, command=self.clear
        ).pack(side=tk.LEFT, padx=5, pady=5)
        self.box.pack(expand=tk.YES, fill=tk.X)

    def clear(self):
        &#34;&#34;&#34;Reset the `filt` attribute to default values.

        &#34;&#34;&#34;
        self.filt.set(RosterFilter())

    def apply(self):
        &#34;&#34;&#34;Set the `result` attribute.

        &#34;&#34;&#34;
        self.result = self.filt

class OptimalSummons(ModalMessage):
    &#34;&#34;&#34;A message dialog showing the summon pool rates.

    Attributes:
        excludeCommons (tk.BooleanVar): `True` is the summon rate
            calculations should exclude Common characters.
        values (dict): {`str`:`tk.StringVar`} A dictionary mapping pool
            names to a formatted string representation of the average
            number of tokens per 150 orbs received from the pool.
        labels (dict): {`str`:(`tk.Label`,`tk.Label`)} A dictionary
            mapping pool names to the pair of labels associated with
            that pool in the body of the message dialog.

    &#34;&#34;&#34;
    def __init__(self, root, parent=None):
        self.excludeCommons = tk.BooleanVar(None, True)
        self.values = {}
        self.labels = {}
        for pool in SUMMON_POOL:
            self.values[pool] = tk.StringVar()
        ModalMessage.__init__(self, root, parent, &#39;Summon Rates&#39;)

    def body(self, master):
        &#34;&#34;&#34;Create the body of the dialog.

        &#34;&#34;&#34;
        tk.Label(
            master,
            text=&#39;Average Tokens per 150 Orbs&#39;,
            font=(None, 13, &#39;bold&#39;)
        ).pack(pady=(0,10))
        results = tk.Frame(master)
        results.pack()
        for row, pool in enumerate(SUMMON_POOL):
            self.labels[pool] = (
                tk.Label(
                    results, text=&#39;{} Pool:&#39;.format(pool)
                ),
                tk.Label(
                    results, textvariable=self.values[pool], width=5
                )
            )
            self.labels[pool][0].grid(row=row, column=0, sticky=tk.W)
            self.labels[pool][1].grid(row=row, column=1, sticky=tk.E)
        tk.Checkbutton(
            master,
            text=&#39;exclude Common characters&#39;,
            variable=self.excludeCommons, command=self.refresh
        ).pack(pady=(10,0))
        self.refresh()

    def refresh(self):
        &#34;&#34;&#34;Updates the values in the `values` attribute and sets the
        font emphasis of the labels so that the highest summon rate is
        bold and the others are normal.

        &#34;&#34;&#34;
        bestPool = &#39;&#39;
        bestPoolTokens = -1
        tokens = {}
        for pool in SUMMON_POOL:
            roster = self.root.session.saveslot.roster
            tokens[pool] = 150 * roster.tokensPerOrb(
                pool, self.excludeCommons.get()
            )
            self.values[pool].set(&#39;{:.2f}&#39;.format(tokens[pool]))
            self.setPoolEmphasis(pool, &#39;normal&#39;)
            if tokens[pool] &gt; bestPoolTokens:
                bestPool, bestPoolTokens = pool, tokens[pool]
        self.setPoolEmphasis(bestPool, &#39;bold&#39;)

    def setPoolEmphasis(self, pool, emphasis):
        &#34;&#34;&#34;Finds the labels associated with the given pool and sets
        their font to have the given emphasis.

        Args:
            pool (str): The name of a summon pool.
            emphasis (str): One of &#39;normal&#39; or &#39;bold&#39;.

        &#34;&#34;&#34;
        self.labels[pool][0].config(font=(None, 11, emphasis))
        self.labels[pool][1].config(font=(None, 11, emphasis))

class RosterFilter():
    &#34;&#34;&#34;Stores information about filtering a
    `legends.ui.rostertab.RosterTab`.

    Attributes:
        rarities (dict): {`str`:`tk.BooleanVar`} A dictionary mapping
            rarities to `tkinter` boolean variables indicating whether
            the rarity is to be included in the
            `legends.ui.rostertab.RosterTab`.
        roles (dict): {`str`:`tk.BooleanVar`} A dictionary mapping roles
            to `tkinter` boolean variables indicating whether the role
            is to be included in the `legends.ui.rostertab.RosterTab`.
        ranks (tuple): (`tk.IntVar`, `tk.IntVar`) The first value is the
            minimum rank to include in the
            `legends.ui.rostertab.RosterTab`. The second is the maximum.
        levels (tuple): (`tk.IntVar`, `tk.IntVar`) The first value is
            the minimum level to include in the
            `legends.ui.rostertab.RosterTab`. The second is the maximum.

    &#34;&#34;&#34;

    def __init__(self, filt=None):
        &#34;&#34;&#34;The constructor creates a new `RosterFilter` object with the
        same values as the given `RosterFilter` object. If `None` is
        provided, the new filter will not omit anything.

        Args:
            filt (RosterFilter): The filter used to initialize the new
                filter.

        &#34;&#34;&#34;
        self.rarities = {
            rarity: tk.BooleanVar(None, True) for rarity in RARITIES
        }
        self.roles = {
            role: tk.BooleanVar(None, True) for role in ROLES
        }
        self.ranks = (tk.IntVar(None, 1), tk.IntVar(None, 9))
        self.levels = (tk.IntVar(None, 1), tk.IntVar(None, 99))
        if filt is not None:
            self.set(filt)

    def set(self, filt):
        &#34;&#34;&#34;Sets the values of the calling instance to match those of the
        given filter.

        Args:
            filt (RosterFilter): The filter from which to copy values.

        &#34;&#34;&#34;
        for rarity, var in self.rarities.items():
            var.set(filt.rarities[rarity].get())
        for role, var in self.roles.items():
            var.set(filt.roles[role].get())
        for j in (0, 1):
            self.ranks[j].set(filt.ranks[j].get())
        for j in (0, 1):
            self.levels[j].set(filt.levels[j].get())

    def dictify(self):
        &#34;&#34;&#34;Creates and returns a dictionary mapping the calling
        instance&#39;s attribute names to its values, with each `tkinter`
        variable replaced by its value.

        Returns:
            dict: The constructed dictionary.

        &#34;&#34;&#34;
        D = {}
        D[&#39;rarities&#39;] = {
            rarity: var.get() for rarity, var in self.rarities.items()
        }
        D[&#39;roles&#39;] = {
            role: var.get() for role, var in self.roles.items()
        }
        D[&#39;ranks&#39;] = (self.ranks[0].get(), self.ranks[1].get())
        D[&#39;levels&#39;] = (self.levels[0].get(), self.levels[1].get())
        return D

    def __eq__(self, other):
        return self.dictify() == other.dictify()

    def __repr__(self):
        return &#39;RosterFilter({})&#39;.format(self.dictify())

class RosterInfoBar(tk.Frame):
    &#34;&#34;&#34;A frame for displaying aggregate data about the user&#39;s roster.

    Attributes:
        totalXP (tk.Label): A label displaying the total XP.
        totalPower (tk.Label): A label displaying the total power.
        charCount (tk.Label): A label displaying the number of
            characters in the roster.

    &#34;&#34;&#34;
    def __init__(self, parent=None, **options):
        &#34;&#34;&#34;The constructor passes its arguments to the `tk.Frame`
        constructor, then builds and packs the attribute labels.

        &#34;&#34;&#34;
        tk.Frame.__init__(self, parent, **options)
        self.totalXP = tk.Label(
            self, borderwidth=2, relief=tk.GROOVE, padx=10
        )
        self.totalXP.pack(side=tk.LEFT)
        self.totalPower = tk.Label(
            self, borderwidth=2, relief=tk.GROOVE, padx=10
        )
        self.totalPower.pack(side=tk.LEFT)
        self.charCount = tk.Label(
            self, borderwidth=2, relief=tk.GROOVE, padx=10
        )
        self.charCount.pack(side=tk.LEFT)

    def makeStats(self, chars, roster):
        &#34;&#34;&#34;Computes and redisplays roster statistics using the given
        collection of characters.

        Args:
            chars (iterable of legends.gameobjects.Character): The
                characters to use when computing statistics.
            roster (legends.roster.Roster): The roster to which the
                characters belong.

        &#34;&#34;&#34;
        self.totalXP.config(text=&#39;Total XP: {:,}&#39;.format(sum(
            char.xp for char in chars
        )))
        self.totalPower.config(text=&#39;Total power: {:,.0f}&#39;.format(sum(
            POWER_AT_ORIGIN + roster.charStats(char.nameID).power
            for char in chars
        )))
        self.charCount.config(text=&#39;Characters: {}/{}&#39;.format(
            len(list(chars)), len(ENABLED)
        ))

class RosterTab(tk.Frame):
    &#34;&#34;&#34;Displays the player&#39;s character collection.

    Attributes:
        filter (RosterFilter): The `RosterFilter` object storing the
            current filter settings.
        scrollArea (legends.utils.scrollframe.ScrollFrame): The
            `legends.utils.scrollframe.ScrollFrame` used to hold the
            character cards.
        infoBar (RosterInfoBar): The info bar containing aggregate info
            about the currently displayed characters.
        sortFuncs (dict): {`str`:`func`} A dictionary mapping field
            names to functions that map `legends.gameobjects.Character`
            objects to a sortable value.
        sortField (tk.StringVar): The currently selected field name by
            which the characters are sorted.
        descending (tk.BooleanVar): `True` if characters should be
            sorted in descending order.

    &#34;&#34;&#34;

    def __init__(self, session, **options):
        &#34;&#34;&#34;The constructor creates an instance as a child of the given
        session.

        Args:
            session (legends.ui.session.Session): The session to assign
                as the instance&#39;s parent.

        &#34;&#34;&#34;
        # build frame and initialize variables
        tk.Frame.__init__(self, session, **options)
        self.filter = RosterFilter()

        # build widgets
        self.scrollArea = ScrollFrame(self)
        self.scrollArea.canvas.config(height=0.7 * self.winfo_screenheight())
        self.infoBar = RosterInfoBar(self)

        # pack frame content
        self.actionBar().pack(expand=tk.YES, fill=tk.X)
        self.scrollArea.pack(expand=tk.YES, fill=tk.BOTH)
        self.infoBar.pack()

        # fill scroll area with character cards
        self.fillCards()

    @property
    def root(self):
        &#34;&#34;&#34;`legends.ui.stlplanner.STLPlanner`: The currently running
        `legends.ui.stlplanner.STLPlanner` instance.
        &#34;&#34;&#34;
        return self.master.master

    @property
    def roster(self):
        &#34;&#34;&#34;`legends.roster.Roster`: The roster associated with this
        roster tab.
        &#34;&#34;&#34;
        return self.master.saveslot.roster

    @property
    def cards(self):
        &#34;&#34;&#34;`dict`: {`str`:`legends.ui.charcard.CharCard`} A dictionary
        mapping a character&#39;s name ID attribute to its character card.
        &#34;&#34;&#34;
        return {
            card.char.nameID : card
            for card in self.scrollArea.content.winfo_children()
            if isinstance(card, CharCard)
        }

    def checkFilter(self, char):
        &#34;&#34;&#34;Checks if the given character passes the current filter
        options.

        Args:
            char (legends.gameobjects.Character): The character to
                check.

        Returns:
            bool: `True` if the character passes.

        &#34;&#34;&#34;
        filt = self.filter.dictify()
        return(
            filt[&#39;rarities&#39;][char.rarity]
            and filt[&#39;roles&#39;][char.role]
            and filt[&#39;ranks&#39;][0] &lt;= char.rank &lt;= filt[&#39;ranks&#39;][1]
            and filt[&#39;levels&#39;][0] &lt;= char.level &lt;= filt[&#39;levels&#39;][1]
        )

    def fillCards(self):
        &#34;&#34;&#34;Builds a card for each character in the player&#39;s collection
        and places it in the scroll area&#39;s content frame.

        &#34;&#34;&#34;
        columns = 4
        for j in range(columns):
            self.scrollArea.content.columnconfigure(
                j, weight=1, uniform=&#39;roster&#39;
            )
        count = 0
        chars = [
            char for char in self.roster.chars.values()
            if self.checkFilter(char)
        ]
        for char in chars:
            CharCard(char, self).grid(
                row=count // columns, column=count % columns, sticky=tk.NSEW
            )
            count += 1
        self.infoBar.makeStats(chars, self.roster)

    def actionBar(self):
        &#34;&#34;&#34;Builds and returns an action bar that allows the user to
        interact with the `RosterTab`.

        &#34;&#34;&#34;
        # define and initialize variables
        sslot = self.master.saveslot
        ros = self.roster
        self.sortFuncs = {
            &#39;Name&#39;: lambda c: c.shortName,
            &#39;Favorite&#39;: lambda c,s=sslot: c in s.favorites,
            &#39;Level&#39;: lambda c: c.xp,
            &#39;Rank&#39;: lambda c: c.rank,
            &#39;Rarity&#39;: lambda c: c.rarityIndex,
            &#39;Role&#39;: lambda c: c.role,
            &#39;Tokens&#39;: lambda c,s=sslot: s.tokens[c.nameID],
            &#39;Tokens needed&#39;: lambda c,s=sslot: (
                c.tokensNeeded - s.tokens[c.nameID]
            )
        }
        for statName in STAT_INITIALS:
            self.sortFuncs[statName] = lambda c,r=ros,n=statName: (
                r.charStats(c.nameID).get(n)
            )
        self.sortFuncs[&#39;Power&#39;] = lambda c,r=ros: (
            POWER_AT_ORIGIN + r.charStats(c.nameID).power
        )
        self.sortFuncs.update({
            &#39;Missing gear levels&#39;: lambda c,r=ros: (
                r.missingGearLevels(c.nameID)
            ),
            &#39;Missing gear ranks&#39;: lambda c,r=ros: (
                r.missingGearRanks(c.nameID)
            ),
            &#39;Missing skill levels&#39;: lambda c: c.missingSkillLevels
        })
        fields = list(self.sortFuncs.keys())
        self.sortField = tk.StringVar()
        self.descending = tk.BooleanVar()
        self.descending.set(True)

        # build bar and sorting Combobox
        bar = tk.Frame(self)
        sortMenu = ttk.Combobox(
            bar,
            textvariable=self.sortField,
            values=fields,
            state=&#39;readonly&#39;,
            width=max(len(field) for field in fields)
        )
        sortMenu.bind(&#39;&lt;&lt;ComboboxSelected&gt;&gt;&#39;, lambda event:self.sort())

        # pack and return bar
        tk.Label(bar, text=&#39;sort by:&#39;).pack(side=tk.LEFT)
        sortMenu.pack(side=tk.LEFT)
        tk.Checkbutton(
            bar, text=&#39;descending&#39;, variable=self.descending, command=self.sort
        ).pack(side=tk.LEFT)
        tk.Button(
            bar, text=&#39;filter&#39;, width=6, command=self.adjustFilter
        ).pack(side=tk.LEFT)
        tk.Button(
            bar, text=&#39;export&#39;, width=6, command=self.export
        ).pack(side=tk.LEFT)
        tk.Button(
            bar, text=&#39;summon pools&#39;, command=self.optimalSummons
        ).pack(side=tk.RIGHT)
        return bar

    def optimalSummons(self):
        &#34;&#34;&#34;Raises an `OptimalSummons` message window showing the summon
        rates for the various summon pools.

        &#34;&#34;&#34;
        OptimalSummons(self.root)

    def sort(self):
        &#34;&#34;&#34;Sorts the dictionary of characters stored in the associated
        `legends.saveslot.SaveSlot` object according the currently
        selected sorting field. Then refreshes the character cards.

        &#34;&#34;&#34;
        field = self.sortField.get()
        if field == &#39;&#39;:
            return
        self.master.saveslot.sort(
            self.sortFuncs[field], self.descending.get()
        )
        self.refresh()

    def refresh(self):
        &#34;&#34;&#34;Destroys and rebuilds all character cards.

        &#34;&#34;&#34;
        for card in self.cards.values():
            card.destroy()
        self.fillCards()

    def adjustFilter(self):
        &#34;&#34;&#34;Creates an `AskRosterFilter` window, giving the user an
        opportunity to adjust the filter settings. Then refreshes the
        character cards and info bar.

        &#34;&#34;&#34;
        filt = AskRosterFilter(self.root, self.filter).result
        if filt is not None:
            self.filter = filt
            self.refresh()

    def export(self):
        &#34;&#34;&#34;Exports the data in the character cards to a csv file. Each
        row in the file corresponds to a card, and the data in that row
        is the data generated by the card&#39;s
        `legends.ui.charcard.CharCard.dictify` method.

        &#34;&#34;&#34;
        filename = asksaveasfilename(
            self.root,
            defaultextension=&#39;csv&#39;,
            initialdir=&#39;/Users/&#39; + getuser() + &#39;/Documents/&#39;,
            initialfile=&#39;roster.csv&#39;,
            title=&#39;Export Roster&#39;,
            filetypes=[(&#39;Text CSV&#39;, &#39;*.csv&#39;)]
        )
        if not filename:
            return
        cardDicts = [card.dictify() for card in self.cards.values()]
        fields = cardDicts[0].keys()
        with open(filename, &#39;w&#39;, newline=&#39;&#39;, encoding=&#39;utf-8&#39;) as f:
            writer = DictWriter(f, fields)
            writer.writeheader()
            writer.writerows(cardDicts)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="legends.ui.rostertab.AskRosterFilter"><code class="flex name class">
<span>class <span class="ident">AskRosterFilter</span></span>
<span>(</span><span>root, rosterFilter, parent=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A modal dialog used for adjusting <code><a title="legends.ui.rostertab.RosterFilter" href="#legends.ui.rostertab.RosterFilter">RosterFilter</a></code> objects.</p>
<p>The constructor must be given a <code><a title="legends.ui.rostertab.RosterFilter" href="#legends.ui.rostertab.RosterFilter">RosterFilter</a></code> object. That object
will be used to initialize the window, but will not be modified.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>filt</code></strong> :&ensp;<code><a title="legends.ui.rostertab.RosterFilter" href="#legends.ui.rostertab.RosterFilter">RosterFilter</a></code></dt>
<dd>The <code><a title="legends.ui.rostertab.RosterFilter" href="#legends.ui.rostertab.RosterFilter">RosterFilter</a></code> object controlled and
modified by the dialog window.</dd>
<dt><strong><code>result</code></strong> :&ensp;<code><a title="legends.ui.rostertab.RosterFilter" href="#legends.ui.rostertab.RosterFilter">RosterFilter</a></code> or <code>None</code></dt>
<dd>Inherited from <code>ModalDialog</code>,
which inherited it from <code>tk.simpledialog.Dialog</code>. Defaults
to <code>None</code>. Is set by the <code><a title="legends.ui.rostertab.AskRosterFilter.apply" href="#legends.ui.rostertab.AskRosterFilter.apply">AskRosterFilter.apply()</a></code> method to
the value of the <code>filt</code> attribute.</dd>
</dl>
<p>The constructor sets the <code>filt</code> attribute, then calls the
<code>ModalDialog</code> constructor.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>root</code></strong> :&ensp;<code><a title="legends.ui.stlplanner.STLPlanner" href="stlplanner.html#legends.ui.stlplanner.STLPlanner">STLPlanner</a></code></dt>
<dd>The currently
running <code><a title="legends.ui.stlplanner.STLPlanner" href="stlplanner.html#legends.ui.stlplanner.STLPlanner">STLPlanner</a></code> instance.
Passed to the <code>ModalDialog</code> constructor.</dd>
<dt><strong><code>rosterFilter</code></strong> :&ensp;<code><a title="legends.ui.rostertab.RosterFilter" href="#legends.ui.rostertab.RosterFilter">RosterFilter</a></code></dt>
<dd>The instance's <code>filt</code> attribute
is assigned a copy of this argument.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AskRosterFilter(ModalDialog):
    &#34;&#34;&#34;A modal dialog used for adjusting `RosterFilter` objects.

    The constructor must be given a `RosterFilter` object. That object
    will be used to initialize the window, but will not be modified.

    Attributes:
        filt (RosterFilter): The `RosterFilter` object controlled and
            modified by the dialog window.
        result (RosterFilter or None): Inherited from `ModalDialog`,
            which inherited it from `tk.simpledialog.Dialog`. Defaults
            to `None`. Is set by the `AskRosterFilter.apply` method to
            the value of the `filt` attribute.

    &#34;&#34;&#34;
    def __init__(self, root, rosterFilter, parent=None):
        &#34;&#34;&#34;The constructor sets the `filt` attribute, then calls the
        `ModalDialog` constructor.

        Args:
            root (legends.ui.stlplanner.STLPlanner): The currently
                running `legends.ui.stlplanner.STLPlanner` instance.
                Passed to the `ModalDialog` constructor.
            rosterFilter (RosterFilter): The instance&#39;s `filt` attribute
                is assigned a copy of this argument.

        &#34;&#34;&#34;
        self.filt = RosterFilter(rosterFilter)
        ModalDialog.__init__(self, root, parent, &#39;Filter characters&#39;)

    def body(self, master):
        &#34;&#34;&#34;Create the body of the dialog.

        &#34;&#34;&#34;
        widgets = {}

        # create the rarity and role checkboxes
        widgets[&#39;rarityCheckboxes&#39;] = tk.Frame(master)
        for rarity in RARITIES:
            tk.Checkbutton(
                widgets[&#39;rarityCheckboxes&#39;], text=rarity,
                variable=self.filt.rarities[rarity]
            ).pack(side=tk.LEFT)
        widgets[&#39;roleCheckboxes&#39;] = tk.Frame(master)
        for role in ROLES:
            tk.Checkbutton(
                widgets[&#39;roleCheckboxes&#39;], text=role,
                variable=self.filt.roles[role]
            ).pack(side=tk.LEFT)

        # create the rank and level linked scales
        widgets[&#39;rankMinScale&#39;], widgets[&#39;rankMaxScale&#39;] = (
            self.makeLinkedScales(master, &#39;ranks&#39;, 9)
        )
        widgets[&#39;levelMinScale&#39;], widgets[&#39;levelMaxScale&#39;] = (
            self.makeLinkedScales(master, &#39;levels&#39;, 99)
        )

        # grid the body content
        labels = [
            &#39;Rarity:&#39;, &#39;Role:&#39;,
            &#39;Min rank:&#39;, &#39;Max rank:&#39;, &#39;Min level:&#39;, &#39;Max level:&#39;
        ]
        for row, label, widget in zip(range(6), labels, widgets.values()):
            tk.Label(master, text=label, font=(None, 13, &#39;bold&#39;)).grid(
                row=row, column=0, sticky=tk.E
            )
            widget.grid(row=row, column=1, sticky=tk.W)

    def makeLinkedScales(self, master, attrName, maxVal):
        &#34;&#34;&#34;Creates and returns a pair of linked Scale widgets. Each
        scale has values from 1 to `maxVal`. If `attrName` is &#39;ranks&#39;,
        the scales are associated with the `tkinter` variables stored in
        the `ranks` attribute of the calling instance&#39;s `filt`
        attribute. Similarly if `attrName` is &#39;levels&#39;.

        The first scale controls the minimum value; the second controls
        the maximum. The scales are configured so that the minimum value
        cannot exceed the maximum.

        The given `master` argument is assigned as the parent of both
        scales.

        Args:
            master (obj): The tkinter object to assign as parent.
            attrName (str): One of &#39;ranks&#39; or &#39;levels&#39;
            maxVal (int): The maximum value of the linked scales.

        Returns:
            list of tk.Scale: The two linked scales.

        &#34;&#34;&#34;
        varTuple = getattr(self.filt, attrName)
        funcs = [min, max]
        scales = [None, None]
        for j in (0, 1):
            k = 1 - j
            scales[j] = tk.Scale(
                master, variable=varTuple[j], from_=1, to=maxVal,
                length=400, orient=tk.HORIZONTAL
            )
            scales[j].config(command=lambda val, k=k: varTuple[k].set(
                funcs[k](int(val), varTuple[k].get()))
            )
        return scales

    def buttonbox(self):
        &#34;&#34;&#34;Add a &#39;Clear All&#39; button to the button box.

        &#34;&#34;&#34;
        ModalDialog.buttonbox(self)
        self.box.pack_forget()
        tk.Button(
            self.box, text=&#34;Clear All&#34;, width=10, command=self.clear
        ).pack(side=tk.LEFT, padx=5, pady=5)
        self.box.pack(expand=tk.YES, fill=tk.X)

    def clear(self):
        &#34;&#34;&#34;Reset the `filt` attribute to default values.

        &#34;&#34;&#34;
        self.filt.set(RosterFilter())

    def apply(self):
        &#34;&#34;&#34;Set the `result` attribute.

        &#34;&#34;&#34;
        self.result = self.filt</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="legends.ui.dialogs.ModalDialog" href="dialogs.html#legends.ui.dialogs.ModalDialog">ModalDialog</a></li>
<li><a title="legends.ui.dialogs.ModalMessage" href="dialogs.html#legends.ui.dialogs.ModalMessage">ModalMessage</a></li>
<li>tkinter.simpledialog.Dialog</li>
<li>tkinter.Toplevel</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Wm</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="legends.ui.rostertab.AskRosterFilter.apply"><code class="name flex">
<span>def <span class="ident">apply</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the <code>result</code> attribute.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply(self):
    &#34;&#34;&#34;Set the `result` attribute.

    &#34;&#34;&#34;
    self.result = self.filt</code></pre>
</details>
</dd>
<dt id="legends.ui.rostertab.AskRosterFilter.body"><code class="name flex">
<span>def <span class="ident">body</span></span>(<span>self, master)</span>
</code></dt>
<dd>
<div class="desc"><p>Create the body of the dialog.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def body(self, master):
    &#34;&#34;&#34;Create the body of the dialog.

    &#34;&#34;&#34;
    widgets = {}

    # create the rarity and role checkboxes
    widgets[&#39;rarityCheckboxes&#39;] = tk.Frame(master)
    for rarity in RARITIES:
        tk.Checkbutton(
            widgets[&#39;rarityCheckboxes&#39;], text=rarity,
            variable=self.filt.rarities[rarity]
        ).pack(side=tk.LEFT)
    widgets[&#39;roleCheckboxes&#39;] = tk.Frame(master)
    for role in ROLES:
        tk.Checkbutton(
            widgets[&#39;roleCheckboxes&#39;], text=role,
            variable=self.filt.roles[role]
        ).pack(side=tk.LEFT)

    # create the rank and level linked scales
    widgets[&#39;rankMinScale&#39;], widgets[&#39;rankMaxScale&#39;] = (
        self.makeLinkedScales(master, &#39;ranks&#39;, 9)
    )
    widgets[&#39;levelMinScale&#39;], widgets[&#39;levelMaxScale&#39;] = (
        self.makeLinkedScales(master, &#39;levels&#39;, 99)
    )

    # grid the body content
    labels = [
        &#39;Rarity:&#39;, &#39;Role:&#39;,
        &#39;Min rank:&#39;, &#39;Max rank:&#39;, &#39;Min level:&#39;, &#39;Max level:&#39;
    ]
    for row, label, widget in zip(range(6), labels, widgets.values()):
        tk.Label(master, text=label, font=(None, 13, &#39;bold&#39;)).grid(
            row=row, column=0, sticky=tk.E
        )
        widget.grid(row=row, column=1, sticky=tk.W)</code></pre>
</details>
</dd>
<dt id="legends.ui.rostertab.AskRosterFilter.buttonbox"><code class="name flex">
<span>def <span class="ident">buttonbox</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a 'Clear All' button to the button box.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def buttonbox(self):
    &#34;&#34;&#34;Add a &#39;Clear All&#39; button to the button box.

    &#34;&#34;&#34;
    ModalDialog.buttonbox(self)
    self.box.pack_forget()
    tk.Button(
        self.box, text=&#34;Clear All&#34;, width=10, command=self.clear
    ).pack(side=tk.LEFT, padx=5, pady=5)
    self.box.pack(expand=tk.YES, fill=tk.X)</code></pre>
</details>
</dd>
<dt id="legends.ui.rostertab.AskRosterFilter.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Reset the <code>filt</code> attribute to default values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self):
    &#34;&#34;&#34;Reset the `filt` attribute to default values.

    &#34;&#34;&#34;
    self.filt.set(RosterFilter())</code></pre>
</details>
</dd>
<dt id="legends.ui.rostertab.AskRosterFilter.makeLinkedScales"><code class="name flex">
<span>def <span class="ident">makeLinkedScales</span></span>(<span>self, master, attrName, maxVal)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and returns a pair of linked Scale widgets. Each
scale has values from 1 to <code>maxVal</code>. If <code>attrName</code> is 'ranks',
the scales are associated with the <code>tkinter</code> variables stored in
the <code>ranks</code> attribute of the calling instance's <code>filt</code>
attribute. Similarly if <code>attrName</code> is 'levels'.</p>
<p>The first scale controls the minimum value; the second controls
the maximum. The scales are configured so that the minimum value
cannot exceed the maximum.</p>
<p>The given <code>master</code> argument is assigned as the parent of both
scales.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>master</code></strong> :&ensp;<code>obj</code></dt>
<dd>The tkinter object to assign as parent.</dd>
<dt><strong><code>attrName</code></strong> :&ensp;<code>str</code></dt>
<dd>One of 'ranks' or 'levels'</dd>
<dt><strong><code>maxVal</code></strong> :&ensp;<code>int</code></dt>
<dd>The maximum value of the linked scales.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code> of <code>tk.Scale</code></dt>
<dd>The two linked scales.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def makeLinkedScales(self, master, attrName, maxVal):
    &#34;&#34;&#34;Creates and returns a pair of linked Scale widgets. Each
    scale has values from 1 to `maxVal`. If `attrName` is &#39;ranks&#39;,
    the scales are associated with the `tkinter` variables stored in
    the `ranks` attribute of the calling instance&#39;s `filt`
    attribute. Similarly if `attrName` is &#39;levels&#39;.

    The first scale controls the minimum value; the second controls
    the maximum. The scales are configured so that the minimum value
    cannot exceed the maximum.

    The given `master` argument is assigned as the parent of both
    scales.

    Args:
        master (obj): The tkinter object to assign as parent.
        attrName (str): One of &#39;ranks&#39; or &#39;levels&#39;
        maxVal (int): The maximum value of the linked scales.

    Returns:
        list of tk.Scale: The two linked scales.

    &#34;&#34;&#34;
    varTuple = getattr(self.filt, attrName)
    funcs = [min, max]
    scales = [None, None]
    for j in (0, 1):
        k = 1 - j
        scales[j] = tk.Scale(
            master, variable=varTuple[j], from_=1, to=maxVal,
            length=400, orient=tk.HORIZONTAL
        )
        scales[j].config(command=lambda val, k=k: varTuple[k].set(
            funcs[k](int(val), varTuple[k].get()))
        )
    return scales</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="legends.ui.dialogs.ModalDialog" href="dialogs.html#legends.ui.dialogs.ModalDialog">ModalDialog</a></b></code>:
<ul class="hlist">
<li><code><a title="legends.ui.dialogs.ModalDialog.destroy" href="dialogs.html#legends.ui.dialogs.ModalMessage.destroy">destroy</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="legends.ui.rostertab.OptimalSummons"><code class="flex name class">
<span>class <span class="ident">OptimalSummons</span></span>
<span>(</span><span>root, parent=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A message dialog showing the summon pool rates.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>excludeCommons</code></strong> :&ensp;<code>tk.BooleanVar</code></dt>
<dd><code>True</code> is the summon rate
calculations should exclude Common characters.</dd>
<dt><strong><code>values</code></strong> :&ensp;<code>dict</code></dt>
<dd>{<code>str</code>:<code>tk.StringVar</code>} A dictionary mapping pool
names to a formatted string representation of the average
number of tokens per 150 orbs received from the pool.</dd>
<dt><strong><code>labels</code></strong> :&ensp;<code>dict</code></dt>
<dd>{<code>str</code>:(<code>tk.Label</code>,<code>tk.Label</code>)} A dictionary
mapping pool names to the pair of labels associated with
that pool in the body of the message dialog.</dd>
</dl>
<p>The constructor disables the root menu before calling the
<code>tk.simpledialog.Dialog</code> constructor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OptimalSummons(ModalMessage):
    &#34;&#34;&#34;A message dialog showing the summon pool rates.

    Attributes:
        excludeCommons (tk.BooleanVar): `True` is the summon rate
            calculations should exclude Common characters.
        values (dict): {`str`:`tk.StringVar`} A dictionary mapping pool
            names to a formatted string representation of the average
            number of tokens per 150 orbs received from the pool.
        labels (dict): {`str`:(`tk.Label`,`tk.Label`)} A dictionary
            mapping pool names to the pair of labels associated with
            that pool in the body of the message dialog.

    &#34;&#34;&#34;
    def __init__(self, root, parent=None):
        self.excludeCommons = tk.BooleanVar(None, True)
        self.values = {}
        self.labels = {}
        for pool in SUMMON_POOL:
            self.values[pool] = tk.StringVar()
        ModalMessage.__init__(self, root, parent, &#39;Summon Rates&#39;)

    def body(self, master):
        &#34;&#34;&#34;Create the body of the dialog.

        &#34;&#34;&#34;
        tk.Label(
            master,
            text=&#39;Average Tokens per 150 Orbs&#39;,
            font=(None, 13, &#39;bold&#39;)
        ).pack(pady=(0,10))
        results = tk.Frame(master)
        results.pack()
        for row, pool in enumerate(SUMMON_POOL):
            self.labels[pool] = (
                tk.Label(
                    results, text=&#39;{} Pool:&#39;.format(pool)
                ),
                tk.Label(
                    results, textvariable=self.values[pool], width=5
                )
            )
            self.labels[pool][0].grid(row=row, column=0, sticky=tk.W)
            self.labels[pool][1].grid(row=row, column=1, sticky=tk.E)
        tk.Checkbutton(
            master,
            text=&#39;exclude Common characters&#39;,
            variable=self.excludeCommons, command=self.refresh
        ).pack(pady=(10,0))
        self.refresh()

    def refresh(self):
        &#34;&#34;&#34;Updates the values in the `values` attribute and sets the
        font emphasis of the labels so that the highest summon rate is
        bold and the others are normal.

        &#34;&#34;&#34;
        bestPool = &#39;&#39;
        bestPoolTokens = -1
        tokens = {}
        for pool in SUMMON_POOL:
            roster = self.root.session.saveslot.roster
            tokens[pool] = 150 * roster.tokensPerOrb(
                pool, self.excludeCommons.get()
            )
            self.values[pool].set(&#39;{:.2f}&#39;.format(tokens[pool]))
            self.setPoolEmphasis(pool, &#39;normal&#39;)
            if tokens[pool] &gt; bestPoolTokens:
                bestPool, bestPoolTokens = pool, tokens[pool]
        self.setPoolEmphasis(bestPool, &#39;bold&#39;)

    def setPoolEmphasis(self, pool, emphasis):
        &#34;&#34;&#34;Finds the labels associated with the given pool and sets
        their font to have the given emphasis.

        Args:
            pool (str): The name of a summon pool.
            emphasis (str): One of &#39;normal&#39; or &#39;bold&#39;.

        &#34;&#34;&#34;
        self.labels[pool][0].config(font=(None, 11, emphasis))
        self.labels[pool][1].config(font=(None, 11, emphasis))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="legends.ui.dialogs.ModalMessage" href="dialogs.html#legends.ui.dialogs.ModalMessage">ModalMessage</a></li>
<li>tkinter.simpledialog.Dialog</li>
<li>tkinter.Toplevel</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Wm</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="legends.ui.rostertab.OptimalSummons.body"><code class="name flex">
<span>def <span class="ident">body</span></span>(<span>self, master)</span>
</code></dt>
<dd>
<div class="desc"><p>Create the body of the dialog.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def body(self, master):
    &#34;&#34;&#34;Create the body of the dialog.

    &#34;&#34;&#34;
    tk.Label(
        master,
        text=&#39;Average Tokens per 150 Orbs&#39;,
        font=(None, 13, &#39;bold&#39;)
    ).pack(pady=(0,10))
    results = tk.Frame(master)
    results.pack()
    for row, pool in enumerate(SUMMON_POOL):
        self.labels[pool] = (
            tk.Label(
                results, text=&#39;{} Pool:&#39;.format(pool)
            ),
            tk.Label(
                results, textvariable=self.values[pool], width=5
            )
        )
        self.labels[pool][0].grid(row=row, column=0, sticky=tk.W)
        self.labels[pool][1].grid(row=row, column=1, sticky=tk.E)
    tk.Checkbutton(
        master,
        text=&#39;exclude Common characters&#39;,
        variable=self.excludeCommons, command=self.refresh
    ).pack(pady=(10,0))
    self.refresh()</code></pre>
</details>
</dd>
<dt id="legends.ui.rostertab.OptimalSummons.refresh"><code class="name flex">
<span>def <span class="ident">refresh</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates the values in the <code>values</code> attribute and sets the
font emphasis of the labels so that the highest summon rate is
bold and the others are normal.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refresh(self):
    &#34;&#34;&#34;Updates the values in the `values` attribute and sets the
    font emphasis of the labels so that the highest summon rate is
    bold and the others are normal.

    &#34;&#34;&#34;
    bestPool = &#39;&#39;
    bestPoolTokens = -1
    tokens = {}
    for pool in SUMMON_POOL:
        roster = self.root.session.saveslot.roster
        tokens[pool] = 150 * roster.tokensPerOrb(
            pool, self.excludeCommons.get()
        )
        self.values[pool].set(&#39;{:.2f}&#39;.format(tokens[pool]))
        self.setPoolEmphasis(pool, &#39;normal&#39;)
        if tokens[pool] &gt; bestPoolTokens:
            bestPool, bestPoolTokens = pool, tokens[pool]
    self.setPoolEmphasis(bestPool, &#39;bold&#39;)</code></pre>
</details>
</dd>
<dt id="legends.ui.rostertab.OptimalSummons.setPoolEmphasis"><code class="name flex">
<span>def <span class="ident">setPoolEmphasis</span></span>(<span>self, pool, emphasis)</span>
</code></dt>
<dd>
<div class="desc"><p>Finds the labels associated with the given pool and sets
their font to have the given emphasis.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pool</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of a summon pool.</dd>
<dt><strong><code>emphasis</code></strong> :&ensp;<code>str</code></dt>
<dd>One of 'normal' or 'bold'.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setPoolEmphasis(self, pool, emphasis):
    &#34;&#34;&#34;Finds the labels associated with the given pool and sets
    their font to have the given emphasis.

    Args:
        pool (str): The name of a summon pool.
        emphasis (str): One of &#39;normal&#39; or &#39;bold&#39;.

    &#34;&#34;&#34;
    self.labels[pool][0].config(font=(None, 11, emphasis))
    self.labels[pool][1].config(font=(None, 11, emphasis))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="legends.ui.dialogs.ModalMessage" href="dialogs.html#legends.ui.dialogs.ModalMessage">ModalMessage</a></b></code>:
<ul class="hlist">
<li><code><a title="legends.ui.dialogs.ModalMessage.buttonbox" href="dialogs.html#legends.ui.dialogs.ModalMessage.buttonbox">buttonbox</a></code></li>
<li><code><a title="legends.ui.dialogs.ModalMessage.destroy" href="dialogs.html#legends.ui.dialogs.ModalMessage.destroy">destroy</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="legends.ui.rostertab.RosterFilter"><code class="flex name class">
<span>class <span class="ident">RosterFilter</span></span>
<span>(</span><span>filt=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Stores information about filtering a
<code><a title="legends.ui.rostertab.RosterTab" href="#legends.ui.rostertab.RosterTab">RosterTab</a></code>.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>rarities</code></strong> :&ensp;<code>dict</code></dt>
<dd>{<code>str</code>:<code>tk.BooleanVar</code>} A dictionary mapping
rarities to <code>tkinter</code> boolean variables indicating whether
the rarity is to be included in the
<code><a title="legends.ui.rostertab.RosterTab" href="#legends.ui.rostertab.RosterTab">RosterTab</a></code>.</dd>
<dt><strong><code>roles</code></strong> :&ensp;<code>dict</code></dt>
<dd>{<code>str</code>:<code>tk.BooleanVar</code>} A dictionary mapping roles
to <code>tkinter</code> boolean variables indicating whether the role
is to be included in the <code><a title="legends.ui.rostertab.RosterTab" href="#legends.ui.rostertab.RosterTab">RosterTab</a></code>.</dd>
<dt><strong><code>ranks</code></strong> :&ensp;<code>tuple</code></dt>
<dd>(<code>tk.IntVar</code>, <code>tk.IntVar</code>) The first value is the
minimum rank to include in the
<code><a title="legends.ui.rostertab.RosterTab" href="#legends.ui.rostertab.RosterTab">RosterTab</a></code>. The second is the maximum.</dd>
<dt><strong><code>levels</code></strong> :&ensp;<code>tuple</code></dt>
<dd>(<code>tk.IntVar</code>, <code>tk.IntVar</code>) The first value is
the minimum level to include in the
<code><a title="legends.ui.rostertab.RosterTab" href="#legends.ui.rostertab.RosterTab">RosterTab</a></code>. The second is the maximum.</dd>
</dl>
<p>The constructor creates a new <code><a title="legends.ui.rostertab.RosterFilter" href="#legends.ui.rostertab.RosterFilter">RosterFilter</a></code> object with the
same values as the given <code><a title="legends.ui.rostertab.RosterFilter" href="#legends.ui.rostertab.RosterFilter">RosterFilter</a></code> object. If <code>None</code> is
provided, the new filter will not omit anything.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filt</code></strong> :&ensp;<code><a title="legends.ui.rostertab.RosterFilter" href="#legends.ui.rostertab.RosterFilter">RosterFilter</a></code></dt>
<dd>The filter used to initialize the new
filter.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RosterFilter():
    &#34;&#34;&#34;Stores information about filtering a
    `legends.ui.rostertab.RosterTab`.

    Attributes:
        rarities (dict): {`str`:`tk.BooleanVar`} A dictionary mapping
            rarities to `tkinter` boolean variables indicating whether
            the rarity is to be included in the
            `legends.ui.rostertab.RosterTab`.
        roles (dict): {`str`:`tk.BooleanVar`} A dictionary mapping roles
            to `tkinter` boolean variables indicating whether the role
            is to be included in the `legends.ui.rostertab.RosterTab`.
        ranks (tuple): (`tk.IntVar`, `tk.IntVar`) The first value is the
            minimum rank to include in the
            `legends.ui.rostertab.RosterTab`. The second is the maximum.
        levels (tuple): (`tk.IntVar`, `tk.IntVar`) The first value is
            the minimum level to include in the
            `legends.ui.rostertab.RosterTab`. The second is the maximum.

    &#34;&#34;&#34;

    def __init__(self, filt=None):
        &#34;&#34;&#34;The constructor creates a new `RosterFilter` object with the
        same values as the given `RosterFilter` object. If `None` is
        provided, the new filter will not omit anything.

        Args:
            filt (RosterFilter): The filter used to initialize the new
                filter.

        &#34;&#34;&#34;
        self.rarities = {
            rarity: tk.BooleanVar(None, True) for rarity in RARITIES
        }
        self.roles = {
            role: tk.BooleanVar(None, True) for role in ROLES
        }
        self.ranks = (tk.IntVar(None, 1), tk.IntVar(None, 9))
        self.levels = (tk.IntVar(None, 1), tk.IntVar(None, 99))
        if filt is not None:
            self.set(filt)

    def set(self, filt):
        &#34;&#34;&#34;Sets the values of the calling instance to match those of the
        given filter.

        Args:
            filt (RosterFilter): The filter from which to copy values.

        &#34;&#34;&#34;
        for rarity, var in self.rarities.items():
            var.set(filt.rarities[rarity].get())
        for role, var in self.roles.items():
            var.set(filt.roles[role].get())
        for j in (0, 1):
            self.ranks[j].set(filt.ranks[j].get())
        for j in (0, 1):
            self.levels[j].set(filt.levels[j].get())

    def dictify(self):
        &#34;&#34;&#34;Creates and returns a dictionary mapping the calling
        instance&#39;s attribute names to its values, with each `tkinter`
        variable replaced by its value.

        Returns:
            dict: The constructed dictionary.

        &#34;&#34;&#34;
        D = {}
        D[&#39;rarities&#39;] = {
            rarity: var.get() for rarity, var in self.rarities.items()
        }
        D[&#39;roles&#39;] = {
            role: var.get() for role, var in self.roles.items()
        }
        D[&#39;ranks&#39;] = (self.ranks[0].get(), self.ranks[1].get())
        D[&#39;levels&#39;] = (self.levels[0].get(), self.levels[1].get())
        return D

    def __eq__(self, other):
        return self.dictify() == other.dictify()

    def __repr__(self):
        return &#39;RosterFilter({})&#39;.format(self.dictify())</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="legends.ui.rostertab.RosterFilter.dictify"><code class="name flex">
<span>def <span class="ident">dictify</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and returns a dictionary mapping the calling
instance's attribute names to its values, with each <code>tkinter</code>
variable replaced by its value.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>The constructed dictionary.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dictify(self):
    &#34;&#34;&#34;Creates and returns a dictionary mapping the calling
    instance&#39;s attribute names to its values, with each `tkinter`
    variable replaced by its value.

    Returns:
        dict: The constructed dictionary.

    &#34;&#34;&#34;
    D = {}
    D[&#39;rarities&#39;] = {
        rarity: var.get() for rarity, var in self.rarities.items()
    }
    D[&#39;roles&#39;] = {
        role: var.get() for role, var in self.roles.items()
    }
    D[&#39;ranks&#39;] = (self.ranks[0].get(), self.ranks[1].get())
    D[&#39;levels&#39;] = (self.levels[0].get(), self.levels[1].get())
    return D</code></pre>
</details>
</dd>
<dt id="legends.ui.rostertab.RosterFilter.set"><code class="name flex">
<span>def <span class="ident">set</span></span>(<span>self, filt)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the values of the calling instance to match those of the
given filter.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filt</code></strong> :&ensp;<code><a title="legends.ui.rostertab.RosterFilter" href="#legends.ui.rostertab.RosterFilter">RosterFilter</a></code></dt>
<dd>The filter from which to copy values.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set(self, filt):
    &#34;&#34;&#34;Sets the values of the calling instance to match those of the
    given filter.

    Args:
        filt (RosterFilter): The filter from which to copy values.

    &#34;&#34;&#34;
    for rarity, var in self.rarities.items():
        var.set(filt.rarities[rarity].get())
    for role, var in self.roles.items():
        var.set(filt.roles[role].get())
    for j in (0, 1):
        self.ranks[j].set(filt.ranks[j].get())
    for j in (0, 1):
        self.levels[j].set(filt.levels[j].get())</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="legends.ui.rostertab.RosterInfoBar"><code class="flex name class">
<span>class <span class="ident">RosterInfoBar</span></span>
<span>(</span><span>parent=None, **options)</span>
</code></dt>
<dd>
<div class="desc"><p>A frame for displaying aggregate data about the user's roster.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>totalXP</code></strong> :&ensp;<code>tk.Label</code></dt>
<dd>A label displaying the total XP.</dd>
<dt><strong><code>totalPower</code></strong> :&ensp;<code>tk.Label</code></dt>
<dd>A label displaying the total power.</dd>
<dt><strong><code>charCount</code></strong> :&ensp;<code>tk.Label</code></dt>
<dd>A label displaying the number of
characters in the roster.</dd>
</dl>
<p>The constructor passes its arguments to the <code>tk.Frame</code>
constructor, then builds and packs the attribute labels.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RosterInfoBar(tk.Frame):
    &#34;&#34;&#34;A frame for displaying aggregate data about the user&#39;s roster.

    Attributes:
        totalXP (tk.Label): A label displaying the total XP.
        totalPower (tk.Label): A label displaying the total power.
        charCount (tk.Label): A label displaying the number of
            characters in the roster.

    &#34;&#34;&#34;
    def __init__(self, parent=None, **options):
        &#34;&#34;&#34;The constructor passes its arguments to the `tk.Frame`
        constructor, then builds and packs the attribute labels.

        &#34;&#34;&#34;
        tk.Frame.__init__(self, parent, **options)
        self.totalXP = tk.Label(
            self, borderwidth=2, relief=tk.GROOVE, padx=10
        )
        self.totalXP.pack(side=tk.LEFT)
        self.totalPower = tk.Label(
            self, borderwidth=2, relief=tk.GROOVE, padx=10
        )
        self.totalPower.pack(side=tk.LEFT)
        self.charCount = tk.Label(
            self, borderwidth=2, relief=tk.GROOVE, padx=10
        )
        self.charCount.pack(side=tk.LEFT)

    def makeStats(self, chars, roster):
        &#34;&#34;&#34;Computes and redisplays roster statistics using the given
        collection of characters.

        Args:
            chars (iterable of legends.gameobjects.Character): The
                characters to use when computing statistics.
            roster (legends.roster.Roster): The roster to which the
                characters belong.

        &#34;&#34;&#34;
        self.totalXP.config(text=&#39;Total XP: {:,}&#39;.format(sum(
            char.xp for char in chars
        )))
        self.totalPower.config(text=&#39;Total power: {:,.0f}&#39;.format(sum(
            POWER_AT_ORIGIN + roster.charStats(char.nameID).power
            for char in chars
        )))
        self.charCount.config(text=&#39;Characters: {}/{}&#39;.format(
            len(list(chars)), len(ENABLED)
        ))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tkinter.Frame</li>
<li>tkinter.Widget</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Pack</li>
<li>tkinter.Place</li>
<li>tkinter.Grid</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="legends.ui.rostertab.RosterInfoBar.makeStats"><code class="name flex">
<span>def <span class="ident">makeStats</span></span>(<span>self, chars, roster)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes and redisplays roster statistics using the given
collection of characters.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>chars</code></strong> :&ensp;<code>iterable</code> of <code><a title="legends.gameobjects.Character" href="../gameobjects.html#legends.gameobjects.Character">Character</a></code></dt>
<dd>The
characters to use when computing statistics.</dd>
<dt><strong><code>roster</code></strong> :&ensp;<code><a title="legends.roster.Roster" href="../roster.html#legends.roster.Roster">Roster</a></code></dt>
<dd>The roster to which the
characters belong.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def makeStats(self, chars, roster):
    &#34;&#34;&#34;Computes and redisplays roster statistics using the given
    collection of characters.

    Args:
        chars (iterable of legends.gameobjects.Character): The
            characters to use when computing statistics.
        roster (legends.roster.Roster): The roster to which the
            characters belong.

    &#34;&#34;&#34;
    self.totalXP.config(text=&#39;Total XP: {:,}&#39;.format(sum(
        char.xp for char in chars
    )))
    self.totalPower.config(text=&#39;Total power: {:,.0f}&#39;.format(sum(
        POWER_AT_ORIGIN + roster.charStats(char.nameID).power
        for char in chars
    )))
    self.charCount.config(text=&#39;Characters: {}/{}&#39;.format(
        len(list(chars)), len(ENABLED)
    ))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="legends.ui.rostertab.RosterTab"><code class="flex name class">
<span>class <span class="ident">RosterTab</span></span>
<span>(</span><span>session, **options)</span>
</code></dt>
<dd>
<div class="desc"><p>Displays the player's character collection.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>filter</code></strong> :&ensp;<code><a title="legends.ui.rostertab.RosterFilter" href="#legends.ui.rostertab.RosterFilter">RosterFilter</a></code></dt>
<dd>The <code><a title="legends.ui.rostertab.RosterFilter" href="#legends.ui.rostertab.RosterFilter">RosterFilter</a></code> object storing the
current filter settings.</dd>
<dt><strong><code>scrollArea</code></strong> :&ensp;<code><a title="legends.utils.scrollframe.ScrollFrame" href="../utils/scrollframe.html#legends.utils.scrollframe.ScrollFrame">ScrollFrame</a></code></dt>
<dd>The
<code><a title="legends.utils.scrollframe.ScrollFrame" href="../utils/scrollframe.html#legends.utils.scrollframe.ScrollFrame">ScrollFrame</a></code> used to hold the
character cards.</dd>
<dt><strong><code>infoBar</code></strong> :&ensp;<code><a title="legends.ui.rostertab.RosterInfoBar" href="#legends.ui.rostertab.RosterInfoBar">RosterInfoBar</a></code></dt>
<dd>The info bar containing aggregate info
about the currently displayed characters.</dd>
<dt><strong><code>sortFuncs</code></strong> :&ensp;<code>dict</code></dt>
<dd>{<code>str</code>:<code>func</code>} A dictionary mapping field
names to functions that map <code><a title="legends.gameobjects.Character" href="../gameobjects.html#legends.gameobjects.Character">Character</a></code>
objects to a sortable value.</dd>
<dt><strong><code>sortField</code></strong> :&ensp;<code>tk.StringVar</code></dt>
<dd>The currently selected field name by
which the characters are sorted.</dd>
<dt><strong><code>descending</code></strong> :&ensp;<code>tk.BooleanVar</code></dt>
<dd><code>True</code> if characters should be
sorted in descending order.</dd>
</dl>
<p>The constructor creates an instance as a child of the given
session.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>session</code></strong> :&ensp;<code><a title="legends.ui.session.Session" href="session.html#legends.ui.session.Session">Session</a></code></dt>
<dd>The session to assign
as the instance's parent.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RosterTab(tk.Frame):
    &#34;&#34;&#34;Displays the player&#39;s character collection.

    Attributes:
        filter (RosterFilter): The `RosterFilter` object storing the
            current filter settings.
        scrollArea (legends.utils.scrollframe.ScrollFrame): The
            `legends.utils.scrollframe.ScrollFrame` used to hold the
            character cards.
        infoBar (RosterInfoBar): The info bar containing aggregate info
            about the currently displayed characters.
        sortFuncs (dict): {`str`:`func`} A dictionary mapping field
            names to functions that map `legends.gameobjects.Character`
            objects to a sortable value.
        sortField (tk.StringVar): The currently selected field name by
            which the characters are sorted.
        descending (tk.BooleanVar): `True` if characters should be
            sorted in descending order.

    &#34;&#34;&#34;

    def __init__(self, session, **options):
        &#34;&#34;&#34;The constructor creates an instance as a child of the given
        session.

        Args:
            session (legends.ui.session.Session): The session to assign
                as the instance&#39;s parent.

        &#34;&#34;&#34;
        # build frame and initialize variables
        tk.Frame.__init__(self, session, **options)
        self.filter = RosterFilter()

        # build widgets
        self.scrollArea = ScrollFrame(self)
        self.scrollArea.canvas.config(height=0.7 * self.winfo_screenheight())
        self.infoBar = RosterInfoBar(self)

        # pack frame content
        self.actionBar().pack(expand=tk.YES, fill=tk.X)
        self.scrollArea.pack(expand=tk.YES, fill=tk.BOTH)
        self.infoBar.pack()

        # fill scroll area with character cards
        self.fillCards()

    @property
    def root(self):
        &#34;&#34;&#34;`legends.ui.stlplanner.STLPlanner`: The currently running
        `legends.ui.stlplanner.STLPlanner` instance.
        &#34;&#34;&#34;
        return self.master.master

    @property
    def roster(self):
        &#34;&#34;&#34;`legends.roster.Roster`: The roster associated with this
        roster tab.
        &#34;&#34;&#34;
        return self.master.saveslot.roster

    @property
    def cards(self):
        &#34;&#34;&#34;`dict`: {`str`:`legends.ui.charcard.CharCard`} A dictionary
        mapping a character&#39;s name ID attribute to its character card.
        &#34;&#34;&#34;
        return {
            card.char.nameID : card
            for card in self.scrollArea.content.winfo_children()
            if isinstance(card, CharCard)
        }

    def checkFilter(self, char):
        &#34;&#34;&#34;Checks if the given character passes the current filter
        options.

        Args:
            char (legends.gameobjects.Character): The character to
                check.

        Returns:
            bool: `True` if the character passes.

        &#34;&#34;&#34;
        filt = self.filter.dictify()
        return(
            filt[&#39;rarities&#39;][char.rarity]
            and filt[&#39;roles&#39;][char.role]
            and filt[&#39;ranks&#39;][0] &lt;= char.rank &lt;= filt[&#39;ranks&#39;][1]
            and filt[&#39;levels&#39;][0] &lt;= char.level &lt;= filt[&#39;levels&#39;][1]
        )

    def fillCards(self):
        &#34;&#34;&#34;Builds a card for each character in the player&#39;s collection
        and places it in the scroll area&#39;s content frame.

        &#34;&#34;&#34;
        columns = 4
        for j in range(columns):
            self.scrollArea.content.columnconfigure(
                j, weight=1, uniform=&#39;roster&#39;
            )
        count = 0
        chars = [
            char for char in self.roster.chars.values()
            if self.checkFilter(char)
        ]
        for char in chars:
            CharCard(char, self).grid(
                row=count // columns, column=count % columns, sticky=tk.NSEW
            )
            count += 1
        self.infoBar.makeStats(chars, self.roster)

    def actionBar(self):
        &#34;&#34;&#34;Builds and returns an action bar that allows the user to
        interact with the `RosterTab`.

        &#34;&#34;&#34;
        # define and initialize variables
        sslot = self.master.saveslot
        ros = self.roster
        self.sortFuncs = {
            &#39;Name&#39;: lambda c: c.shortName,
            &#39;Favorite&#39;: lambda c,s=sslot: c in s.favorites,
            &#39;Level&#39;: lambda c: c.xp,
            &#39;Rank&#39;: lambda c: c.rank,
            &#39;Rarity&#39;: lambda c: c.rarityIndex,
            &#39;Role&#39;: lambda c: c.role,
            &#39;Tokens&#39;: lambda c,s=sslot: s.tokens[c.nameID],
            &#39;Tokens needed&#39;: lambda c,s=sslot: (
                c.tokensNeeded - s.tokens[c.nameID]
            )
        }
        for statName in STAT_INITIALS:
            self.sortFuncs[statName] = lambda c,r=ros,n=statName: (
                r.charStats(c.nameID).get(n)
            )
        self.sortFuncs[&#39;Power&#39;] = lambda c,r=ros: (
            POWER_AT_ORIGIN + r.charStats(c.nameID).power
        )
        self.sortFuncs.update({
            &#39;Missing gear levels&#39;: lambda c,r=ros: (
                r.missingGearLevels(c.nameID)
            ),
            &#39;Missing gear ranks&#39;: lambda c,r=ros: (
                r.missingGearRanks(c.nameID)
            ),
            &#39;Missing skill levels&#39;: lambda c: c.missingSkillLevels
        })
        fields = list(self.sortFuncs.keys())
        self.sortField = tk.StringVar()
        self.descending = tk.BooleanVar()
        self.descending.set(True)

        # build bar and sorting Combobox
        bar = tk.Frame(self)
        sortMenu = ttk.Combobox(
            bar,
            textvariable=self.sortField,
            values=fields,
            state=&#39;readonly&#39;,
            width=max(len(field) for field in fields)
        )
        sortMenu.bind(&#39;&lt;&lt;ComboboxSelected&gt;&gt;&#39;, lambda event:self.sort())

        # pack and return bar
        tk.Label(bar, text=&#39;sort by:&#39;).pack(side=tk.LEFT)
        sortMenu.pack(side=tk.LEFT)
        tk.Checkbutton(
            bar, text=&#39;descending&#39;, variable=self.descending, command=self.sort
        ).pack(side=tk.LEFT)
        tk.Button(
            bar, text=&#39;filter&#39;, width=6, command=self.adjustFilter
        ).pack(side=tk.LEFT)
        tk.Button(
            bar, text=&#39;export&#39;, width=6, command=self.export
        ).pack(side=tk.LEFT)
        tk.Button(
            bar, text=&#39;summon pools&#39;, command=self.optimalSummons
        ).pack(side=tk.RIGHT)
        return bar

    def optimalSummons(self):
        &#34;&#34;&#34;Raises an `OptimalSummons` message window showing the summon
        rates for the various summon pools.

        &#34;&#34;&#34;
        OptimalSummons(self.root)

    def sort(self):
        &#34;&#34;&#34;Sorts the dictionary of characters stored in the associated
        `legends.saveslot.SaveSlot` object according the currently
        selected sorting field. Then refreshes the character cards.

        &#34;&#34;&#34;
        field = self.sortField.get()
        if field == &#39;&#39;:
            return
        self.master.saveslot.sort(
            self.sortFuncs[field], self.descending.get()
        )
        self.refresh()

    def refresh(self):
        &#34;&#34;&#34;Destroys and rebuilds all character cards.

        &#34;&#34;&#34;
        for card in self.cards.values():
            card.destroy()
        self.fillCards()

    def adjustFilter(self):
        &#34;&#34;&#34;Creates an `AskRosterFilter` window, giving the user an
        opportunity to adjust the filter settings. Then refreshes the
        character cards and info bar.

        &#34;&#34;&#34;
        filt = AskRosterFilter(self.root, self.filter).result
        if filt is not None:
            self.filter = filt
            self.refresh()

    def export(self):
        &#34;&#34;&#34;Exports the data in the character cards to a csv file. Each
        row in the file corresponds to a card, and the data in that row
        is the data generated by the card&#39;s
        `legends.ui.charcard.CharCard.dictify` method.

        &#34;&#34;&#34;
        filename = asksaveasfilename(
            self.root,
            defaultextension=&#39;csv&#39;,
            initialdir=&#39;/Users/&#39; + getuser() + &#39;/Documents/&#39;,
            initialfile=&#39;roster.csv&#39;,
            title=&#39;Export Roster&#39;,
            filetypes=[(&#39;Text CSV&#39;, &#39;*.csv&#39;)]
        )
        if not filename:
            return
        cardDicts = [card.dictify() for card in self.cards.values()]
        fields = cardDicts[0].keys()
        with open(filename, &#39;w&#39;, newline=&#39;&#39;, encoding=&#39;utf-8&#39;) as f:
            writer = DictWriter(f, fields)
            writer.writeheader()
            writer.writerows(cardDicts)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tkinter.Frame</li>
<li>tkinter.Widget</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Pack</li>
<li>tkinter.Place</li>
<li>tkinter.Grid</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="legends.ui.rostertab.RosterTab.cards"><code class="name">var <span class="ident">cards</span></code></dt>
<dd>
<div class="desc"><p><code>dict</code>: {<code>str</code>:<code><a title="legends.ui.charcard.CharCard" href="charcard.html#legends.ui.charcard.CharCard">CharCard</a></code>} A dictionary
mapping a character's name ID attribute to its character card.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cards(self):
    &#34;&#34;&#34;`dict`: {`str`:`legends.ui.charcard.CharCard`} A dictionary
    mapping a character&#39;s name ID attribute to its character card.
    &#34;&#34;&#34;
    return {
        card.char.nameID : card
        for card in self.scrollArea.content.winfo_children()
        if isinstance(card, CharCard)
    }</code></pre>
</details>
</dd>
<dt id="legends.ui.rostertab.RosterTab.root"><code class="name">var <span class="ident">root</span></code></dt>
<dd>
<div class="desc"><p><code><a title="legends.ui.stlplanner.STLPlanner" href="stlplanner.html#legends.ui.stlplanner.STLPlanner">STLPlanner</a></code>: The currently running
<code><a title="legends.ui.stlplanner.STLPlanner" href="stlplanner.html#legends.ui.stlplanner.STLPlanner">STLPlanner</a></code> instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def root(self):
    &#34;&#34;&#34;`legends.ui.stlplanner.STLPlanner`: The currently running
    `legends.ui.stlplanner.STLPlanner` instance.
    &#34;&#34;&#34;
    return self.master.master</code></pre>
</details>
</dd>
<dt id="legends.ui.rostertab.RosterTab.roster"><code class="name">var <span class="ident">roster</span></code></dt>
<dd>
<div class="desc"><p><code><a title="legends.roster.Roster" href="../roster.html#legends.roster.Roster">Roster</a></code>: The roster associated with this
roster tab.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def roster(self):
    &#34;&#34;&#34;`legends.roster.Roster`: The roster associated with this
    roster tab.
    &#34;&#34;&#34;
    return self.master.saveslot.roster</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="legends.ui.rostertab.RosterTab.actionBar"><code class="name flex">
<span>def <span class="ident">actionBar</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Builds and returns an action bar that allows the user to
interact with the <code><a title="legends.ui.rostertab.RosterTab" href="#legends.ui.rostertab.RosterTab">RosterTab</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def actionBar(self):
    &#34;&#34;&#34;Builds and returns an action bar that allows the user to
    interact with the `RosterTab`.

    &#34;&#34;&#34;
    # define and initialize variables
    sslot = self.master.saveslot
    ros = self.roster
    self.sortFuncs = {
        &#39;Name&#39;: lambda c: c.shortName,
        &#39;Favorite&#39;: lambda c,s=sslot: c in s.favorites,
        &#39;Level&#39;: lambda c: c.xp,
        &#39;Rank&#39;: lambda c: c.rank,
        &#39;Rarity&#39;: lambda c: c.rarityIndex,
        &#39;Role&#39;: lambda c: c.role,
        &#39;Tokens&#39;: lambda c,s=sslot: s.tokens[c.nameID],
        &#39;Tokens needed&#39;: lambda c,s=sslot: (
            c.tokensNeeded - s.tokens[c.nameID]
        )
    }
    for statName in STAT_INITIALS:
        self.sortFuncs[statName] = lambda c,r=ros,n=statName: (
            r.charStats(c.nameID).get(n)
        )
    self.sortFuncs[&#39;Power&#39;] = lambda c,r=ros: (
        POWER_AT_ORIGIN + r.charStats(c.nameID).power
    )
    self.sortFuncs.update({
        &#39;Missing gear levels&#39;: lambda c,r=ros: (
            r.missingGearLevels(c.nameID)
        ),
        &#39;Missing gear ranks&#39;: lambda c,r=ros: (
            r.missingGearRanks(c.nameID)
        ),
        &#39;Missing skill levels&#39;: lambda c: c.missingSkillLevels
    })
    fields = list(self.sortFuncs.keys())
    self.sortField = tk.StringVar()
    self.descending = tk.BooleanVar()
    self.descending.set(True)

    # build bar and sorting Combobox
    bar = tk.Frame(self)
    sortMenu = ttk.Combobox(
        bar,
        textvariable=self.sortField,
        values=fields,
        state=&#39;readonly&#39;,
        width=max(len(field) for field in fields)
    )
    sortMenu.bind(&#39;&lt;&lt;ComboboxSelected&gt;&gt;&#39;, lambda event:self.sort())

    # pack and return bar
    tk.Label(bar, text=&#39;sort by:&#39;).pack(side=tk.LEFT)
    sortMenu.pack(side=tk.LEFT)
    tk.Checkbutton(
        bar, text=&#39;descending&#39;, variable=self.descending, command=self.sort
    ).pack(side=tk.LEFT)
    tk.Button(
        bar, text=&#39;filter&#39;, width=6, command=self.adjustFilter
    ).pack(side=tk.LEFT)
    tk.Button(
        bar, text=&#39;export&#39;, width=6, command=self.export
    ).pack(side=tk.LEFT)
    tk.Button(
        bar, text=&#39;summon pools&#39;, command=self.optimalSummons
    ).pack(side=tk.RIGHT)
    return bar</code></pre>
</details>
</dd>
<dt id="legends.ui.rostertab.RosterTab.adjustFilter"><code class="name flex">
<span>def <span class="ident">adjustFilter</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates an <code><a title="legends.ui.rostertab.AskRosterFilter" href="#legends.ui.rostertab.AskRosterFilter">AskRosterFilter</a></code> window, giving the user an
opportunity to adjust the filter settings. Then refreshes the
character cards and info bar.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def adjustFilter(self):
    &#34;&#34;&#34;Creates an `AskRosterFilter` window, giving the user an
    opportunity to adjust the filter settings. Then refreshes the
    character cards and info bar.

    &#34;&#34;&#34;
    filt = AskRosterFilter(self.root, self.filter).result
    if filt is not None:
        self.filter = filt
        self.refresh()</code></pre>
</details>
</dd>
<dt id="legends.ui.rostertab.RosterTab.checkFilter"><code class="name flex">
<span>def <span class="ident">checkFilter</span></span>(<span>self, char)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if the given character passes the current filter
options.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>char</code></strong> :&ensp;<code><a title="legends.gameobjects.Character" href="../gameobjects.html#legends.gameobjects.Character">Character</a></code></dt>
<dd>The character to
check.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd><code>True</code> if the character passes.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def checkFilter(self, char):
    &#34;&#34;&#34;Checks if the given character passes the current filter
    options.

    Args:
        char (legends.gameobjects.Character): The character to
            check.

    Returns:
        bool: `True` if the character passes.

    &#34;&#34;&#34;
    filt = self.filter.dictify()
    return(
        filt[&#39;rarities&#39;][char.rarity]
        and filt[&#39;roles&#39;][char.role]
        and filt[&#39;ranks&#39;][0] &lt;= char.rank &lt;= filt[&#39;ranks&#39;][1]
        and filt[&#39;levels&#39;][0] &lt;= char.level &lt;= filt[&#39;levels&#39;][1]
    )</code></pre>
</details>
</dd>
<dt id="legends.ui.rostertab.RosterTab.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Exports the data in the character cards to a csv file. Each
row in the file corresponds to a card, and the data in that row
is the data generated by the card's
<code><a title="legends.ui.charcard.CharCard.dictify" href="charcard.html#legends.ui.charcard.CharCard.dictify">CharCard.dictify()</a></code> method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self):
    &#34;&#34;&#34;Exports the data in the character cards to a csv file. Each
    row in the file corresponds to a card, and the data in that row
    is the data generated by the card&#39;s
    `legends.ui.charcard.CharCard.dictify` method.

    &#34;&#34;&#34;
    filename = asksaveasfilename(
        self.root,
        defaultextension=&#39;csv&#39;,
        initialdir=&#39;/Users/&#39; + getuser() + &#39;/Documents/&#39;,
        initialfile=&#39;roster.csv&#39;,
        title=&#39;Export Roster&#39;,
        filetypes=[(&#39;Text CSV&#39;, &#39;*.csv&#39;)]
    )
    if not filename:
        return
    cardDicts = [card.dictify() for card in self.cards.values()]
    fields = cardDicts[0].keys()
    with open(filename, &#39;w&#39;, newline=&#39;&#39;, encoding=&#39;utf-8&#39;) as f:
        writer = DictWriter(f, fields)
        writer.writeheader()
        writer.writerows(cardDicts)</code></pre>
</details>
</dd>
<dt id="legends.ui.rostertab.RosterTab.fillCards"><code class="name flex">
<span>def <span class="ident">fillCards</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Builds a card for each character in the player's collection
and places it in the scroll area's content frame.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fillCards(self):
    &#34;&#34;&#34;Builds a card for each character in the player&#39;s collection
    and places it in the scroll area&#39;s content frame.

    &#34;&#34;&#34;
    columns = 4
    for j in range(columns):
        self.scrollArea.content.columnconfigure(
            j, weight=1, uniform=&#39;roster&#39;
        )
    count = 0
    chars = [
        char for char in self.roster.chars.values()
        if self.checkFilter(char)
    ]
    for char in chars:
        CharCard(char, self).grid(
            row=count // columns, column=count % columns, sticky=tk.NSEW
        )
        count += 1
    self.infoBar.makeStats(chars, self.roster)</code></pre>
</details>
</dd>
<dt id="legends.ui.rostertab.RosterTab.optimalSummons"><code class="name flex">
<span>def <span class="ident">optimalSummons</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Raises an <code><a title="legends.ui.rostertab.OptimalSummons" href="#legends.ui.rostertab.OptimalSummons">OptimalSummons</a></code> message window showing the summon
rates for the various summon pools.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def optimalSummons(self):
    &#34;&#34;&#34;Raises an `OptimalSummons` message window showing the summon
    rates for the various summon pools.

    &#34;&#34;&#34;
    OptimalSummons(self.root)</code></pre>
</details>
</dd>
<dt id="legends.ui.rostertab.RosterTab.refresh"><code class="name flex">
<span>def <span class="ident">refresh</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Destroys and rebuilds all character cards.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refresh(self):
    &#34;&#34;&#34;Destroys and rebuilds all character cards.

    &#34;&#34;&#34;
    for card in self.cards.values():
        card.destroy()
    self.fillCards()</code></pre>
</details>
</dd>
<dt id="legends.ui.rostertab.RosterTab.sort"><code class="name flex">
<span>def <span class="ident">sort</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Sorts the dictionary of characters stored in the associated
<code><a title="legends.saveslot.SaveSlot" href="../saveslot.html#legends.saveslot.SaveSlot">SaveSlot</a></code> object according the currently
selected sorting field. Then refreshes the character cards.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sort(self):
    &#34;&#34;&#34;Sorts the dictionary of characters stored in the associated
    `legends.saveslot.SaveSlot` object according the currently
    selected sorting field. Then refreshes the character cards.

    &#34;&#34;&#34;
    field = self.sortField.get()
    if field == &#39;&#39;:
        return
    self.master.saveslot.sort(
        self.sortFuncs[field], self.descending.get()
    )
    self.refresh()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="legends.ui" href="index.html">legends.ui</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="legends.ui.rostertab.AskRosterFilter" href="#legends.ui.rostertab.AskRosterFilter">AskRosterFilter</a></code></h4>
<ul class="">
<li><code><a title="legends.ui.rostertab.AskRosterFilter.apply" href="#legends.ui.rostertab.AskRosterFilter.apply">apply</a></code></li>
<li><code><a title="legends.ui.rostertab.AskRosterFilter.body" href="#legends.ui.rostertab.AskRosterFilter.body">body</a></code></li>
<li><code><a title="legends.ui.rostertab.AskRosterFilter.buttonbox" href="#legends.ui.rostertab.AskRosterFilter.buttonbox">buttonbox</a></code></li>
<li><code><a title="legends.ui.rostertab.AskRosterFilter.clear" href="#legends.ui.rostertab.AskRosterFilter.clear">clear</a></code></li>
<li><code><a title="legends.ui.rostertab.AskRosterFilter.makeLinkedScales" href="#legends.ui.rostertab.AskRosterFilter.makeLinkedScales">makeLinkedScales</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="legends.ui.rostertab.OptimalSummons" href="#legends.ui.rostertab.OptimalSummons">OptimalSummons</a></code></h4>
<ul class="">
<li><code><a title="legends.ui.rostertab.OptimalSummons.body" href="#legends.ui.rostertab.OptimalSummons.body">body</a></code></li>
<li><code><a title="legends.ui.rostertab.OptimalSummons.refresh" href="#legends.ui.rostertab.OptimalSummons.refresh">refresh</a></code></li>
<li><code><a title="legends.ui.rostertab.OptimalSummons.setPoolEmphasis" href="#legends.ui.rostertab.OptimalSummons.setPoolEmphasis">setPoolEmphasis</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="legends.ui.rostertab.RosterFilter" href="#legends.ui.rostertab.RosterFilter">RosterFilter</a></code></h4>
<ul class="">
<li><code><a title="legends.ui.rostertab.RosterFilter.dictify" href="#legends.ui.rostertab.RosterFilter.dictify">dictify</a></code></li>
<li><code><a title="legends.ui.rostertab.RosterFilter.set" href="#legends.ui.rostertab.RosterFilter.set">set</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="legends.ui.rostertab.RosterInfoBar" href="#legends.ui.rostertab.RosterInfoBar">RosterInfoBar</a></code></h4>
<ul class="">
<li><code><a title="legends.ui.rostertab.RosterInfoBar.makeStats" href="#legends.ui.rostertab.RosterInfoBar.makeStats">makeStats</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="legends.ui.rostertab.RosterTab" href="#legends.ui.rostertab.RosterTab">RosterTab</a></code></h4>
<ul class="two-column">
<li><code><a title="legends.ui.rostertab.RosterTab.actionBar" href="#legends.ui.rostertab.RosterTab.actionBar">actionBar</a></code></li>
<li><code><a title="legends.ui.rostertab.RosterTab.adjustFilter" href="#legends.ui.rostertab.RosterTab.adjustFilter">adjustFilter</a></code></li>
<li><code><a title="legends.ui.rostertab.RosterTab.cards" href="#legends.ui.rostertab.RosterTab.cards">cards</a></code></li>
<li><code><a title="legends.ui.rostertab.RosterTab.checkFilter" href="#legends.ui.rostertab.RosterTab.checkFilter">checkFilter</a></code></li>
<li><code><a title="legends.ui.rostertab.RosterTab.export" href="#legends.ui.rostertab.RosterTab.export">export</a></code></li>
<li><code><a title="legends.ui.rostertab.RosterTab.fillCards" href="#legends.ui.rostertab.RosterTab.fillCards">fillCards</a></code></li>
<li><code><a title="legends.ui.rostertab.RosterTab.optimalSummons" href="#legends.ui.rostertab.RosterTab.optimalSummons">optimalSummons</a></code></li>
<li><code><a title="legends.ui.rostertab.RosterTab.refresh" href="#legends.ui.rostertab.RosterTab.refresh">refresh</a></code></li>
<li><code><a title="legends.ui.rostertab.RosterTab.root" href="#legends.ui.rostertab.RosterTab.root">root</a></code></li>
<li><code><a title="legends.ui.rostertab.RosterTab.roster" href="#legends.ui.rostertab.RosterTab.roster">roster</a></code></li>
<li><code><a title="legends.ui.rostertab.RosterTab.sort" href="#legends.ui.rostertab.RosterTab.sort">sort</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>