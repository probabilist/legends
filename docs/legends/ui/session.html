<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>legends.ui.session API documentation</title>
<meta name="description" content="The `legends.ui.session.Session` class and related objects." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>legends.ui.session</code></h1>
</header>
<section id="section-intro">
<p>The <code><a title="legends.ui.session.Session" href="#legends.ui.session.Session">Session</a></code> class and related objects.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;The `legends.ui.session.Session` class and related objects.

&#34;&#34;&#34;

import tkinter as tk
from tkinter import ttk
from getpass import getuser
from legends.utils.relations import bidict
from legends.utils.scrollframe import ScrollFrame
from legends.constants import ITEMS
from legends.functions import cleanTime, levelFromXP, xpFromLevel
from legends.saveslot import Inventory
from legends.ui.dialogs import ModalMessage
from legends.ui.rostertab import RosterTab, RosterFilter
from legends.ui.chartab import CharTab

__all__ = [
    &#39;InventoryScreen&#39;,
    &#39;MissingMissions&#39;,
    &#39;Session&#39;,
    &#39;SessionSettings&#39;,
    &#39;SurvivalEffects&#39;
]

class InventoryScreen(ModalMessage):
    &#34;&#34;&#34;A message dialog showing the player&#39;s inventory.

    Attributes:
        levelMap (legends.utils.relations.bidict): {`int`:`int`} After
            fully leveling, from 1 to 99, as many characters as possible
            with the bio-gel items in the inventory, a certain amount of
            excess bio-gel will remain. A `key`, `value` pair in this
            dictionary means that this excess bio-gel can level a
            character of level `key` to level `value`.
        startLevel (tk.StringVar): The level displayed in the starting
            level combo-box.
        endLevel (tk.StringVar): The level displayed in the ending level
            combo-box.

    &#34;&#34;&#34;
    def __init__(self, root, parent=None):
        self.root = root
        self.levelMap = bidict()
        extraXP = self.inventory.xp % xpFromLevel(99)
        for start in range(1,99):
            end = levelFromXP(xpFromLevel(start) + extraXP)
            if start &gt; 1 and start == end:
                break
            try:
                self.levelMap[start] = end
            except ValueError:
                pass
        self.startLevel = tk.StringVar(None, &#39;1&#39;)
        self.endLevel = tk.StringVar()
        self.setEndLevel()
        ModalMessage.__init__(self, root, parent, &#39;Inventory&#39;)

    @property
    def inventory(self):
        &#34;&#34;&#34;`legends.constants.Inventory`: The inventory associated
        with the current session.
        &#34;&#34;&#34;
        return self.root.session.saveslot.inventory

    @property
    def roster(self):
        &#34;&#34;&#34;`legends.roster.Roster`: The roster associated with the
        current session.
        &#34;&#34;&#34;
        return self.root.session.saveslot.roster

    def body(self, master):
        &#34;&#34;&#34;Create the body of the dialog.

        &#34;&#34;&#34;
        # grid the inventory quantities
        self.displayCat(master, &#39;Currency&#39;, (0, 0))
        self.displayCat(master, &#39;General Items&#39;, (0, 2))
        self.displayCat(master, &#39;Bio-Gel&#39;, (4, 0), True)
        self.displayCat(master, &#39;Protomatter&#39;, (10, 0), True)
        self.displayCat(master, &#39;Gear Leveling Materials&#39;, (16, 0), True)
        self.displayCat(master, &#39;Gear Ranking Materials&#39;, (16, 2), True)

        # show total XP
        tk.Label(
            master, text=&#39;TOTAL BIO-GEL XP:&#39;, font=(None, 13, &#39;italic&#39;)
        ).grid(row=5, column=2, sticky=tk.W, padx=(20,0))
        tk.Label(
            master, text=&#39;{:,}&#39;.format(self.inventory.xp)
        ).grid(row=5, column=3, sticky=tk.E, padx=(0,20))

        # show number of characters can level
        chars = int(self.inventory.xp/xpFromLevel(99))
        tk.Label(
            master,
            text=&#39;Can fully level {} character{},&#39;.format(
                chars,
                &#39;s&#39; if chars &gt; 1 else &#39;&#39;
            )
        ).grid(row=6, column=2, columnspan=2, padx=(20,20))

        # show additional character, partial level
        tk.Label(
            master, text=&#39;and one more from&#39;
        ).grid(row=7, column=2, columnspan=2, padx=(20,20))

        # build combo-box level-checking tool
        bar = tk.Frame(master)

        # starting level combo-box
        tk.Label(bar, text=&#39;Level&#39;).pack(side=tk.LEFT)
        startLevelBox = ttk.Combobox(
            bar, textvariable=self.startLevel,
            values=[str(level) for level in self.levelMap],
            state=&#39;readonly&#39;, width=2
        )
        startLevelBox.pack(side=tk.LEFT)
        startLevelBox.bind(
            &#39;&lt;&lt;ComboboxSelected&gt;&gt;&#39;, lambda event:self.setEndLevel()
        )

        # ending level combo-box
        tk.Label(
            bar, text=&#39;to&#39;
        ).pack(side=tk.LEFT)
        endLevelBox = ttk.Combobox(
            bar, textvariable=self.endLevel,
            values=[str(level) for level in self.levelMap.values()],
            state=&#39;readonly&#39;, width=2
        )
        endLevelBox.pack(side=tk.LEFT)
        endLevelBox.bind(
            &#39;&lt;&lt;ComboboxSelected&gt;&gt;&#39;, lambda event:self.setStartLevel()
        )

        # pack combo-box level-checking tool
        bar.grid(row=8, column=2, columnspan=2, padx=(20,20))

        # show protomatter needed to max roster
        tk.Label(
            master, text=&#39;Needed to Max Roster&#39;, font=(None, 13, &#39;italic&#39;)
        ).grid(row=10, column=2, columnspan=2, sticky=tk.W, pady=(20,0))
        for index, item in enumerate(self.inventory.keysByCat(&#39;Protomatter&#39;)):
            totalNeeded = Inventory()
            for char in self.roster.chars.values():
                if char.role == item.role:
                    totalNeeded = sum(
                        (skill.itemsToMax for skill in char.skills.values()),
                        totalNeeded
                    )
            tk.Label(
                master, text=&#39;{:,} + {:,} Latinum&#39;.format(
                    totalNeeded[item],
                    totalNeeded[ITEMS[&#39;Latinum&#39;]]
                )
            ).grid(row=11 + index, column=2, sticky=tk.W)

    def setStartLevel(self):
        &#34;&#34;&#34;Sets the `tkinter` variable in the `startLevel` attribute
        according to the value of `endLevel`.

        &#34;&#34;&#34;
        self.startLevel.set(str(
            self.levelMap.inverse[int(self.endLevel.get())]
        ))

    def setEndLevel(self):
        &#34;&#34;&#34;Sets the `tkinter` variable in the `endLevel` attribute
        according to the value of `startLevel`.

        &#34;&#34;&#34;
        self.endLevel.set(str(
            self.levelMap[int(self.startLevel.get())]
        ))

    def displayCat(self, master, cat, coords, pad=False):
        &#34;&#34;&#34;Grids the headings, labels, and item quantities for the given
        category onto the given master object.

        Args:
            master (obj): The `tkinter` object to assign as master.
            cat (str): The category of items to grid.
            coords (tuple): (`int`,`int`) The row and column of the top
                left corner of the display.
            pad (bool): `True` if the display should have vertical
                padding above it.

        &#34;&#34;&#34;
        row, col = coords
        catLabel = tk.Label(master, text=cat, font=(None, 13, &#39;bold&#39;))
        catLabel.grid(row=row, column=col, columnspan=2, sticky=tk.W)
        if pad:
            catLabel.grid_configure(pady=(20,0))
        row += 1
        for item, qty in self.inventory.itemsByCat(cat):
            tk.Label(master, text=item.name).grid(
                row=row, column=col, sticky=tk.W, padx=(20,0)
            )
            tk.Label(master, text=&#39;{:,}&#39;.format(qty)).grid(
                row=row, column=col + 1, sticky=tk.E, padx=(0,20)
            )
            row += 1

class MissingMissions(ModalMessage):
    &#34;&#34;&#34;A message showing the player&#39;s incomplete missions.

    Also shows the total uncollected gear ranking materials.

    &#34;&#34;&#34;

    def __init__(self, root, parent=None):
        ModalMessage.__init__(self, root, parent, &#39;Incomplete Missions&#39;)

    def body(self, master):
        &#34;&#34;&#34;Create the body of the dialog.

        &#34;&#34;&#34;
        scrollFrame = ScrollFrame(master)
        display = tk.Frame(scrollFrame.content)
        scrollFrame.canvas.config(height=0.5 * self.winfo_screenheight())
        incompleteMissions = [
            mission for mission in self.root.session.saveslot.missions
            if mission.complete &lt; 1
        ]
        missingRewards = Inventory()
        for mission in incompleteMissions:
            missingRewards = missingRewards + mission.missingNodeRewards
            missingRewards = missingRewards + mission.rewards
        tk.Label(
            display,
            text=&#39;Uncollected Gear Ranking Materials&#39;,
            font=(None, 13, &#39;bold&#39;)
        ).grid(row=0, column=0, columnspan=3, sticky=tk.W)
        row = 1
        for item, qty in missingRewards.itemsByCat(&#39;Gear Ranking Materials&#39;):
            tk.Label(
                display, text=item.name
            ).grid(row=row, column=0, columnspan=2, sticky=tk.W)
            tk.Label(
                display, text=&#39;{:,}&#39;.format(qty)
            ).grid(row=row, column=2, sticky=tk.E)
            row += 1
        tk.Label(
            display, text=&#39;Incomplete Missions&#39;, font=(None, 13, &#39;bold&#39;)
        ).grid(row=row, column=0, columnspan=3, sticky=tk.W, pady=(20,0))
        row += 1
        for mission in incompleteMissions:
            tk.Label(
                display, text=mission.difficulty
            ).grid(row=row, column=0, sticky=tk.W)
            tk.Label(
                display,
                text=&#39;Episode {} Mission {}&#39;.format(
                    mission.episode,
                    mission.orderIndex
                )
            ).grid(row=row, column=1, sticky=tk.W)
            tk.Label(
                display, text=&#39;{:.0%}&#39;.format(mission.complete)
            ).grid(row=row, column=2, sticky=tk.E)
            row += 1
        display.pack(padx=20)
        scrollFrame.pack(expand=tk.YES, fill=tk.BOTH)

class Session(tk.Frame):
    &#34;&#34;&#34;A user session in the *STL Planner* app.

    Attributes:
        saveslot (legends.saveslot.SaveSlot): The
            `legends.saveslot.SaveSlot` object associated with the
            session.
        settings (SessionSettings): The `SessionSettings` instance that
            stores the settings for the current session.
        timeBar (tk.Frame): The horizontal bar at the top of the session
            frame that displays time stamp info connected with the
            associated save slot.
        tab (tk.Frame): The visible tab in the session frame.

    &#34;&#34;&#34;
    def __init__(self, stlplanner, saveslot=None, **options):
        &#34;&#34;&#34;The constructor creates a new session associated with the
        given `legends.saveslot.SaveSlot` object. If none is provided,
        the session displays buttons that activate choices from the
        `File` menu.

        Args:
            stlplanner (STLPlanner): The `STLPlanner` instance to be
                assigned as the parent of this session.

        &#34;&#34;&#34;
        tk.Frame.__init__(self, stlplanner, **options)
        self.saveslot = saveslot
        self.timeBar = None
        self.settings = SessionSettings()
        self.tab = tk.Frame(self)
        self.tab.pack()
        if saveslot is None:
            self.startFrame()
        else:
            self.makeTimeBar()
            self.rosterTab()

    def startFrame(self):
        &#34;&#34;&#34;Build the starting frame, with choices from the `File` menu.

        &#34;&#34;&#34;
        buttonbox = tk.Frame(self.tab)
        tk.Button(
            buttonbox, text=&#39;from HD&#39;, command=self.master.newFromFile
        ).grid(row=0, column=0, sticky=tk.EW)
        tk.Button(
            buttonbox,
            text=&#39;from Clipboard&#39;, command=self.master.newFromClipboard
        ).grid(row=1, column=0, sticky=tk.EW)
        tk.Button(
            buttonbox, text=&#39;MAX&#39;, command=self.master.newMaxChars
        ).grid(row=2, column=0, sticky=tk.EW)
        tk.Label(
            buttonbox, text=&#39;Extract data from your local save file&#39;
        ).grid(row=0, column=1, sticky=tk.W)
        tk.Label(
            buttonbox, text=&#39;Use a support email to extract your data&#39;
        ).grid(row=1, column=1, sticky=tk.W)
        tk.Label(
            buttonbox, text=&#39;Create a roster of maxed characters&#39;
        ).grid(row=2, column=1, sticky=tk.W)
        buttonbox.pack(padx=50, pady=50)

    def makeTimeBar(self):
        &#34;&#34;&#34;Builds a horizontal bar (a `tk.Frame` instance) containing
        timestamp information from the associated save slot, then
        assigns the bar to the `timeBar` attribute. If there is no save
        slot, or the time bar already exists, or the `STLPlanner` master
        prohibits it, the method does nothing.

        &#34;&#34;&#34;
        if (
            self.saveslot is None
            or self.timeBar is not None
            or not self.master.showTimestamps.get()
        ):
            return

        # build bar and initialize variables
        self.timeBar = tk.Frame(self)
        timestamps = self.saveslot.timestamps
        start = (
            &#39;start date: &#39;
            + timestamps.startDate.strftime(&#39;%b %-d %Y %H:%M %Z&#39;)
        )
        last = (
            &#39;last played: &#39;
            + timestamps.timeLastPlayed.strftime(&#39;%b %-d %Y %H:%M %Z&#39;)
        )
        total = (
            &#39;play duration: &#39; + cleanTime(timestamps.playDuration)
        )
        average = (
            &#39;play time per day: &#39; + cleanTime(timestamps.playTimePerDay)
        )

        # build labels
        labels = [None] * 4
        for j in range(4):
            labels[j] = tk.Label(
                self.timeBar, borderwidth=2, relief=tk.GROOVE, padx=10
            )
        for index, text in enumerate([start, last, total, average]):
            labels[index].config(text=text)

        # pack labels and bar
        for label in labels:
            label.pack(side=tk.LEFT)
        self.timeBar.pack(side=tk.TOP)

    def removeTimeBar(self):
        &#34;&#34;&#34;If the time bar exists, it is destroyed and the `timeBar`
        attribute is set to `None`.

        &#34;&#34;&#34;
        if self.timeBar is not None:
            self.timeBar.destroy()
            self.timeBar = None

    def rosterTab(self):
        &#34;&#34;&#34;Loads a new `legends.ui.rostertab.RosterTab` instance into
        the `tab` attribute.

        &#34;&#34;&#34;
        self.tab.destroy()
        self.tab = RosterTab(self)
        self.tab.pack(side=tk.BOTTOM, expand=tk.YES, fill=tk.Y)
        self.master.title(&#39;STL Planner - Roster&#39;)

    def charTab(self, char):
        &#34;&#34;&#34;Loads a new `legends.ui.chartab.CharTab` instance into the
        `tab` attribute.

        &#34;&#34;&#34;
        self.tab.destroy()
        self.tab = CharTab(char, self)
        self.tab.pack(side=tk.BOTTOM, expand=tk.YES, fill=tk.Y)
        self.master.title(&#39;STL Planner - {}&#39;.format(char.shortName))

class SessionSettings(): # pylint: disable=too-few-public-methods
    &#34;&#34;&#34;Stores the settings for a `Session`.

    Attributes:
        rosterFilter (legends.ui.rostertab.RosterFilter): The
            `legends.ui.rostertab.RosterFilter` object storing the
            current filter settings for the roster tab.
        rosterExportFile (str): The path to use when prompting the user
            to export their roster to a spreadsheet.
        excludeCommons (tk.BooleanVar): `True` is the summon rate
            calculations made by the roster tab should exclude Common
            characters.

    &#34;&#34;&#34;

    def __init__(self):
        self.rosterFilter = RosterFilter()
        self.rosterExportFile = &#39;/Users/&#39; + getuser() + &#39;/Documents/roster.csv&#39;
        self.excludeCommons = tk.BooleanVar(None, True)

class SurvivalEffects(ModalMessage):
    &#34;&#34;&#34;A message showing the active battle modifiers in survival mode.

    &#34;&#34;&#34;

    def __init__(self, root, parent=None):
        ModalMessage.__init__(self, root, parent, &#39;Active Survival Effects&#39;)

    def body(self, master):
        &#34;&#34;&#34;Create the body of the dialog.

        &#34;&#34;&#34;
        saveslot = self.root.session.saveslot
        count = 0
        for effect, duration in saveslot.survivalEffects.items():
            tk.Label(
                master, text=effect
            ).grid(row=count, column=0, sticky=tk.W, padx=(20,0))
            tk.Label(
                master, text=&#39;({} battles remaining)&#39;.format(duration)
            ).grid(row=count, column=1, sticky=tk.E, padx=(0,20))
            count += 1</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="legends.ui.session.InventoryScreen"><code class="flex name class">
<span>class <span class="ident">InventoryScreen</span></span>
<span>(</span><span>root, parent=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A message dialog showing the player's inventory.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>levelMap</code></strong> :&ensp;<code><a title="legends.utils.relations.bidict" href="../utils/relations.html#legends.utils.relations.bidict">bidict</a></code></dt>
<dd>{<code>int</code>:<code>int</code>} After
fully leveling, from 1 to 99, as many characters as possible
with the bio-gel items in the inventory, a certain amount of
excess bio-gel will remain. A <code>key</code>, <code>value</code> pair in this
dictionary means that this excess bio-gel can level a
character of level <code>key</code> to level <code>value</code>.</dd>
<dt><strong><code>startLevel</code></strong> :&ensp;<code>tk.StringVar</code></dt>
<dd>The level displayed in the starting
level combo-box.</dd>
<dt><strong><code>endLevel</code></strong> :&ensp;<code>tk.StringVar</code></dt>
<dd>The level displayed in the ending level
combo-box.</dd>
</dl>
<p>The constructor disables the root menu before calling the
<code>tk.simpledialog.Dialog</code> constructor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InventoryScreen(ModalMessage):
    &#34;&#34;&#34;A message dialog showing the player&#39;s inventory.

    Attributes:
        levelMap (legends.utils.relations.bidict): {`int`:`int`} After
            fully leveling, from 1 to 99, as many characters as possible
            with the bio-gel items in the inventory, a certain amount of
            excess bio-gel will remain. A `key`, `value` pair in this
            dictionary means that this excess bio-gel can level a
            character of level `key` to level `value`.
        startLevel (tk.StringVar): The level displayed in the starting
            level combo-box.
        endLevel (tk.StringVar): The level displayed in the ending level
            combo-box.

    &#34;&#34;&#34;
    def __init__(self, root, parent=None):
        self.root = root
        self.levelMap = bidict()
        extraXP = self.inventory.xp % xpFromLevel(99)
        for start in range(1,99):
            end = levelFromXP(xpFromLevel(start) + extraXP)
            if start &gt; 1 and start == end:
                break
            try:
                self.levelMap[start] = end
            except ValueError:
                pass
        self.startLevel = tk.StringVar(None, &#39;1&#39;)
        self.endLevel = tk.StringVar()
        self.setEndLevel()
        ModalMessage.__init__(self, root, parent, &#39;Inventory&#39;)

    @property
    def inventory(self):
        &#34;&#34;&#34;`legends.constants.Inventory`: The inventory associated
        with the current session.
        &#34;&#34;&#34;
        return self.root.session.saveslot.inventory

    @property
    def roster(self):
        &#34;&#34;&#34;`legends.roster.Roster`: The roster associated with the
        current session.
        &#34;&#34;&#34;
        return self.root.session.saveslot.roster

    def body(self, master):
        &#34;&#34;&#34;Create the body of the dialog.

        &#34;&#34;&#34;
        # grid the inventory quantities
        self.displayCat(master, &#39;Currency&#39;, (0, 0))
        self.displayCat(master, &#39;General Items&#39;, (0, 2))
        self.displayCat(master, &#39;Bio-Gel&#39;, (4, 0), True)
        self.displayCat(master, &#39;Protomatter&#39;, (10, 0), True)
        self.displayCat(master, &#39;Gear Leveling Materials&#39;, (16, 0), True)
        self.displayCat(master, &#39;Gear Ranking Materials&#39;, (16, 2), True)

        # show total XP
        tk.Label(
            master, text=&#39;TOTAL BIO-GEL XP:&#39;, font=(None, 13, &#39;italic&#39;)
        ).grid(row=5, column=2, sticky=tk.W, padx=(20,0))
        tk.Label(
            master, text=&#39;{:,}&#39;.format(self.inventory.xp)
        ).grid(row=5, column=3, sticky=tk.E, padx=(0,20))

        # show number of characters can level
        chars = int(self.inventory.xp/xpFromLevel(99))
        tk.Label(
            master,
            text=&#39;Can fully level {} character{},&#39;.format(
                chars,
                &#39;s&#39; if chars &gt; 1 else &#39;&#39;
            )
        ).grid(row=6, column=2, columnspan=2, padx=(20,20))

        # show additional character, partial level
        tk.Label(
            master, text=&#39;and one more from&#39;
        ).grid(row=7, column=2, columnspan=2, padx=(20,20))

        # build combo-box level-checking tool
        bar = tk.Frame(master)

        # starting level combo-box
        tk.Label(bar, text=&#39;Level&#39;).pack(side=tk.LEFT)
        startLevelBox = ttk.Combobox(
            bar, textvariable=self.startLevel,
            values=[str(level) for level in self.levelMap],
            state=&#39;readonly&#39;, width=2
        )
        startLevelBox.pack(side=tk.LEFT)
        startLevelBox.bind(
            &#39;&lt;&lt;ComboboxSelected&gt;&gt;&#39;, lambda event:self.setEndLevel()
        )

        # ending level combo-box
        tk.Label(
            bar, text=&#39;to&#39;
        ).pack(side=tk.LEFT)
        endLevelBox = ttk.Combobox(
            bar, textvariable=self.endLevel,
            values=[str(level) for level in self.levelMap.values()],
            state=&#39;readonly&#39;, width=2
        )
        endLevelBox.pack(side=tk.LEFT)
        endLevelBox.bind(
            &#39;&lt;&lt;ComboboxSelected&gt;&gt;&#39;, lambda event:self.setStartLevel()
        )

        # pack combo-box level-checking tool
        bar.grid(row=8, column=2, columnspan=2, padx=(20,20))

        # show protomatter needed to max roster
        tk.Label(
            master, text=&#39;Needed to Max Roster&#39;, font=(None, 13, &#39;italic&#39;)
        ).grid(row=10, column=2, columnspan=2, sticky=tk.W, pady=(20,0))
        for index, item in enumerate(self.inventory.keysByCat(&#39;Protomatter&#39;)):
            totalNeeded = Inventory()
            for char in self.roster.chars.values():
                if char.role == item.role:
                    totalNeeded = sum(
                        (skill.itemsToMax for skill in char.skills.values()),
                        totalNeeded
                    )
            tk.Label(
                master, text=&#39;{:,} + {:,} Latinum&#39;.format(
                    totalNeeded[item],
                    totalNeeded[ITEMS[&#39;Latinum&#39;]]
                )
            ).grid(row=11 + index, column=2, sticky=tk.W)

    def setStartLevel(self):
        &#34;&#34;&#34;Sets the `tkinter` variable in the `startLevel` attribute
        according to the value of `endLevel`.

        &#34;&#34;&#34;
        self.startLevel.set(str(
            self.levelMap.inverse[int(self.endLevel.get())]
        ))

    def setEndLevel(self):
        &#34;&#34;&#34;Sets the `tkinter` variable in the `endLevel` attribute
        according to the value of `startLevel`.

        &#34;&#34;&#34;
        self.endLevel.set(str(
            self.levelMap[int(self.startLevel.get())]
        ))

    def displayCat(self, master, cat, coords, pad=False):
        &#34;&#34;&#34;Grids the headings, labels, and item quantities for the given
        category onto the given master object.

        Args:
            master (obj): The `tkinter` object to assign as master.
            cat (str): The category of items to grid.
            coords (tuple): (`int`,`int`) The row and column of the top
                left corner of the display.
            pad (bool): `True` if the display should have vertical
                padding above it.

        &#34;&#34;&#34;
        row, col = coords
        catLabel = tk.Label(master, text=cat, font=(None, 13, &#39;bold&#39;))
        catLabel.grid(row=row, column=col, columnspan=2, sticky=tk.W)
        if pad:
            catLabel.grid_configure(pady=(20,0))
        row += 1
        for item, qty in self.inventory.itemsByCat(cat):
            tk.Label(master, text=item.name).grid(
                row=row, column=col, sticky=tk.W, padx=(20,0)
            )
            tk.Label(master, text=&#39;{:,}&#39;.format(qty)).grid(
                row=row, column=col + 1, sticky=tk.E, padx=(0,20)
            )
            row += 1</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="legends.ui.dialogs.ModalMessage" href="dialogs.html#legends.ui.dialogs.ModalMessage">ModalMessage</a></li>
<li>tkinter.simpledialog.Dialog</li>
<li>tkinter.Toplevel</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Wm</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="legends.ui.session.InventoryScreen.inventory"><code class="name">var <span class="ident">inventory</span></code></dt>
<dd>
<div class="desc"><p><code><a title="legends.constants.Inventory" href="../constants.html#legends.constants.Inventory">Inventory</a></code>: The inventory associated
with the current session.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def inventory(self):
    &#34;&#34;&#34;`legends.constants.Inventory`: The inventory associated
    with the current session.
    &#34;&#34;&#34;
    return self.root.session.saveslot.inventory</code></pre>
</details>
</dd>
<dt id="legends.ui.session.InventoryScreen.roster"><code class="name">var <span class="ident">roster</span></code></dt>
<dd>
<div class="desc"><p><code><a title="legends.roster.Roster" href="../roster.html#legends.roster.Roster">Roster</a></code>: The roster associated with the
current session.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def roster(self):
    &#34;&#34;&#34;`legends.roster.Roster`: The roster associated with the
    current session.
    &#34;&#34;&#34;
    return self.root.session.saveslot.roster</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="legends.ui.session.InventoryScreen.body"><code class="name flex">
<span>def <span class="ident">body</span></span>(<span>self, master)</span>
</code></dt>
<dd>
<div class="desc"><p>Create the body of the dialog.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def body(self, master):
    &#34;&#34;&#34;Create the body of the dialog.

    &#34;&#34;&#34;
    # grid the inventory quantities
    self.displayCat(master, &#39;Currency&#39;, (0, 0))
    self.displayCat(master, &#39;General Items&#39;, (0, 2))
    self.displayCat(master, &#39;Bio-Gel&#39;, (4, 0), True)
    self.displayCat(master, &#39;Protomatter&#39;, (10, 0), True)
    self.displayCat(master, &#39;Gear Leveling Materials&#39;, (16, 0), True)
    self.displayCat(master, &#39;Gear Ranking Materials&#39;, (16, 2), True)

    # show total XP
    tk.Label(
        master, text=&#39;TOTAL BIO-GEL XP:&#39;, font=(None, 13, &#39;italic&#39;)
    ).grid(row=5, column=2, sticky=tk.W, padx=(20,0))
    tk.Label(
        master, text=&#39;{:,}&#39;.format(self.inventory.xp)
    ).grid(row=5, column=3, sticky=tk.E, padx=(0,20))

    # show number of characters can level
    chars = int(self.inventory.xp/xpFromLevel(99))
    tk.Label(
        master,
        text=&#39;Can fully level {} character{},&#39;.format(
            chars,
            &#39;s&#39; if chars &gt; 1 else &#39;&#39;
        )
    ).grid(row=6, column=2, columnspan=2, padx=(20,20))

    # show additional character, partial level
    tk.Label(
        master, text=&#39;and one more from&#39;
    ).grid(row=7, column=2, columnspan=2, padx=(20,20))

    # build combo-box level-checking tool
    bar = tk.Frame(master)

    # starting level combo-box
    tk.Label(bar, text=&#39;Level&#39;).pack(side=tk.LEFT)
    startLevelBox = ttk.Combobox(
        bar, textvariable=self.startLevel,
        values=[str(level) for level in self.levelMap],
        state=&#39;readonly&#39;, width=2
    )
    startLevelBox.pack(side=tk.LEFT)
    startLevelBox.bind(
        &#39;&lt;&lt;ComboboxSelected&gt;&gt;&#39;, lambda event:self.setEndLevel()
    )

    # ending level combo-box
    tk.Label(
        bar, text=&#39;to&#39;
    ).pack(side=tk.LEFT)
    endLevelBox = ttk.Combobox(
        bar, textvariable=self.endLevel,
        values=[str(level) for level in self.levelMap.values()],
        state=&#39;readonly&#39;, width=2
    )
    endLevelBox.pack(side=tk.LEFT)
    endLevelBox.bind(
        &#39;&lt;&lt;ComboboxSelected&gt;&gt;&#39;, lambda event:self.setStartLevel()
    )

    # pack combo-box level-checking tool
    bar.grid(row=8, column=2, columnspan=2, padx=(20,20))

    # show protomatter needed to max roster
    tk.Label(
        master, text=&#39;Needed to Max Roster&#39;, font=(None, 13, &#39;italic&#39;)
    ).grid(row=10, column=2, columnspan=2, sticky=tk.W, pady=(20,0))
    for index, item in enumerate(self.inventory.keysByCat(&#39;Protomatter&#39;)):
        totalNeeded = Inventory()
        for char in self.roster.chars.values():
            if char.role == item.role:
                totalNeeded = sum(
                    (skill.itemsToMax for skill in char.skills.values()),
                    totalNeeded
                )
        tk.Label(
            master, text=&#39;{:,} + {:,} Latinum&#39;.format(
                totalNeeded[item],
                totalNeeded[ITEMS[&#39;Latinum&#39;]]
            )
        ).grid(row=11 + index, column=2, sticky=tk.W)</code></pre>
</details>
</dd>
<dt id="legends.ui.session.InventoryScreen.displayCat"><code class="name flex">
<span>def <span class="ident">displayCat</span></span>(<span>self, master, cat, coords, pad=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Grids the headings, labels, and item quantities for the given
category onto the given master object.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>master</code></strong> :&ensp;<code>obj</code></dt>
<dd>The <code>tkinter</code> object to assign as master.</dd>
<dt><strong><code>cat</code></strong> :&ensp;<code>str</code></dt>
<dd>The category of items to grid.</dd>
<dt><strong><code>coords</code></strong> :&ensp;<code>tuple</code></dt>
<dd>(<code>int</code>,<code>int</code>) The row and column of the top
left corner of the display.</dd>
<dt><strong><code>pad</code></strong> :&ensp;<code>bool</code></dt>
<dd><code>True</code> if the display should have vertical
padding above it.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def displayCat(self, master, cat, coords, pad=False):
    &#34;&#34;&#34;Grids the headings, labels, and item quantities for the given
    category onto the given master object.

    Args:
        master (obj): The `tkinter` object to assign as master.
        cat (str): The category of items to grid.
        coords (tuple): (`int`,`int`) The row and column of the top
            left corner of the display.
        pad (bool): `True` if the display should have vertical
            padding above it.

    &#34;&#34;&#34;
    row, col = coords
    catLabel = tk.Label(master, text=cat, font=(None, 13, &#39;bold&#39;))
    catLabel.grid(row=row, column=col, columnspan=2, sticky=tk.W)
    if pad:
        catLabel.grid_configure(pady=(20,0))
    row += 1
    for item, qty in self.inventory.itemsByCat(cat):
        tk.Label(master, text=item.name).grid(
            row=row, column=col, sticky=tk.W, padx=(20,0)
        )
        tk.Label(master, text=&#39;{:,}&#39;.format(qty)).grid(
            row=row, column=col + 1, sticky=tk.E, padx=(0,20)
        )
        row += 1</code></pre>
</details>
</dd>
<dt id="legends.ui.session.InventoryScreen.setEndLevel"><code class="name flex">
<span>def <span class="ident">setEndLevel</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the <code>tkinter</code> variable in the <code>endLevel</code> attribute
according to the value of <code>startLevel</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setEndLevel(self):
    &#34;&#34;&#34;Sets the `tkinter` variable in the `endLevel` attribute
    according to the value of `startLevel`.

    &#34;&#34;&#34;
    self.endLevel.set(str(
        self.levelMap[int(self.startLevel.get())]
    ))</code></pre>
</details>
</dd>
<dt id="legends.ui.session.InventoryScreen.setStartLevel"><code class="name flex">
<span>def <span class="ident">setStartLevel</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the <code>tkinter</code> variable in the <code>startLevel</code> attribute
according to the value of <code>endLevel</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setStartLevel(self):
    &#34;&#34;&#34;Sets the `tkinter` variable in the `startLevel` attribute
    according to the value of `endLevel`.

    &#34;&#34;&#34;
    self.startLevel.set(str(
        self.levelMap.inverse[int(self.endLevel.get())]
    ))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="legends.ui.dialogs.ModalMessage" href="dialogs.html#legends.ui.dialogs.ModalMessage">ModalMessage</a></b></code>:
<ul class="hlist">
<li><code><a title="legends.ui.dialogs.ModalMessage.buttonbox" href="dialogs.html#legends.ui.dialogs.ModalMessage.buttonbox">buttonbox</a></code></li>
<li><code><a title="legends.ui.dialogs.ModalMessage.destroy" href="dialogs.html#legends.ui.dialogs.ModalMessage.destroy">destroy</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="legends.ui.session.MissingMissions"><code class="flex name class">
<span>class <span class="ident">MissingMissions</span></span>
<span>(</span><span>root, parent=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A message showing the player's incomplete missions.</p>
<p>Also shows the total uncollected gear ranking materials.</p>
<p>The constructor disables the root menu before calling the
<code>tk.simpledialog.Dialog</code> constructor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MissingMissions(ModalMessage):
    &#34;&#34;&#34;A message showing the player&#39;s incomplete missions.

    Also shows the total uncollected gear ranking materials.

    &#34;&#34;&#34;

    def __init__(self, root, parent=None):
        ModalMessage.__init__(self, root, parent, &#39;Incomplete Missions&#39;)

    def body(self, master):
        &#34;&#34;&#34;Create the body of the dialog.

        &#34;&#34;&#34;
        scrollFrame = ScrollFrame(master)
        display = tk.Frame(scrollFrame.content)
        scrollFrame.canvas.config(height=0.5 * self.winfo_screenheight())
        incompleteMissions = [
            mission for mission in self.root.session.saveslot.missions
            if mission.complete &lt; 1
        ]
        missingRewards = Inventory()
        for mission in incompleteMissions:
            missingRewards = missingRewards + mission.missingNodeRewards
            missingRewards = missingRewards + mission.rewards
        tk.Label(
            display,
            text=&#39;Uncollected Gear Ranking Materials&#39;,
            font=(None, 13, &#39;bold&#39;)
        ).grid(row=0, column=0, columnspan=3, sticky=tk.W)
        row = 1
        for item, qty in missingRewards.itemsByCat(&#39;Gear Ranking Materials&#39;):
            tk.Label(
                display, text=item.name
            ).grid(row=row, column=0, columnspan=2, sticky=tk.W)
            tk.Label(
                display, text=&#39;{:,}&#39;.format(qty)
            ).grid(row=row, column=2, sticky=tk.E)
            row += 1
        tk.Label(
            display, text=&#39;Incomplete Missions&#39;, font=(None, 13, &#39;bold&#39;)
        ).grid(row=row, column=0, columnspan=3, sticky=tk.W, pady=(20,0))
        row += 1
        for mission in incompleteMissions:
            tk.Label(
                display, text=mission.difficulty
            ).grid(row=row, column=0, sticky=tk.W)
            tk.Label(
                display,
                text=&#39;Episode {} Mission {}&#39;.format(
                    mission.episode,
                    mission.orderIndex
                )
            ).grid(row=row, column=1, sticky=tk.W)
            tk.Label(
                display, text=&#39;{:.0%}&#39;.format(mission.complete)
            ).grid(row=row, column=2, sticky=tk.E)
            row += 1
        display.pack(padx=20)
        scrollFrame.pack(expand=tk.YES, fill=tk.BOTH)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="legends.ui.dialogs.ModalMessage" href="dialogs.html#legends.ui.dialogs.ModalMessage">ModalMessage</a></li>
<li>tkinter.simpledialog.Dialog</li>
<li>tkinter.Toplevel</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Wm</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="legends.ui.session.MissingMissions.body"><code class="name flex">
<span>def <span class="ident">body</span></span>(<span>self, master)</span>
</code></dt>
<dd>
<div class="desc"><p>Create the body of the dialog.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def body(self, master):
    &#34;&#34;&#34;Create the body of the dialog.

    &#34;&#34;&#34;
    scrollFrame = ScrollFrame(master)
    display = tk.Frame(scrollFrame.content)
    scrollFrame.canvas.config(height=0.5 * self.winfo_screenheight())
    incompleteMissions = [
        mission for mission in self.root.session.saveslot.missions
        if mission.complete &lt; 1
    ]
    missingRewards = Inventory()
    for mission in incompleteMissions:
        missingRewards = missingRewards + mission.missingNodeRewards
        missingRewards = missingRewards + mission.rewards
    tk.Label(
        display,
        text=&#39;Uncollected Gear Ranking Materials&#39;,
        font=(None, 13, &#39;bold&#39;)
    ).grid(row=0, column=0, columnspan=3, sticky=tk.W)
    row = 1
    for item, qty in missingRewards.itemsByCat(&#39;Gear Ranking Materials&#39;):
        tk.Label(
            display, text=item.name
        ).grid(row=row, column=0, columnspan=2, sticky=tk.W)
        tk.Label(
            display, text=&#39;{:,}&#39;.format(qty)
        ).grid(row=row, column=2, sticky=tk.E)
        row += 1
    tk.Label(
        display, text=&#39;Incomplete Missions&#39;, font=(None, 13, &#39;bold&#39;)
    ).grid(row=row, column=0, columnspan=3, sticky=tk.W, pady=(20,0))
    row += 1
    for mission in incompleteMissions:
        tk.Label(
            display, text=mission.difficulty
        ).grid(row=row, column=0, sticky=tk.W)
        tk.Label(
            display,
            text=&#39;Episode {} Mission {}&#39;.format(
                mission.episode,
                mission.orderIndex
            )
        ).grid(row=row, column=1, sticky=tk.W)
        tk.Label(
            display, text=&#39;{:.0%}&#39;.format(mission.complete)
        ).grid(row=row, column=2, sticky=tk.E)
        row += 1
    display.pack(padx=20)
    scrollFrame.pack(expand=tk.YES, fill=tk.BOTH)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="legends.ui.dialogs.ModalMessage" href="dialogs.html#legends.ui.dialogs.ModalMessage">ModalMessage</a></b></code>:
<ul class="hlist">
<li><code><a title="legends.ui.dialogs.ModalMessage.buttonbox" href="dialogs.html#legends.ui.dialogs.ModalMessage.buttonbox">buttonbox</a></code></li>
<li><code><a title="legends.ui.dialogs.ModalMessage.destroy" href="dialogs.html#legends.ui.dialogs.ModalMessage.destroy">destroy</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="legends.ui.session.Session"><code class="flex name class">
<span>class <span class="ident">Session</span></span>
<span>(</span><span>stlplanner, saveslot=None, **options)</span>
</code></dt>
<dd>
<div class="desc"><p>A user session in the <em>STL Planner</em> app.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>saveslot</code></strong> :&ensp;<code><a title="legends.saveslot.SaveSlot" href="../saveslot.html#legends.saveslot.SaveSlot">SaveSlot</a></code></dt>
<dd>The
<code><a title="legends.saveslot.SaveSlot" href="../saveslot.html#legends.saveslot.SaveSlot">SaveSlot</a></code> object associated with the
session.</dd>
<dt><strong><code>settings</code></strong> :&ensp;<code><a title="legends.ui.session.SessionSettings" href="#legends.ui.session.SessionSettings">SessionSettings</a></code></dt>
<dd>The <code><a title="legends.ui.session.SessionSettings" href="#legends.ui.session.SessionSettings">SessionSettings</a></code> instance that
stores the settings for the current session.</dd>
<dt><strong><code>timeBar</code></strong> :&ensp;<code>tk.Frame</code></dt>
<dd>The horizontal bar at the top of the session
frame that displays time stamp info connected with the
associated save slot.</dd>
<dt><strong><code>tab</code></strong> :&ensp;<code>tk.Frame</code></dt>
<dd>The visible tab in the session frame.</dd>
</dl>
<p>The constructor creates a new session associated with the
given <code><a title="legends.saveslot.SaveSlot" href="../saveslot.html#legends.saveslot.SaveSlot">SaveSlot</a></code> object. If none is provided,
the session displays buttons that activate choices from the
<code>File</code> menu.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>stlplanner</code></strong> :&ensp;<code>STLPlanner</code></dt>
<dd>The <code>STLPlanner</code> instance to be
assigned as the parent of this session.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Session(tk.Frame):
    &#34;&#34;&#34;A user session in the *STL Planner* app.

    Attributes:
        saveslot (legends.saveslot.SaveSlot): The
            `legends.saveslot.SaveSlot` object associated with the
            session.
        settings (SessionSettings): The `SessionSettings` instance that
            stores the settings for the current session.
        timeBar (tk.Frame): The horizontal bar at the top of the session
            frame that displays time stamp info connected with the
            associated save slot.
        tab (tk.Frame): The visible tab in the session frame.

    &#34;&#34;&#34;
    def __init__(self, stlplanner, saveslot=None, **options):
        &#34;&#34;&#34;The constructor creates a new session associated with the
        given `legends.saveslot.SaveSlot` object. If none is provided,
        the session displays buttons that activate choices from the
        `File` menu.

        Args:
            stlplanner (STLPlanner): The `STLPlanner` instance to be
                assigned as the parent of this session.

        &#34;&#34;&#34;
        tk.Frame.__init__(self, stlplanner, **options)
        self.saveslot = saveslot
        self.timeBar = None
        self.settings = SessionSettings()
        self.tab = tk.Frame(self)
        self.tab.pack()
        if saveslot is None:
            self.startFrame()
        else:
            self.makeTimeBar()
            self.rosterTab()

    def startFrame(self):
        &#34;&#34;&#34;Build the starting frame, with choices from the `File` menu.

        &#34;&#34;&#34;
        buttonbox = tk.Frame(self.tab)
        tk.Button(
            buttonbox, text=&#39;from HD&#39;, command=self.master.newFromFile
        ).grid(row=0, column=0, sticky=tk.EW)
        tk.Button(
            buttonbox,
            text=&#39;from Clipboard&#39;, command=self.master.newFromClipboard
        ).grid(row=1, column=0, sticky=tk.EW)
        tk.Button(
            buttonbox, text=&#39;MAX&#39;, command=self.master.newMaxChars
        ).grid(row=2, column=0, sticky=tk.EW)
        tk.Label(
            buttonbox, text=&#39;Extract data from your local save file&#39;
        ).grid(row=0, column=1, sticky=tk.W)
        tk.Label(
            buttonbox, text=&#39;Use a support email to extract your data&#39;
        ).grid(row=1, column=1, sticky=tk.W)
        tk.Label(
            buttonbox, text=&#39;Create a roster of maxed characters&#39;
        ).grid(row=2, column=1, sticky=tk.W)
        buttonbox.pack(padx=50, pady=50)

    def makeTimeBar(self):
        &#34;&#34;&#34;Builds a horizontal bar (a `tk.Frame` instance) containing
        timestamp information from the associated save slot, then
        assigns the bar to the `timeBar` attribute. If there is no save
        slot, or the time bar already exists, or the `STLPlanner` master
        prohibits it, the method does nothing.

        &#34;&#34;&#34;
        if (
            self.saveslot is None
            or self.timeBar is not None
            or not self.master.showTimestamps.get()
        ):
            return

        # build bar and initialize variables
        self.timeBar = tk.Frame(self)
        timestamps = self.saveslot.timestamps
        start = (
            &#39;start date: &#39;
            + timestamps.startDate.strftime(&#39;%b %-d %Y %H:%M %Z&#39;)
        )
        last = (
            &#39;last played: &#39;
            + timestamps.timeLastPlayed.strftime(&#39;%b %-d %Y %H:%M %Z&#39;)
        )
        total = (
            &#39;play duration: &#39; + cleanTime(timestamps.playDuration)
        )
        average = (
            &#39;play time per day: &#39; + cleanTime(timestamps.playTimePerDay)
        )

        # build labels
        labels = [None] * 4
        for j in range(4):
            labels[j] = tk.Label(
                self.timeBar, borderwidth=2, relief=tk.GROOVE, padx=10
            )
        for index, text in enumerate([start, last, total, average]):
            labels[index].config(text=text)

        # pack labels and bar
        for label in labels:
            label.pack(side=tk.LEFT)
        self.timeBar.pack(side=tk.TOP)

    def removeTimeBar(self):
        &#34;&#34;&#34;If the time bar exists, it is destroyed and the `timeBar`
        attribute is set to `None`.

        &#34;&#34;&#34;
        if self.timeBar is not None:
            self.timeBar.destroy()
            self.timeBar = None

    def rosterTab(self):
        &#34;&#34;&#34;Loads a new `legends.ui.rostertab.RosterTab` instance into
        the `tab` attribute.

        &#34;&#34;&#34;
        self.tab.destroy()
        self.tab = RosterTab(self)
        self.tab.pack(side=tk.BOTTOM, expand=tk.YES, fill=tk.Y)
        self.master.title(&#39;STL Planner - Roster&#39;)

    def charTab(self, char):
        &#34;&#34;&#34;Loads a new `legends.ui.chartab.CharTab` instance into the
        `tab` attribute.

        &#34;&#34;&#34;
        self.tab.destroy()
        self.tab = CharTab(char, self)
        self.tab.pack(side=tk.BOTTOM, expand=tk.YES, fill=tk.Y)
        self.master.title(&#39;STL Planner - {}&#39;.format(char.shortName))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tkinter.Frame</li>
<li>tkinter.Widget</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Pack</li>
<li>tkinter.Place</li>
<li>tkinter.Grid</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="legends.ui.session.Session.charTab"><code class="name flex">
<span>def <span class="ident">charTab</span></span>(<span>self, char)</span>
</code></dt>
<dd>
<div class="desc"><p>Loads a new <code><a title="legends.ui.chartab.CharTab" href="chartab.html#legends.ui.chartab.CharTab">CharTab</a></code> instance into the
<code>tab</code> attribute.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def charTab(self, char):
    &#34;&#34;&#34;Loads a new `legends.ui.chartab.CharTab` instance into the
    `tab` attribute.

    &#34;&#34;&#34;
    self.tab.destroy()
    self.tab = CharTab(char, self)
    self.tab.pack(side=tk.BOTTOM, expand=tk.YES, fill=tk.Y)
    self.master.title(&#39;STL Planner - {}&#39;.format(char.shortName))</code></pre>
</details>
</dd>
<dt id="legends.ui.session.Session.makeTimeBar"><code class="name flex">
<span>def <span class="ident">makeTimeBar</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Builds a horizontal bar (a <code>tk.Frame</code> instance) containing
timestamp information from the associated save slot, then
assigns the bar to the <code>timeBar</code> attribute. If there is no save
slot, or the time bar already exists, or the <code>STLPlanner</code> master
prohibits it, the method does nothing.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def makeTimeBar(self):
    &#34;&#34;&#34;Builds a horizontal bar (a `tk.Frame` instance) containing
    timestamp information from the associated save slot, then
    assigns the bar to the `timeBar` attribute. If there is no save
    slot, or the time bar already exists, or the `STLPlanner` master
    prohibits it, the method does nothing.

    &#34;&#34;&#34;
    if (
        self.saveslot is None
        or self.timeBar is not None
        or not self.master.showTimestamps.get()
    ):
        return

    # build bar and initialize variables
    self.timeBar = tk.Frame(self)
    timestamps = self.saveslot.timestamps
    start = (
        &#39;start date: &#39;
        + timestamps.startDate.strftime(&#39;%b %-d %Y %H:%M %Z&#39;)
    )
    last = (
        &#39;last played: &#39;
        + timestamps.timeLastPlayed.strftime(&#39;%b %-d %Y %H:%M %Z&#39;)
    )
    total = (
        &#39;play duration: &#39; + cleanTime(timestamps.playDuration)
    )
    average = (
        &#39;play time per day: &#39; + cleanTime(timestamps.playTimePerDay)
    )

    # build labels
    labels = [None] * 4
    for j in range(4):
        labels[j] = tk.Label(
            self.timeBar, borderwidth=2, relief=tk.GROOVE, padx=10
        )
    for index, text in enumerate([start, last, total, average]):
        labels[index].config(text=text)

    # pack labels and bar
    for label in labels:
        label.pack(side=tk.LEFT)
    self.timeBar.pack(side=tk.TOP)</code></pre>
</details>
</dd>
<dt id="legends.ui.session.Session.removeTimeBar"><code class="name flex">
<span>def <span class="ident">removeTimeBar</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>If the time bar exists, it is destroyed and the <code>timeBar</code>
attribute is set to <code>None</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def removeTimeBar(self):
    &#34;&#34;&#34;If the time bar exists, it is destroyed and the `timeBar`
    attribute is set to `None`.

    &#34;&#34;&#34;
    if self.timeBar is not None:
        self.timeBar.destroy()
        self.timeBar = None</code></pre>
</details>
</dd>
<dt id="legends.ui.session.Session.rosterTab"><code class="name flex">
<span>def <span class="ident">rosterTab</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Loads a new <code><a title="legends.ui.rostertab.RosterTab" href="rostertab.html#legends.ui.rostertab.RosterTab">RosterTab</a></code> instance into
the <code>tab</code> attribute.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rosterTab(self):
    &#34;&#34;&#34;Loads a new `legends.ui.rostertab.RosterTab` instance into
    the `tab` attribute.

    &#34;&#34;&#34;
    self.tab.destroy()
    self.tab = RosterTab(self)
    self.tab.pack(side=tk.BOTTOM, expand=tk.YES, fill=tk.Y)
    self.master.title(&#39;STL Planner - Roster&#39;)</code></pre>
</details>
</dd>
<dt id="legends.ui.session.Session.startFrame"><code class="name flex">
<span>def <span class="ident">startFrame</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Build the starting frame, with choices from the <code>File</code> menu.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def startFrame(self):
    &#34;&#34;&#34;Build the starting frame, with choices from the `File` menu.

    &#34;&#34;&#34;
    buttonbox = tk.Frame(self.tab)
    tk.Button(
        buttonbox, text=&#39;from HD&#39;, command=self.master.newFromFile
    ).grid(row=0, column=0, sticky=tk.EW)
    tk.Button(
        buttonbox,
        text=&#39;from Clipboard&#39;, command=self.master.newFromClipboard
    ).grid(row=1, column=0, sticky=tk.EW)
    tk.Button(
        buttonbox, text=&#39;MAX&#39;, command=self.master.newMaxChars
    ).grid(row=2, column=0, sticky=tk.EW)
    tk.Label(
        buttonbox, text=&#39;Extract data from your local save file&#39;
    ).grid(row=0, column=1, sticky=tk.W)
    tk.Label(
        buttonbox, text=&#39;Use a support email to extract your data&#39;
    ).grid(row=1, column=1, sticky=tk.W)
    tk.Label(
        buttonbox, text=&#39;Create a roster of maxed characters&#39;
    ).grid(row=2, column=1, sticky=tk.W)
    buttonbox.pack(padx=50, pady=50)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="legends.ui.session.SessionSettings"><code class="flex name class">
<span>class <span class="ident">SessionSettings</span></span>
</code></dt>
<dd>
<div class="desc"><p>Stores the settings for a <code><a title="legends.ui.session.Session" href="#legends.ui.session.Session">Session</a></code>.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>rosterFilter</code></strong> :&ensp;<code><a title="legends.ui.rostertab.RosterFilter" href="rostertab.html#legends.ui.rostertab.RosterFilter">RosterFilter</a></code></dt>
<dd>The
<code><a title="legends.ui.rostertab.RosterFilter" href="rostertab.html#legends.ui.rostertab.RosterFilter">RosterFilter</a></code> object storing the
current filter settings for the roster tab.</dd>
<dt><strong><code>rosterExportFile</code></strong> :&ensp;<code>str</code></dt>
<dd>The path to use when prompting the user
to export their roster to a spreadsheet.</dd>
<dt><strong><code>excludeCommons</code></strong> :&ensp;<code>tk.BooleanVar</code></dt>
<dd><code>True</code> is the summon rate
calculations made by the roster tab should exclude Common
characters.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SessionSettings(): # pylint: disable=too-few-public-methods
    &#34;&#34;&#34;Stores the settings for a `Session`.

    Attributes:
        rosterFilter (legends.ui.rostertab.RosterFilter): The
            `legends.ui.rostertab.RosterFilter` object storing the
            current filter settings for the roster tab.
        rosterExportFile (str): The path to use when prompting the user
            to export their roster to a spreadsheet.
        excludeCommons (tk.BooleanVar): `True` is the summon rate
            calculations made by the roster tab should exclude Common
            characters.

    &#34;&#34;&#34;

    def __init__(self):
        self.rosterFilter = RosterFilter()
        self.rosterExportFile = &#39;/Users/&#39; + getuser() + &#39;/Documents/roster.csv&#39;
        self.excludeCommons = tk.BooleanVar(None, True)</code></pre>
</details>
</dd>
<dt id="legends.ui.session.SurvivalEffects"><code class="flex name class">
<span>class <span class="ident">SurvivalEffects</span></span>
<span>(</span><span>root, parent=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A message showing the active battle modifiers in survival mode.</p>
<p>The constructor disables the root menu before calling the
<code>tk.simpledialog.Dialog</code> constructor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SurvivalEffects(ModalMessage):
    &#34;&#34;&#34;A message showing the active battle modifiers in survival mode.

    &#34;&#34;&#34;

    def __init__(self, root, parent=None):
        ModalMessage.__init__(self, root, parent, &#39;Active Survival Effects&#39;)

    def body(self, master):
        &#34;&#34;&#34;Create the body of the dialog.

        &#34;&#34;&#34;
        saveslot = self.root.session.saveslot
        count = 0
        for effect, duration in saveslot.survivalEffects.items():
            tk.Label(
                master, text=effect
            ).grid(row=count, column=0, sticky=tk.W, padx=(20,0))
            tk.Label(
                master, text=&#39;({} battles remaining)&#39;.format(duration)
            ).grid(row=count, column=1, sticky=tk.E, padx=(0,20))
            count += 1</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="legends.ui.dialogs.ModalMessage" href="dialogs.html#legends.ui.dialogs.ModalMessage">ModalMessage</a></li>
<li>tkinter.simpledialog.Dialog</li>
<li>tkinter.Toplevel</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Wm</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="legends.ui.session.SurvivalEffects.body"><code class="name flex">
<span>def <span class="ident">body</span></span>(<span>self, master)</span>
</code></dt>
<dd>
<div class="desc"><p>Create the body of the dialog.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def body(self, master):
    &#34;&#34;&#34;Create the body of the dialog.

    &#34;&#34;&#34;
    saveslot = self.root.session.saveslot
    count = 0
    for effect, duration in saveslot.survivalEffects.items():
        tk.Label(
            master, text=effect
        ).grid(row=count, column=0, sticky=tk.W, padx=(20,0))
        tk.Label(
            master, text=&#39;({} battles remaining)&#39;.format(duration)
        ).grid(row=count, column=1, sticky=tk.E, padx=(0,20))
        count += 1</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="legends.ui.dialogs.ModalMessage" href="dialogs.html#legends.ui.dialogs.ModalMessage">ModalMessage</a></b></code>:
<ul class="hlist">
<li><code><a title="legends.ui.dialogs.ModalMessage.buttonbox" href="dialogs.html#legends.ui.dialogs.ModalMessage.buttonbox">buttonbox</a></code></li>
<li><code><a title="legends.ui.dialogs.ModalMessage.destroy" href="dialogs.html#legends.ui.dialogs.ModalMessage.destroy">destroy</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="legends.ui" href="index.html">legends.ui</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="legends.ui.session.InventoryScreen" href="#legends.ui.session.InventoryScreen">InventoryScreen</a></code></h4>
<ul class="two-column">
<li><code><a title="legends.ui.session.InventoryScreen.body" href="#legends.ui.session.InventoryScreen.body">body</a></code></li>
<li><code><a title="legends.ui.session.InventoryScreen.displayCat" href="#legends.ui.session.InventoryScreen.displayCat">displayCat</a></code></li>
<li><code><a title="legends.ui.session.InventoryScreen.inventory" href="#legends.ui.session.InventoryScreen.inventory">inventory</a></code></li>
<li><code><a title="legends.ui.session.InventoryScreen.roster" href="#legends.ui.session.InventoryScreen.roster">roster</a></code></li>
<li><code><a title="legends.ui.session.InventoryScreen.setEndLevel" href="#legends.ui.session.InventoryScreen.setEndLevel">setEndLevel</a></code></li>
<li><code><a title="legends.ui.session.InventoryScreen.setStartLevel" href="#legends.ui.session.InventoryScreen.setStartLevel">setStartLevel</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="legends.ui.session.MissingMissions" href="#legends.ui.session.MissingMissions">MissingMissions</a></code></h4>
<ul class="">
<li><code><a title="legends.ui.session.MissingMissions.body" href="#legends.ui.session.MissingMissions.body">body</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="legends.ui.session.Session" href="#legends.ui.session.Session">Session</a></code></h4>
<ul class="">
<li><code><a title="legends.ui.session.Session.charTab" href="#legends.ui.session.Session.charTab">charTab</a></code></li>
<li><code><a title="legends.ui.session.Session.makeTimeBar" href="#legends.ui.session.Session.makeTimeBar">makeTimeBar</a></code></li>
<li><code><a title="legends.ui.session.Session.removeTimeBar" href="#legends.ui.session.Session.removeTimeBar">removeTimeBar</a></code></li>
<li><code><a title="legends.ui.session.Session.rosterTab" href="#legends.ui.session.Session.rosterTab">rosterTab</a></code></li>
<li><code><a title="legends.ui.session.Session.startFrame" href="#legends.ui.session.Session.startFrame">startFrame</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="legends.ui.session.SessionSettings" href="#legends.ui.session.SessionSettings">SessionSettings</a></code></h4>
</li>
<li>
<h4><code><a title="legends.ui.session.SurvivalEffects" href="#legends.ui.session.SurvivalEffects">SurvivalEffects</a></code></h4>
<ul class="">
<li><code><a title="legends.ui.session.SurvivalEffects.body" href="#legends.ui.session.SurvivalEffects.body">body</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>