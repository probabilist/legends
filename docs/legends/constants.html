<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>legends.constants API documentation</title>
<meta name="description" content="Constants and custom data structures used in the `legends` package â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>legends.constants</code></h1>
</header>
<section id="section-intro">
<p>Constants and custom data structures used in the <code><a title="legends" href="index.html">legends</a></code> package.</p>
<p>Each json file in <code>legends/data</code> is converted to a constant. The
variable name is the file name without extension, and the variable
points to a Python dictionary built from the file's contents.</p>
<p>NOTE: (1) The constant <code>GSBaseStat</code> differs from the data file
'GSBaseStat.json'. In the constant, 'MaxHealth' is renamed to 'Health'.
(2) The file 'Item.json' is converted to the constant <code>Item_asset</code> to
prevent conflict with the <code><a title="legends.constants.Item" href="#legends.constants.Item">Item</a></code> class.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>DESCRIPTIONS</code></strong> :&ensp;<code>dict</code></dt>
<dd>The key-value pairs in <code>lang_en_us['List']</code> put
into a Python dictionary.</dd>
<dt><strong><code>ENABLED</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>A list of name IDs of characters that appear
on the Crew screen.</dd>
<dt><strong><code>HELP</code></strong> :&ensp;<code>str</code></dt>
<dd>The contents of the file, <code>legends/help.txt</code>.</dd>
<dt><strong><code>ITEMS</code></strong> :&ensp;<code>dict</code></dt>
<dd>{<code>str</code>:<code><a title="legends.constants.Item" href="#legends.constants.Item">Item</a></code>} A dictionary mapping each item ID in
<code>GSItem</code> to an <code><a title="legends.constants.Item" href="#legends.constants.Item">Item</a></code> instance built from that item ID.</dd>
<dt><strong><code>POWER_GRADIENT</code></strong> :&ensp;<code>dict</code></dt>
<dd>{<code>str</code>:<code>float</code>} A dictionary mapping stat
names to the amount that a character's power would increase if
that stat were to increase by 1.</dd>
<dt><strong><code>POWER_AT_ORIGIN</code></strong> :&ensp;<code>float</code></dt>
<dd>The theoretical power of a character whose
every stat is 0.</dd>
<dt><strong><code>RARITIES</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>A list of rarities in the game, from low to
high.</dd>
<dt><strong><code>RARITY_COLORS</code></strong> :&ensp;<code>dict</code></dt>
<dd>{<code>str</code>:<code>str</code>} A dictionary mapping character
rarities to color names in <code>tkinter</code>.</dd>
<dt><strong><code>ROLES</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>A list of roles in the game.</dd>
<dt><strong><code>PART_STAT_UNLOCKED</code></strong> :&ensp;<code>dict</code></dt>
<dd>{<code>str</code>:[<code>int</code>]}: A dictionary
mapping particle rarities to a list whose indices denote the
0-based level of the particle and whose values denote the number
of unlocked stats on a particle of that rarity and level. See
the examples below.</dd>
<dt><strong><code>PART_STAT_VALUES</code></strong> :&ensp;<code>dict</code></dt>
<dd>{<code>str</code>:{<code>str</code>:[<code>float</code>]}}: A
dictionary mapping stat names to a dictionary mapping rarity
names to a list whose indices denote the 0-based level of the
particle and whose values denote the value of the given stat on
a particle of the given rarity and level. See the examples
below.</dd>
<dt><strong><code>STAT_ABBREVIATIONS</code></strong> :&ensp;<code>dict</code></dt>
<dd>{<code>str</code>:<code>str</code>} A dictionary mapping stat
names as they appear in <code>GSBaseStat</code> to abbreviations used
throughout this package, typically for attribute names.</dd>
<dt><strong><code>STAT_INITIALS</code></strong> :&ensp;<code>dict</code></dt>
<dd>{<code>str</code>:<code>str</code>} A dictionary mapping stat names
as they appear in <code>GSBaseStat</code> to one or two letter short forms,
typically used in GUI elements where brevity is essential.</dd>
<dt><strong><code>SUMMON_POOL</code></strong> :&ensp;<code>dict</code></dt>
<dd>{<code>str</code>:<code>dict</code>} A dictionary mapping pool names
('Core' or one the roles in <code>ROLES</code>) to a dictionary with three
keys: 'nameIDs', which maps to a dictionary connecting name IDs
of the characters in that particular summon pool to their summon
probabilities; 'rarityChances', which maps to the probabilities
of summoning the available rarities; and 'cost', which maps to
the number of orbs required to summon from that pool. See the
examples below.</dd>
<dt><strong><code>SUMMON_POOL_IDS</code></strong> :&ensp;<code><a title="legends.utils.relations.bidict" href="utils/relations.html#legends.utils.relations.bidict">bidict</a></code></dt>
<dd>An invertible
dictionary mapping pool names their summon IDs, which are used
by the game data to identify particular summon pools.</dd>
<dt><strong><code>UPCOMING</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>A list of name IDs of characters believed to
be in the queue for future release.</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>A Very Rare, Level 3 particle has 2 stats unlocked:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; PART_STAT_UNLOCKED['VeryRare'][2]
2
</code></pre>
<p>If an Epic, Level 1 particle has Attack as one of its stats, the
Attack value will be 32:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; PART_STAT_VALUES['Attack']['Epic'][0]
32.0
</code></pre>
<p>The probability of summoning Kirk from the Command pool is 1%:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; SUMMON_POOL['Command']['nameIDs']['Kirk']
0.01
</code></pre>
<p>The probability of summoning an Epic character from the 'Core' pool
is 10%:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; SUMMON_POOL['Core']['rarityChances']['Epic']
0.1
</code></pre>
<p>It costs 75 orbs to summon once from the Science pool:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; SUMMON_POOL['Science']['cost']
75
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Constants and custom data structures used in the `legends` package.

Each json file in `legends/data` is converted to a constant. The
variable name is the file name without extension, and the variable
points to a Python dictionary built from the file&#39;s contents.

NOTE: (1) The constant `GSBaseStat` differs from the data file
&#39;GSBaseStat.json&#39;. In the constant, &#39;MaxHealth&#39; is renamed to &#39;Health&#39;.
(2) The file &#39;Item.json&#39; is converted to the constant `Item_asset` to
prevent conflict with the `Item` class.

Attributes:
    DESCRIPTIONS (dict): The key-value pairs in `lang_en_us[&#39;List&#39;]` put
        into a Python dictionary.
    ENABLED (list of str): A list of name IDs of characters that appear
        on the Crew screen.
    HELP (str): The contents of the file, `legends/help.txt`.
    ITEMS (dict): {`str`:`Item`} A dictionary mapping each item ID in
        `GSItem` to an `Item` instance built from that item ID.
    POWER_GRADIENT (dict): {`str`:`float`} A dictionary mapping stat
        names to the amount that a character&#39;s power would increase if
        that stat were to increase by 1.
    POWER_AT_ORIGIN (float): The theoretical power of a character whose
        every stat is 0.
    RARITIES (list of str): A list of rarities in the game, from low to
        high.
    RARITY_COLORS (dict): {`str`:`str`} A dictionary mapping character
        rarities to color names in `tkinter`.
    ROLES (list of str): A list of roles in the game.
    PART_STAT_UNLOCKED (dict): {`str`:[`int`]}: A dictionary
        mapping particle rarities to a list whose indices denote the
        0-based level of the particle and whose values denote the number
        of unlocked stats on a particle of that rarity and level. See
        the examples below.
    PART_STAT_VALUES (dict): {`str`:{`str`:[`float`]}}: A
        dictionary mapping stat names to a dictionary mapping rarity
        names to a list whose indices denote the 0-based level of the
        particle and whose values denote the value of the given stat on
        a particle of the given rarity and level. See the examples
        below.
    STAT_ABBREVIATIONS (dict): {`str`:`str`} A dictionary mapping stat
        names as they appear in `GSBaseStat` to abbreviations used
        throughout this package, typically for attribute names.
    STAT_INITIALS (dict): {`str`:`str`} A dictionary mapping stat names
        as they appear in `GSBaseStat` to one or two letter short forms,
        typically used in GUI elements where brevity is essential.
    SUMMON_POOL (dict): {`str`:`dict`} A dictionary mapping pool names
        (&#39;Core&#39; or one the roles in `ROLES`) to a dictionary with three
        keys: &#39;nameIDs&#39;, which maps to a dictionary connecting name IDs
        of the characters in that particular summon pool to their summon
        probabilities; &#39;rarityChances&#39;, which maps to the probabilities
        of summoning the available rarities; and &#39;cost&#39;, which maps to
        the number of orbs required to summon from that pool. See the
        examples below.
    SUMMON_POOL_IDS (legends.utils.relations.bidict): An invertible
        dictionary mapping pool names their summon IDs, which are used
        by the game data to identify particular summon pools.
    UPCOMING (list of str): A list of name IDs of characters believed to
        be in the queue for future release.

Examples:
    A Very Rare, Level 3 particle has 2 stats unlocked:
    &gt;&gt;&gt; PART_STAT_UNLOCKED[&#39;VeryRare&#39;][2]
    2

    If an Epic, Level 1 particle has Attack as one of its stats, the
    Attack value will be 32:
    &gt;&gt;&gt; PART_STAT_VALUES[&#39;Attack&#39;][&#39;Epic&#39;][0]
    32.0

    The probability of summoning Kirk from the Command pool is 1%:
    &gt;&gt;&gt; SUMMON_POOL[&#39;Command&#39;][&#39;nameIDs&#39;][&#39;Kirk&#39;]
    0.01

    The probability of summoning an Epic character from the &#39;Core&#39; pool
    is 10%:
    &gt;&gt;&gt; SUMMON_POOL[&#39;Core&#39;][&#39;rarityChances&#39;][&#39;Epic&#39;]
    0.1

    It costs 75 orbs to summon once from the Science pool:
    &gt;&gt;&gt; SUMMON_POOL[&#39;Science&#39;][&#39;cost&#39;]
    75

&#34;&#34;&#34;

from collections.abc import MutableMapping
from json import load
from os import listdir
from os.path import abspath, dirname
from legends.utils.relations import bidict

__all__ = [
    &#39;DESCRIPTIONS&#39;,
    &#39;ENABLED&#39;,
    &#39;HELP&#39;,
    &#39;Item&#39;,
    &#39;ITEMS&#39;,
    &#39;POWER_GRADIENT&#39;,
    &#39;POWER_AT_ORIGIN&#39;,
    &#39;PART_STAT_UNLOCKED&#39;,
    &#39;RARITIES&#39;,
    &#39;PART_STAT_VALUES&#39;,
    &#39;RARITY_COLORS&#39;,
    &#39;ROLES&#39;,
    &#39;STAT_ABBREVIATIONS&#39;,
    &#39;STAT_INITIALS&#39;,
    &#39;SUMMON_POOL&#39;,
    &#39;SUMMON_POOL_IDS&#39;,
    &#39;UPCOMING&#39;,
    &#39;Inventory&#39;
]

rootPath = abspath(dirname(__file__))

# convert all json files in `/data` to dictionaries and assign to a
# variable whose name is the file name without extension
for fileName in listdir(rootPath + &#39;/data&#39;):
    if fileName[0] == &#39;.&#39;:
        continue
    varName = fileName.split(&#39;.&#39;)[0]
    if varName == &#39;Item&#39;:
        varName = &#39;Item_asset&#39; # pylint: disable=invalid-name
    with open(rootPath + &#39;/data/&#39; + fileName, encoding=&#39;utf-8&#39;) as f:
        globals()[varName] = load(f)
    __all__.append(varName)

# rename &#39;MaxHealth&#39; in `GSBaseStat` to &#39;Health&#39;
# pylint: disable-next=used-before-assignment
_ = {&#39;Health&#39;: GSBaseStat[&#39;MaxHealth&#39;]}
_.update(GSBaseStat)
del _[&#39;MaxHealth&#39;]
GSBaseStat = _

DESCRIPTIONS = {}
for D in lang_en_us[&#39;List&#39;]: # pylint: disable=undefined-variable
    key = D[&#39;key&#39;]
    value = D[&#39;value&#39;]
    if key:
        DESCRIPTIONS[key] = value

ENABLED = [
    # pylint: disable-next=undefined-variable
    nameID for nameID, data in GSCharacter.items() if data[&#39;Type&#39;] == &#39;Normal&#39;
]

# read and store the help file
with open(rootPath + &#39;/help.txt&#39;, encoding=&#39;utf-8&#39;) as f:
    HELP = f.read()

class Item():
    &#34;&#34;&#34;An item in STL.

    An `Item` instance has no public attributes. All its data should be
    accessed through its read-only properties. It is meant to be used
    like an immutable data type.

    &#34;&#34;&#34;

    _betterCategoryNames = {
        &#39;BiomimeticGel&#39;: &#39;Bio-Gel&#39;,
        &#39;Item&#39;: &#39;General Items&#39;,
        &#39;ProtoMatter&#39;: &#39;Protomatter&#39;,
    }

    def __init__(self, itemID):
        &#34;&#34;&#34;The constructor builds the item from the given item ID,
        which should match a key in `GSItem`.

        &#34;&#34;&#34;
        self._itemID = itemID
        itemData = GSItem[itemID] # pylint: disable=undefined-variable
        dataCat = itemData[&#39;category&#39;]
        self._category = self._betterCategoryNames.get(dataCat, dataCat)
        if itemData[&#39;icon&#39;][:4] == &#39;Gear&#39;:
            if itemData[&#39;rarity&#39;] == &#39;Common&#39;:
                self._category = &#39;Gear Leveling Materials&#39;
            else:
                self._category = &#39;Gear Ranking Materials&#39;

    @property
    def itemID(self):
        &#34;&#34;&#34;`str`: The in-data item ID of the item. Should match a key in
        `GSItem`.
        &#34;&#34;&#34;
        return self._itemID

    @property
    def name(self):
        &#34;&#34;&#34;`str`: The in-game name of the item.&#34;&#34;&#34;
        # pylint: disable-next=undefined-variable
        itemData = GSItem[self.itemID]
        return (
            DESCRIPTIONS[itemData[&#39;name&#39;]] if &#39;name&#39; in itemData
            else self.itemID
        )

    @property
    def category(self):
        &#34;&#34;&#34;`str`: The category of the item. Categories appear in
        `GSItem`. The `Item` class replaces the category found there in
        the following cases. It replaces &#39;BiomimeticGel&#39; with &#39;Bio-Gel&#39;,
        &#39;Item&#39; with &#39;General Items&#39;, and &#39;ProtoMatter&#39; with
        &#39;Protomatter&#39;. Also, if the item is a gear-leveling or gear
        ranking material, the category is replaced by &#39;Gear Leveling
        Materials&#39; or &#39;Gear Ranking Materials&#39;, respectively.
        &#34;&#34;&#34;
        return self._category

    @property
    def xp(self):
        &#34;&#34;&#34;`int`: If the item is a bio-gel, this is the amount of xp it
        awards; otherwise it is 0.
        &#34;&#34;&#34;
        try:
            # pylint: disable-next=undefined-variable
            return GSItem[self.itemID][&#39;DataBiomimeticGel&#39;][&#39;Xp&#39;]
        except KeyError:
            return 0

    @property
    def role(self):
        &#34;&#34;&#34;`str`: If the item is protomatter, this is the role that the
        protomatter is meant for; otherwise it is `None`.
        &#34;&#34;&#34;
        if self.category != &#39;Protomatter&#39;:
            return None
        roleName = self.itemID[6:-3]
        roleName = &#39;Engineering&#39; if roleName == &#39;Engineer&#39; else roleName
        return roleName

    def __repr__(self):
        return &#39;&lt;Item: {!r}&gt;&#39;.format(self.name)

# pylint: disable-next=undefined-variable
ITEMS = {itemID: Item(itemID) for itemID in GSItem}

POWER_GRADIENT = {}
POWER_AT_ORIGIN = 0
for statName, statData in GSBaseStat.items():
    m = statData[&#39;MinValue&#39;]
    M = statData[&#39;MaxValue&#39;]
    POWER_GRADIENT[statName] = 10 / (M - m)
    POWER_AT_ORIGIN += (-m) * 10 / (M - m)

PART_STAT_UNLOCKED = {
    &#39;Common&#39;: [1, 2, 2, 2, 2],
    &#39;Rare&#39;: [1, 2, 2, 2, 2],
    &#39;VeryRare&#39;: [1, 2, 2, 3, 3],
    &#39;Epic&#39;: [2, 3, 3, 4, 4],
    &#39;Legendary&#39;: [2, 3, 3, 4, 4]
}

RARITIES = [&#39;Common&#39;, &#39;Rare&#39;, &#39;VeryRare&#39;, &#39;Epic&#39;, &#39;Legendary&#39;]

# initialize PART_STAT_VALUES
PART_STAT_VALUES = {
    statName: {rarity: [0] * 5 for rarity in RARITIES}
    for statName in
    GSAccessoryStatGeneration # pylint: disable=undefined-variable
}
# fill PART_STAT_VALUES
# pylint: disable-next=undefined-variable
for data in GSAccessoryStatGrowth.values():
    statName = data[&#39;Stat&#39;]
    level = data[&#39;Level&#39;]
    rarity = data[&#39;Rarity&#39;]
    statVal = data[&#39;StatIncrease&#39;]
    PART_STAT_VALUES[statName][rarity][level - 1] = statVal

RARITY_COLORS = {
    &#39;Common&#39;: &#39;cyan&#39;,
    &#39;Rare&#39;: &#39;lawn green&#39;,
    &#39;VeryRare&#39;: &#39;orange&#39;,
    &#39;Epic&#39;: &#39;MediumPurple1&#39;,
    &#39;Legendary&#39;: &#39;yellow&#39;
}

ROLES = [&#39;Command&#39;, &#39;Engineering&#39;, &#39;Medical&#39;, &#39;Science&#39;, &#39;Security&#39;]

STAT_ABBREVIATIONS = {
    &#39;Health&#39;: &#39;hlth&#39;,
    &#39;Attack&#39;: &#39;att&#39;,
    &#39;Speed&#39;: &#39;spd&#39;,
    &#39;Defense&#39;: &#39;dfn&#39;,
    &#39;Tech&#39;: &#39;tech&#39;,
    &#39;CritDamage&#39;: &#39;cd&#39;,
    &#39;CritChance&#39;: &#39;cc&#39;,
    &#39;GlancingDamage&#39;: &#39;gd&#39;,
    &#39;GlancingChance&#39;: &#39;gc&#39;,
    &#39;Resolve&#39;: &#39;res&#39;
}
STAT_INITIALS = {
    &#39;Health&#39;: &#39;H&#39;,
    &#39;Attack&#39;: &#39;A&#39;,
    &#39;Speed&#39;: &#39;S&#39;,
    &#39;Defense&#39;: &#39;D&#39;,
    &#39;Tech&#39;: &#39;T&#39;,
    &#39;CritDamage&#39;: &#39;CD&#39;,
    &#39;CritChance&#39;: &#39;CC&#39;,
    &#39;GlancingDamage&#39;: &#39;GD&#39;,
    &#39;GlancingChance&#39;: &#39;GC&#39;,
    &#39;Resolve&#39;: &#39;R&#39;
}

# initialize SUMMON_POOL and SUMMON_POOL_IDS
SUMMON_POOL = {&#39;Core&#39;: {&#39;nameIDs&#39;: {}}}
SUMMON_POOL.update({role: {&#39;nameIDs&#39;: {}} for role in ROLES})
SUMMON_POOL_IDS = bidict()
# build SUMMON_POOL_IDS; keep only highest unlocked summon pools
for pool in SUMMON_POOL:
    summonID = max(
        (
            # pylint: disable-next=undefined-variable
            data[&#39;summonId&#39;] for key, data in GSSummonSetup.items()
            if key[7:10] == pool[:3]
        ),
        key=lambda summonID:int(summonID[-2:])
    )
    SUMMON_POOL_IDS[pool] = summonID
# retrieve rarity chances
for data in GSSummonPools.values(): # pylint: disable=undefined-variable
    summonID = data[&#39;summonID&#39;]
    if summonID in SUMMON_POOL_IDS.values():
        pool = SUMMON_POOL_IDS.inverse[summonID]
        SUMMON_POOL[pool][&#39;rarityChances&#39;] = data[&#39;rarityChances&#39;]
# retrieve costs
for data in GSSummonSetup.values(): # pylint: disable=undefined-variable
    summonID = data[&#39;summonId&#39;]
    if summonID in SUMMON_POOL_IDS.values():
        pool = SUMMON_POOL_IDS.inverse[summonID]
        SUMMON_POOL[pool][&#39;cost&#39;] = data[&#39;costQuantity&#39;]
# retrieve characters in each summon pool
for data in GSSummonItems.values(): # pylint: disable=undefined-variable
    for summonID in data[&#39;filterGroups&#39;]:
        if summonID in SUMMON_POOL_IDS.values():
            pool = SUMMON_POOL_IDS.inverse[summonID]
            SUMMON_POOL[pool][&#39;nameIDs&#39;][data[&#39;itemID&#39;]] = None
# raise an error if Core does not contain everyone in other pools
for pool, data in SUMMON_POOL.items():
    if pool == &#39;Core&#39;:
        continue
    for nameID in data[&#39;nameIDs&#39;]:
        if nameID not in SUMMON_POOL[&#39;Core&#39;][&#39;nameIDs&#39;]:
            raise ValueError(
                &#39;{} in {} summon pool but not in Core&#39;.format(nameID, pool)
            )
# add summoning probabilities
for pool, data in SUMMON_POOL.items():
    for rarity in RARITIES:
        nameIDs = [
            nameID for nameID in data[&#39;nameIDs&#39;]
            # pylint: disable-next=undefined-variable
            if GSCharacter[nameID][&#39;Rarity&#39;] == rarity
        ]
        if nameIDs:
            prob = data[&#39;rarityChances&#39;][rarity] / len(nameIDs)
            for nameID in nameIDs:
                data[&#39;nameIDs&#39;][nameID] = prob

UPCOMING = [&#39;Tuvok&#39;, &#39;Gowron&#39;, &#39;JadziaDax&#39;, &#39;PicardOld&#39;, &#39;JudgeQ&#39;]

class Inventory(MutableMapping):
    &#34;&#34;&#34;A collection of items in STL.

    The `Inventory` class is a dictionary-like data structure, mapping
    each item in `ITEMS` to the quantity of that item that exists in the
    player&#39;s inventory. Keys cannot be deleted. Instead, deleting a key
    simply changes its value to 0. Iterating over an `Inventory` object
    will skip over items that are either irrelevant to the `legends`
    package, or are implemented elsewhere. The skipped items are
    determined by the `hiddenItemIDs` and `hiddenCategories` attributes.
    To iterate over all keys, simply iterate over `ITEMS`.
    The `__len__()` method also does not consider these skipped items.

    &#34;&#34;&#34;

    hiddenCategories = [&#39;Token&#39;, &#39;PlayerAvatar&#39;, &#39;Emote&#39;]
    &#34;&#34;&#34;`list of str`: A list of category names, as they appear in the
    `category` attribute of an `legends.constants.Item` instance, that
    are of limited use or implemented elsewhere in the `legends`
    package.
    &#34;&#34;&#34;

    hiddenItemIDs = [
        &#39;Credits&#39;, &#39;Dilithium&#39;, &#39;Tritanium&#39;, &#39;Player XP&#39;, &#39;PvP Stamina&#39;,
        &#39;Alliance Stamina&#39;, &#39;EventPoint&#39;, &#39;PvP Chest Points&#39;,
        &#39;Shards Advanced&#39;, &#39;Shards Elite&#39;, &#39;Shards Credit&#39;,
        &#39;Shards Biomimetic&#39;, &#39;Shards Protomatter&#39;, &#39;Shards_Worf&#39;,
        &#39;Shards_McCoy&#39;, &#39;Dungeon Currency&#39;, &#39;Dungeon Stamina&#39;
    ]
    &#34;&#34;&#34;`list of str`: A list of item IDs, as they appear in `GSItem`,
    that are of limited use or implemented elsewhere in the `legends`
    package.
    &#34;&#34;&#34;

    def __init__(self, initDict=None):
        &#34;&#34;&#34;The constructor initializes the `Inventory` instance with one
        key for each item in `ITEMS`, and all values 0. If the
        `initData` argument is given, it is used to initialize the
        values.

        Args:
            initData (dict): {`str`:`int`} A dictionary mapping item
                IDs, as they appear in `GSItem`, to nonnegative
                integers. Used to initialize the quantities in the
                `Inventory` instance.

        &#34;&#34;&#34;
        self._data = {}
        for itemID in GSItem: # pylint: disable=undefined-variable
            self._data[itemID] = 0
        initDict = {} if initDict is None else initDict
        for itemID, qty in initDict.items():
            self._data[itemID] = qty

    @property
    def xp(self):
        &#34;&#34;&#34;`int`: The total xp of all Bio-Gel items in the inventory.&#34;&#34;&#34;
        return sum(qty * item.xp for item, qty in self.itemsByCat(&#39;Bio-Gel&#39;))

    def __getitem__(self, item):
        return self._data[item.itemID]

    def __setitem__(self, item, qty):
        self._data[item.itemID] = qty

    def __delitem__(self, item):
        self._data[item.itemID] = 0

    def __iter__(self):
        for itemID in self._data:
            if not self._hidden(itemID):
                yield ITEMS[itemID]

    def __len__(self):
        count = 0
        for itemID in self._data:
            if not self._hidden(itemID):
                count += 1
        return count

    def __add__(self, other):
        result = Inventory()
        for item in self:
            result[item] = self[item] + other[item]
        return result

    def _hidden(self, itemID):
        if itemID in self.hiddenItemIDs:
            return True
        if ITEMS[itemID].category in self.hiddenCategories:
            return True
        return False

    def keysByCat(self, category):
        &#34;&#34;&#34;Returns an iterator over all keys that match the given
        category, skipping any keys that are skipped during normal
        iteration.

        Args:
            category (str): The category to iterate over.

        &#34;&#34;&#34;
        return (item for item in self if item.category == category)

    def itemsByCat(self, category):
        &#34;&#34;&#34;Returns an iterator over all (key, value) tuples that match
        the given category, skipping any keys that are skipped during
        normal iteration.

        Args:
            category (str): The category to iterate over.

        &#34;&#34;&#34;
        return (
            (item, qty) for item, qty in self.items()
            if item.category == category
        )

    def __repr__(self):
        return &#39;Inventory({!r})&#39;.format({
            itemID: qty for itemID, qty in self._data.items()
            if qty &gt; 0
        })</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="legends.constants.Inventory"><code class="flex name class">
<span>class <span class="ident">Inventory</span></span>
<span>(</span><span>initDict=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A collection of items in STL.</p>
<p>The <code><a title="legends.constants.Inventory" href="#legends.constants.Inventory">Inventory</a></code> class is a dictionary-like data structure, mapping
each item in <code>ITEMS</code> to the quantity of that item that exists in the
player's inventory. Keys cannot be deleted. Instead, deleting a key
simply changes its value to 0. Iterating over an <code><a title="legends.constants.Inventory" href="#legends.constants.Inventory">Inventory</a></code> object
will skip over items that are either irrelevant to the <code><a title="legends" href="index.html">legends</a></code>
package, or are implemented elsewhere. The skipped items are
determined by the <code>hiddenItemIDs</code> and <code>hiddenCategories</code> attributes.
To iterate over all keys, simply iterate over <code>ITEMS</code>.
The <code>__len__()</code> method also does not consider these skipped items.</p>
<p>The constructor initializes the <code><a title="legends.constants.Inventory" href="#legends.constants.Inventory">Inventory</a></code> instance with one
key for each item in <code>ITEMS</code>, and all values 0. If the
<code>initData</code> argument is given, it is used to initialize the
values.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>initData</code></strong> :&ensp;<code>dict</code></dt>
<dd>{<code>str</code>:<code>int</code>} A dictionary mapping item
IDs, as they appear in <code>GSItem</code>, to nonnegative
integers. Used to initialize the quantities in the
<code><a title="legends.constants.Inventory" href="#legends.constants.Inventory">Inventory</a></code> instance.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Inventory(MutableMapping):
    &#34;&#34;&#34;A collection of items in STL.

    The `Inventory` class is a dictionary-like data structure, mapping
    each item in `ITEMS` to the quantity of that item that exists in the
    player&#39;s inventory. Keys cannot be deleted. Instead, deleting a key
    simply changes its value to 0. Iterating over an `Inventory` object
    will skip over items that are either irrelevant to the `legends`
    package, or are implemented elsewhere. The skipped items are
    determined by the `hiddenItemIDs` and `hiddenCategories` attributes.
    To iterate over all keys, simply iterate over `ITEMS`.
    The `__len__()` method also does not consider these skipped items.

    &#34;&#34;&#34;

    hiddenCategories = [&#39;Token&#39;, &#39;PlayerAvatar&#39;, &#39;Emote&#39;]
    &#34;&#34;&#34;`list of str`: A list of category names, as they appear in the
    `category` attribute of an `legends.constants.Item` instance, that
    are of limited use or implemented elsewhere in the `legends`
    package.
    &#34;&#34;&#34;

    hiddenItemIDs = [
        &#39;Credits&#39;, &#39;Dilithium&#39;, &#39;Tritanium&#39;, &#39;Player XP&#39;, &#39;PvP Stamina&#39;,
        &#39;Alliance Stamina&#39;, &#39;EventPoint&#39;, &#39;PvP Chest Points&#39;,
        &#39;Shards Advanced&#39;, &#39;Shards Elite&#39;, &#39;Shards Credit&#39;,
        &#39;Shards Biomimetic&#39;, &#39;Shards Protomatter&#39;, &#39;Shards_Worf&#39;,
        &#39;Shards_McCoy&#39;, &#39;Dungeon Currency&#39;, &#39;Dungeon Stamina&#39;
    ]
    &#34;&#34;&#34;`list of str`: A list of item IDs, as they appear in `GSItem`,
    that are of limited use or implemented elsewhere in the `legends`
    package.
    &#34;&#34;&#34;

    def __init__(self, initDict=None):
        &#34;&#34;&#34;The constructor initializes the `Inventory` instance with one
        key for each item in `ITEMS`, and all values 0. If the
        `initData` argument is given, it is used to initialize the
        values.

        Args:
            initData (dict): {`str`:`int`} A dictionary mapping item
                IDs, as they appear in `GSItem`, to nonnegative
                integers. Used to initialize the quantities in the
                `Inventory` instance.

        &#34;&#34;&#34;
        self._data = {}
        for itemID in GSItem: # pylint: disable=undefined-variable
            self._data[itemID] = 0
        initDict = {} if initDict is None else initDict
        for itemID, qty in initDict.items():
            self._data[itemID] = qty

    @property
    def xp(self):
        &#34;&#34;&#34;`int`: The total xp of all Bio-Gel items in the inventory.&#34;&#34;&#34;
        return sum(qty * item.xp for item, qty in self.itemsByCat(&#39;Bio-Gel&#39;))

    def __getitem__(self, item):
        return self._data[item.itemID]

    def __setitem__(self, item, qty):
        self._data[item.itemID] = qty

    def __delitem__(self, item):
        self._data[item.itemID] = 0

    def __iter__(self):
        for itemID in self._data:
            if not self._hidden(itemID):
                yield ITEMS[itemID]

    def __len__(self):
        count = 0
        for itemID in self._data:
            if not self._hidden(itemID):
                count += 1
        return count

    def __add__(self, other):
        result = Inventory()
        for item in self:
            result[item] = self[item] + other[item]
        return result

    def _hidden(self, itemID):
        if itemID in self.hiddenItemIDs:
            return True
        if ITEMS[itemID].category in self.hiddenCategories:
            return True
        return False

    def keysByCat(self, category):
        &#34;&#34;&#34;Returns an iterator over all keys that match the given
        category, skipping any keys that are skipped during normal
        iteration.

        Args:
            category (str): The category to iterate over.

        &#34;&#34;&#34;
        return (item for item in self if item.category == category)

    def itemsByCat(self, category):
        &#34;&#34;&#34;Returns an iterator over all (key, value) tuples that match
        the given category, skipping any keys that are skipped during
        normal iteration.

        Args:
            category (str): The category to iterate over.

        &#34;&#34;&#34;
        return (
            (item, qty) for item, qty in self.items()
            if item.category == category
        )

    def __repr__(self):
        return &#39;Inventory({!r})&#39;.format({
            itemID: qty for itemID, qty in self._data.items()
            if qty &gt; 0
        })</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>collections.abc.MutableMapping</li>
<li>collections.abc.Mapping</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>collections.abc.Iterable</li>
<li>collections.abc.Container</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="legends.constants.Inventory.hiddenCategories"><code class="name">var <span class="ident">hiddenCategories</span></code></dt>
<dd>
<div class="desc"><p><code>list of str</code>: A list of category names, as they appear in the
<code>category</code> attribute of an <code><a title="legends.constants.Item" href="#legends.constants.Item">Item</a></code> instance, that
are of limited use or implemented elsewhere in the <code><a title="legends" href="index.html">legends</a></code>
package.</p></div>
</dd>
<dt id="legends.constants.Inventory.hiddenItemIDs"><code class="name">var <span class="ident">hiddenItemIDs</span></code></dt>
<dd>
<div class="desc"><p><code>list of str</code>: A list of item IDs, as they appear in <code>GSItem</code>,
that are of limited use or implemented elsewhere in the <code><a title="legends" href="index.html">legends</a></code>
package.</p></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="legends.constants.Inventory.xp"><code class="name">var <span class="ident">xp</span></code></dt>
<dd>
<div class="desc"><p><code>int</code>: The total xp of all Bio-Gel items in the inventory.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def xp(self):
    &#34;&#34;&#34;`int`: The total xp of all Bio-Gel items in the inventory.&#34;&#34;&#34;
    return sum(qty * item.xp for item, qty in self.itemsByCat(&#39;Bio-Gel&#39;))</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="legends.constants.Inventory.itemsByCat"><code class="name flex">
<span>def <span class="ident">itemsByCat</span></span>(<span>self, category)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns an iterator over all (key, value) tuples that match
the given category, skipping any keys that are skipped during
normal iteration.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>category</code></strong> :&ensp;<code>str</code></dt>
<dd>The category to iterate over.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def itemsByCat(self, category):
    &#34;&#34;&#34;Returns an iterator over all (key, value) tuples that match
    the given category, skipping any keys that are skipped during
    normal iteration.

    Args:
        category (str): The category to iterate over.

    &#34;&#34;&#34;
    return (
        (item, qty) for item, qty in self.items()
        if item.category == category
    )</code></pre>
</details>
</dd>
<dt id="legends.constants.Inventory.keysByCat"><code class="name flex">
<span>def <span class="ident">keysByCat</span></span>(<span>self, category)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns an iterator over all keys that match the given
category, skipping any keys that are skipped during normal
iteration.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>category</code></strong> :&ensp;<code>str</code></dt>
<dd>The category to iterate over.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def keysByCat(self, category):
    &#34;&#34;&#34;Returns an iterator over all keys that match the given
    category, skipping any keys that are skipped during normal
    iteration.

    Args:
        category (str): The category to iterate over.

    &#34;&#34;&#34;
    return (item for item in self if item.category == category)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="legends.constants.Item"><code class="flex name class">
<span>class <span class="ident">Item</span></span>
<span>(</span><span>itemID)</span>
</code></dt>
<dd>
<div class="desc"><p>An item in STL.</p>
<p>An <code><a title="legends.constants.Item" href="#legends.constants.Item">Item</a></code> instance has no public attributes. All its data should be
accessed through its read-only properties. It is meant to be used
like an immutable data type.</p>
<p>The constructor builds the item from the given item ID,
which should match a key in <code>GSItem</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Item():
    &#34;&#34;&#34;An item in STL.

    An `Item` instance has no public attributes. All its data should be
    accessed through its read-only properties. It is meant to be used
    like an immutable data type.

    &#34;&#34;&#34;

    _betterCategoryNames = {
        &#39;BiomimeticGel&#39;: &#39;Bio-Gel&#39;,
        &#39;Item&#39;: &#39;General Items&#39;,
        &#39;ProtoMatter&#39;: &#39;Protomatter&#39;,
    }

    def __init__(self, itemID):
        &#34;&#34;&#34;The constructor builds the item from the given item ID,
        which should match a key in `GSItem`.

        &#34;&#34;&#34;
        self._itemID = itemID
        itemData = GSItem[itemID] # pylint: disable=undefined-variable
        dataCat = itemData[&#39;category&#39;]
        self._category = self._betterCategoryNames.get(dataCat, dataCat)
        if itemData[&#39;icon&#39;][:4] == &#39;Gear&#39;:
            if itemData[&#39;rarity&#39;] == &#39;Common&#39;:
                self._category = &#39;Gear Leveling Materials&#39;
            else:
                self._category = &#39;Gear Ranking Materials&#39;

    @property
    def itemID(self):
        &#34;&#34;&#34;`str`: The in-data item ID of the item. Should match a key in
        `GSItem`.
        &#34;&#34;&#34;
        return self._itemID

    @property
    def name(self):
        &#34;&#34;&#34;`str`: The in-game name of the item.&#34;&#34;&#34;
        # pylint: disable-next=undefined-variable
        itemData = GSItem[self.itemID]
        return (
            DESCRIPTIONS[itemData[&#39;name&#39;]] if &#39;name&#39; in itemData
            else self.itemID
        )

    @property
    def category(self):
        &#34;&#34;&#34;`str`: The category of the item. Categories appear in
        `GSItem`. The `Item` class replaces the category found there in
        the following cases. It replaces &#39;BiomimeticGel&#39; with &#39;Bio-Gel&#39;,
        &#39;Item&#39; with &#39;General Items&#39;, and &#39;ProtoMatter&#39; with
        &#39;Protomatter&#39;. Also, if the item is a gear-leveling or gear
        ranking material, the category is replaced by &#39;Gear Leveling
        Materials&#39; or &#39;Gear Ranking Materials&#39;, respectively.
        &#34;&#34;&#34;
        return self._category

    @property
    def xp(self):
        &#34;&#34;&#34;`int`: If the item is a bio-gel, this is the amount of xp it
        awards; otherwise it is 0.
        &#34;&#34;&#34;
        try:
            # pylint: disable-next=undefined-variable
            return GSItem[self.itemID][&#39;DataBiomimeticGel&#39;][&#39;Xp&#39;]
        except KeyError:
            return 0

    @property
    def role(self):
        &#34;&#34;&#34;`str`: If the item is protomatter, this is the role that the
        protomatter is meant for; otherwise it is `None`.
        &#34;&#34;&#34;
        if self.category != &#39;Protomatter&#39;:
            return None
        roleName = self.itemID[6:-3]
        roleName = &#39;Engineering&#39; if roleName == &#39;Engineer&#39; else roleName
        return roleName

    def __repr__(self):
        return &#39;&lt;Item: {!r}&gt;&#39;.format(self.name)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="legends.constants.Item.category"><code class="name">var <span class="ident">category</span></code></dt>
<dd>
<div class="desc"><p><code>str</code>: The category of the item. Categories appear in
<code>GSItem</code>. The <code><a title="legends.constants.Item" href="#legends.constants.Item">Item</a></code> class replaces the category found there in
the following cases. It replaces 'BiomimeticGel' with 'Bio-Gel',
'Item' with 'General Items', and 'ProtoMatter' with
'Protomatter'. Also, if the item is a gear-leveling or gear
ranking material, the category is replaced by 'Gear Leveling
Materials' or 'Gear Ranking Materials', respectively.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def category(self):
    &#34;&#34;&#34;`str`: The category of the item. Categories appear in
    `GSItem`. The `Item` class replaces the category found there in
    the following cases. It replaces &#39;BiomimeticGel&#39; with &#39;Bio-Gel&#39;,
    &#39;Item&#39; with &#39;General Items&#39;, and &#39;ProtoMatter&#39; with
    &#39;Protomatter&#39;. Also, if the item is a gear-leveling or gear
    ranking material, the category is replaced by &#39;Gear Leveling
    Materials&#39; or &#39;Gear Ranking Materials&#39;, respectively.
    &#34;&#34;&#34;
    return self._category</code></pre>
</details>
</dd>
<dt id="legends.constants.Item.itemID"><code class="name">var <span class="ident">itemID</span></code></dt>
<dd>
<div class="desc"><p><code>str</code>: The in-data item ID of the item. Should match a key in
<code>GSItem</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def itemID(self):
    &#34;&#34;&#34;`str`: The in-data item ID of the item. Should match a key in
    `GSItem`.
    &#34;&#34;&#34;
    return self._itemID</code></pre>
</details>
</dd>
<dt id="legends.constants.Item.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p><code>str</code>: The in-game name of the item.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self):
    &#34;&#34;&#34;`str`: The in-game name of the item.&#34;&#34;&#34;
    # pylint: disable-next=undefined-variable
    itemData = GSItem[self.itemID]
    return (
        DESCRIPTIONS[itemData[&#39;name&#39;]] if &#39;name&#39; in itemData
        else self.itemID
    )</code></pre>
</details>
</dd>
<dt id="legends.constants.Item.role"><code class="name">var <span class="ident">role</span></code></dt>
<dd>
<div class="desc"><p><code>str</code>: If the item is protomatter, this is the role that the
protomatter is meant for; otherwise it is <code>None</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def role(self):
    &#34;&#34;&#34;`str`: If the item is protomatter, this is the role that the
    protomatter is meant for; otherwise it is `None`.
    &#34;&#34;&#34;
    if self.category != &#39;Protomatter&#39;:
        return None
    roleName = self.itemID[6:-3]
    roleName = &#39;Engineering&#39; if roleName == &#39;Engineer&#39; else roleName
    return roleName</code></pre>
</details>
</dd>
<dt id="legends.constants.Item.xp"><code class="name">var <span class="ident">xp</span></code></dt>
<dd>
<div class="desc"><p><code>int</code>: If the item is a bio-gel, this is the amount of xp it
awards; otherwise it is 0.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def xp(self):
    &#34;&#34;&#34;`int`: If the item is a bio-gel, this is the amount of xp it
    awards; otherwise it is 0.
    &#34;&#34;&#34;
    try:
        # pylint: disable-next=undefined-variable
        return GSItem[self.itemID][&#39;DataBiomimeticGel&#39;][&#39;Xp&#39;]
    except KeyError:
        return 0</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="legends" href="index.html">legends</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="legends.constants.Inventory" href="#legends.constants.Inventory">Inventory</a></code></h4>
<ul class="">
<li><code><a title="legends.constants.Inventory.hiddenCategories" href="#legends.constants.Inventory.hiddenCategories">hiddenCategories</a></code></li>
<li><code><a title="legends.constants.Inventory.hiddenItemIDs" href="#legends.constants.Inventory.hiddenItemIDs">hiddenItemIDs</a></code></li>
<li><code><a title="legends.constants.Inventory.itemsByCat" href="#legends.constants.Inventory.itemsByCat">itemsByCat</a></code></li>
<li><code><a title="legends.constants.Inventory.keysByCat" href="#legends.constants.Inventory.keysByCat">keysByCat</a></code></li>
<li><code><a title="legends.constants.Inventory.xp" href="#legends.constants.Inventory.xp">xp</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="legends.constants.Item" href="#legends.constants.Item">Item</a></code></h4>
<ul class="">
<li><code><a title="legends.constants.Item.category" href="#legends.constants.Item.category">category</a></code></li>
<li><code><a title="legends.constants.Item.itemID" href="#legends.constants.Item.itemID">itemID</a></code></li>
<li><code><a title="legends.constants.Item.name" href="#legends.constants.Item.name">name</a></code></li>
<li><code><a title="legends.constants.Item.role" href="#legends.constants.Item.role">role</a></code></li>
<li><code><a title="legends.constants.Item.xp" href="#legends.constants.Item.xp">xp</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>