<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>legends.stats API documentation</title>
<meta name="description" content="Tools for storing and manipulating STL object statistics." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>legends.stats</code></h1>
</header>
<section id="section-intro">
<p>Tools for storing and manipulating STL object statistics.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Tools for storing and manipulating STL object statistics.

&#34;&#34;&#34;

from legends.utils.functions import formatDict
from legends.utils.eventhandler import Event, EventHandler
from legends.constants import PART_EFFECTS, POWER_GRADIENT, STAT_ABBREVIATIONS

__all__ = [
    &#39;checkForStats&#39;,
    &#39;PartEffects&#39;,
    &#39;StatChangeEvent&#39;,
    &#39;StatObject&#39;,
    &#39;Stats&#39;
]

def checkForStats(obj):
    &#34;&#34;&#34;Checks if the given objects has a &#39;stats&#39; attribute that points
    to a `StatObject` instance.

    Args:
        obj (obj): The object to check.

    Raises:
        ValueError: If the object fails the check.

    &#34;&#34;&#34;
    if not hasattr(obj, &#39;stats&#39;):
        raise ValueError(&#39;{} has no `stats` attribute&#39;.format(obj))
    if not isinstance(obj.stats, StatObject):
        raise ValueError(
            &#39;{} is not an instance of `StatObject`&#39;.format(obj.stats)
        )

class StatChangeEvent(Event): # pylint: disable=too-few-public-methods
    &#34;&#34;&#34;Created when one of a `StatObject`&#39;s attributes changes.

    Should only be created when the changing attribute is a statistic.

    Attributes:
        parent (obj): The object whose statistics have changed.
        attrName (str): The name of the statistic that changed.
        oldVal (int or float): The old value of the statistic.
        newVal (int or float): The new value of the statistic.

    &#34;&#34;&#34;

    def __init__(self, parent, attrName, oldVal, newVal):
        self.parent = parent
        self.attrName = attrName
        self.oldVal = oldVal
        self.newVal = newVal

class StatObject():
    &#34;&#34;&#34;An object that stores named statistics as attributes.

    The `StatObject` class is meant to be subclassed. Subclasses must
    set `statAbbrs` to an iterable that iterates over the names
    (typically abbreviations) of the statistics being stored in the
    subclass. The subclass constructor must be able to accept no
    arguments, and when it does, it should create an object, all of
    whose statistics are zero.

    Two `StatObject` instances can be added/multiplied. The result is a
    new `StatObject` instance whose statistics are the sum/product of
    the statistics of the given instances.

    Attributes:
        parent (obj): The object to which these stats belong.
        onChange (legends.utils.eventhandler.EventHandler): Sends a
            `StatChangeEvent` to subscribers when a statistic changes.
        silent (bool): Set to `True` to prevent the sending of a
            `StatChangeEvent` when a statistic changes. Defaults to
            `False`.

    &#34;&#34;&#34;

    def __init__(self, statAbbrs, parent=None, initDict=None):
        &#34;&#34;&#34;If a dictionary of stat values is provided, the constructor
        initializes the instance with these values.

        Args:
            statAbbrs (dict): {`str`:`str`} The dictionary to assign to
                the `statAbbrs` property.
            initDict (dict): {`str`:`int or float`} A dictionary mapping
                stat names to numerical values. The keys of `initDict`
                should match the keys of the `statAbbrs` property.

        &#34;&#34;&#34;
        self._statAbbrs = statAbbrs
        self.parent = parent
        self.silent = False
        self.onChange = EventHandler()
        if initDict is None:
            initDict = {statName: 0 for statName in self.statAbbrs}
        self.update(initDict)

    @property
    def statAbbrs(self):
        &#34;&#34;&#34;dict: {`str`:`str`} A dictionary mapping the names of stats
        to be stored to the abbreviations that are to be used as
        attribute names.
        &#34;&#34;&#34;
        return self._statAbbrs

    def __setattr__(self, attrName, value):
        oldVal = getattr(self, attrName) if hasattr(self, attrName) else None
        self.__dict__[attrName] = value
        if (
            attrName in self.statAbbrs.values()
            and oldVal != value
            and not self.silent
        ):
            self.onChange.notify(StatChangeEvent(
                self.parent, attrName, oldVal, value
            ))

    def get(self, statName):
        &#34;&#34;&#34;Looks up a stat value by its name, as it appears in the keys
        of the `statAbbrs` property.

        Args:
            statName (str): A stat name, as it appears in the keys of
                the `statAbbrs` property.

        Returns:
            int or float: The value of the given stat.

        &#34;&#34;&#34;
        return getattr(self, self.statAbbrs[statName])

    def set(self, statName, value):
        &#34;&#34;&#34;Sets a stat value by its name, as it appears in the keys of
        the `statAbbrs` property.

        Args:
            statName (str): A stat name, as it appears in the keys of
                the `statAbbrs` property.
            value (int or float): The value to assign.

        &#34;&#34;&#34;
        setattr(self, self.statAbbrs[statName], value)

    def update(self, statDict):
        &#34;&#34;&#34;Sets the stat attributes to those contained in the given stat
        dictionary.

        Args:
            statDict (dict): {`str`:`int or float`} A dictionary mapping
                stat names to numerical values. The keys of `statDict`
                should match the keys of the `statAbbrs` attribute.

        &#34;&#34;&#34;
        for statName, statVal in statDict.items():
            setattr(self, self.statAbbrs[statName], statVal)

    def __add__(self, other):
        result = self.__class__(self.statAbbrs)
        for statAbbr in self.statAbbrs.values():
            statSum = getattr(self, statAbbr) + getattr(other, statAbbr)
            setattr(result, statAbbr, statSum)
        return result

    def __mul__(self, other):
        result = self.__class__(self.statAbbrs)
        for statAbbr in self.statAbbrs.values():
            statProd = getattr(self, statAbbr) * getattr(other, statAbbr)
            setattr(result, statAbbr, statProd)
        return result

    def __repr__(self):
        return &#39;StatObject({})&#39;.format(formatDict({
            statAbbr: getattr(self, statAbbr) for statAbbr in self.statAbbrs
        }))

class Stats(StatObject):
    &#34;&#34;&#34;Stores the basic stats in STL.

    A subclass of `StatObject` whose `statAbbrs` property is set to
    `STAT_ABBREVIATIONS`.

    &#34;&#34;&#34;

    def __init__(self, parent=None, initDict=None):
        StatObject.__init__(self, STAT_ABBREVIATIONS.copy(), parent, initDict)

    @property
    def power(self):
        &#34;&#34;&#34;The additional power that would be added to a character if
        its stats increased by the amounts given in the calling
        instance.
        &#34;&#34;&#34;
        powerDelta = 0
        for statName in STAT_ABBREVIATIONS:
            statVal = self.get(statName)
            powerDelta += POWER_GRADIENT[statName] * statVal
        return powerDelta

class PartEffects(StatObject):
    &#34;&#34;&#34;Stats describing effects of particles in STL.

    A subclass of `StatObject` whose `statAbbrs` property is set to
    `PART_EFFECTS`.

    &#34;&#34;&#34;

    def __init__(self, parent=None, initDict=None):
        &#34;&#34;&#34;If a dictionary of stat values is provided, the constructor
        initializes the instance with these values.

        Args:
            initDict (dict): {`str`:`int or float`} A dictionary mapping
                the stat names in the keys of `PART_EFFECTS` to
                numerical values.

        &#34;&#34;&#34;
        StatObject.__init__(self, PART_EFFECTS, parent, initDict)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="legends.stats.checkForStats"><code class="name flex">
<span>def <span class="ident">checkForStats</span></span>(<span>obj)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if the given objects has a 'stats' attribute that points
to a <code><a title="legends.stats.StatObject" href="#legends.stats.StatObject">StatObject</a></code> instance.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>obj</code></strong> :&ensp;<code>obj</code></dt>
<dd>The object to check.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the object fails the check.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def checkForStats(obj):
    &#34;&#34;&#34;Checks if the given objects has a &#39;stats&#39; attribute that points
    to a `StatObject` instance.

    Args:
        obj (obj): The object to check.

    Raises:
        ValueError: If the object fails the check.

    &#34;&#34;&#34;
    if not hasattr(obj, &#39;stats&#39;):
        raise ValueError(&#39;{} has no `stats` attribute&#39;.format(obj))
    if not isinstance(obj.stats, StatObject):
        raise ValueError(
            &#39;{} is not an instance of `StatObject`&#39;.format(obj.stats)
        )</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="legends.stats.PartEffects"><code class="flex name class">
<span>class <span class="ident">PartEffects</span></span>
<span>(</span><span>parent=None, initDict=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Stats describing effects of particles in STL.</p>
<p>A subclass of <code><a title="legends.stats.StatObject" href="#legends.stats.StatObject">StatObject</a></code> whose <code>statAbbrs</code> property is set to
<code>PART_EFFECTS</code>.</p>
<p>If a dictionary of stat values is provided, the constructor
initializes the instance with these values.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>initDict</code></strong> :&ensp;<code>dict</code></dt>
<dd>{<code>str</code>:<code>int or float</code>} A dictionary mapping
the stat names in the keys of <code>PART_EFFECTS</code> to
numerical values.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PartEffects(StatObject):
    &#34;&#34;&#34;Stats describing effects of particles in STL.

    A subclass of `StatObject` whose `statAbbrs` property is set to
    `PART_EFFECTS`.

    &#34;&#34;&#34;

    def __init__(self, parent=None, initDict=None):
        &#34;&#34;&#34;If a dictionary of stat values is provided, the constructor
        initializes the instance with these values.

        Args:
            initDict (dict): {`str`:`int or float`} A dictionary mapping
                the stat names in the keys of `PART_EFFECTS` to
                numerical values.

        &#34;&#34;&#34;
        StatObject.__init__(self, PART_EFFECTS, parent, initDict)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="legends.stats.StatObject" href="#legends.stats.StatObject">StatObject</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="legends.stats.StatObject" href="#legends.stats.StatObject">StatObject</a></b></code>:
<ul class="hlist">
<li><code><a title="legends.stats.StatObject.get" href="#legends.stats.StatObject.get">get</a></code></li>
<li><code><a title="legends.stats.StatObject.set" href="#legends.stats.StatObject.set">set</a></code></li>
<li><code><a title="legends.stats.StatObject.statAbbrs" href="#legends.stats.StatObject.statAbbrs">statAbbrs</a></code></li>
<li><code><a title="legends.stats.StatObject.update" href="#legends.stats.StatObject.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="legends.stats.StatChangeEvent"><code class="flex name class">
<span>class <span class="ident">StatChangeEvent</span></span>
<span>(</span><span>parent, attrName, oldVal, newVal)</span>
</code></dt>
<dd>
<div class="desc"><p>Created when one of a <code><a title="legends.stats.StatObject" href="#legends.stats.StatObject">StatObject</a></code>'s attributes changes.</p>
<p>Should only be created when the changing attribute is a statistic.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>parent</code></strong> :&ensp;<code>obj</code></dt>
<dd>The object whose statistics have changed.</dd>
<dt><strong><code>attrName</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the statistic that changed.</dd>
<dt><strong><code>oldVal</code></strong> :&ensp;<code>int</code> or <code>float</code></dt>
<dd>The old value of the statistic.</dd>
<dt><strong><code>newVal</code></strong> :&ensp;<code>int</code> or <code>float</code></dt>
<dd>The new value of the statistic.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StatChangeEvent(Event): # pylint: disable=too-few-public-methods
    &#34;&#34;&#34;Created when one of a `StatObject`&#39;s attributes changes.

    Should only be created when the changing attribute is a statistic.

    Attributes:
        parent (obj): The object whose statistics have changed.
        attrName (str): The name of the statistic that changed.
        oldVal (int or float): The old value of the statistic.
        newVal (int or float): The new value of the statistic.

    &#34;&#34;&#34;

    def __init__(self, parent, attrName, oldVal, newVal):
        self.parent = parent
        self.attrName = attrName
        self.oldVal = oldVal
        self.newVal = newVal</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="legends.utils.eventhandler.Event" href="utils/eventhandler.html#legends.utils.eventhandler.Event">Event</a></li>
</ul>
</dd>
<dt id="legends.stats.StatObject"><code class="flex name class">
<span>class <span class="ident">StatObject</span></span>
<span>(</span><span>statAbbrs, parent=None, initDict=None)</span>
</code></dt>
<dd>
<div class="desc"><p>An object that stores named statistics as attributes.</p>
<p>The <code><a title="legends.stats.StatObject" href="#legends.stats.StatObject">StatObject</a></code> class is meant to be subclassed. Subclasses must
set <code>statAbbrs</code> to an iterable that iterates over the names
(typically abbreviations) of the statistics being stored in the
subclass. The subclass constructor must be able to accept no
arguments, and when it does, it should create an object, all of
whose statistics are zero.</p>
<p>Two <code><a title="legends.stats.StatObject" href="#legends.stats.StatObject">StatObject</a></code> instances can be added/multiplied. The result is a
new <code><a title="legends.stats.StatObject" href="#legends.stats.StatObject">StatObject</a></code> instance whose statistics are the sum/product of
the statistics of the given instances.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>parent</code></strong> :&ensp;<code>obj</code></dt>
<dd>The object to which these stats belong.</dd>
<dt><strong><code>onChange</code></strong> :&ensp;<code><a title="legends.utils.eventhandler.EventHandler" href="utils/eventhandler.html#legends.utils.eventhandler.EventHandler">EventHandler</a></code></dt>
<dd>Sends a
<code><a title="legends.stats.StatChangeEvent" href="#legends.stats.StatChangeEvent">StatChangeEvent</a></code> to subscribers when a statistic changes.</dd>
<dt><strong><code>silent</code></strong> :&ensp;<code>bool</code></dt>
<dd>Set to <code>True</code> to prevent the sending of a
<code><a title="legends.stats.StatChangeEvent" href="#legends.stats.StatChangeEvent">StatChangeEvent</a></code> when a statistic changes. Defaults to
<code>False</code>.</dd>
</dl>
<p>If a dictionary of stat values is provided, the constructor
initializes the instance with these values.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>statAbbrs</code></strong> :&ensp;<code>dict</code></dt>
<dd>{<code>str</code>:<code>str</code>} The dictionary to assign to
the <code>statAbbrs</code> property.</dd>
<dt><strong><code>initDict</code></strong> :&ensp;<code>dict</code></dt>
<dd>{<code>str</code>:<code>int or float</code>} A dictionary mapping
stat names to numerical values. The keys of <code>initDict</code>
should match the keys of the <code>statAbbrs</code> property.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StatObject():
    &#34;&#34;&#34;An object that stores named statistics as attributes.

    The `StatObject` class is meant to be subclassed. Subclasses must
    set `statAbbrs` to an iterable that iterates over the names
    (typically abbreviations) of the statistics being stored in the
    subclass. The subclass constructor must be able to accept no
    arguments, and when it does, it should create an object, all of
    whose statistics are zero.

    Two `StatObject` instances can be added/multiplied. The result is a
    new `StatObject` instance whose statistics are the sum/product of
    the statistics of the given instances.

    Attributes:
        parent (obj): The object to which these stats belong.
        onChange (legends.utils.eventhandler.EventHandler): Sends a
            `StatChangeEvent` to subscribers when a statistic changes.
        silent (bool): Set to `True` to prevent the sending of a
            `StatChangeEvent` when a statistic changes. Defaults to
            `False`.

    &#34;&#34;&#34;

    def __init__(self, statAbbrs, parent=None, initDict=None):
        &#34;&#34;&#34;If a dictionary of stat values is provided, the constructor
        initializes the instance with these values.

        Args:
            statAbbrs (dict): {`str`:`str`} The dictionary to assign to
                the `statAbbrs` property.
            initDict (dict): {`str`:`int or float`} A dictionary mapping
                stat names to numerical values. The keys of `initDict`
                should match the keys of the `statAbbrs` property.

        &#34;&#34;&#34;
        self._statAbbrs = statAbbrs
        self.parent = parent
        self.silent = False
        self.onChange = EventHandler()
        if initDict is None:
            initDict = {statName: 0 for statName in self.statAbbrs}
        self.update(initDict)

    @property
    def statAbbrs(self):
        &#34;&#34;&#34;dict: {`str`:`str`} A dictionary mapping the names of stats
        to be stored to the abbreviations that are to be used as
        attribute names.
        &#34;&#34;&#34;
        return self._statAbbrs

    def __setattr__(self, attrName, value):
        oldVal = getattr(self, attrName) if hasattr(self, attrName) else None
        self.__dict__[attrName] = value
        if (
            attrName in self.statAbbrs.values()
            and oldVal != value
            and not self.silent
        ):
            self.onChange.notify(StatChangeEvent(
                self.parent, attrName, oldVal, value
            ))

    def get(self, statName):
        &#34;&#34;&#34;Looks up a stat value by its name, as it appears in the keys
        of the `statAbbrs` property.

        Args:
            statName (str): A stat name, as it appears in the keys of
                the `statAbbrs` property.

        Returns:
            int or float: The value of the given stat.

        &#34;&#34;&#34;
        return getattr(self, self.statAbbrs[statName])

    def set(self, statName, value):
        &#34;&#34;&#34;Sets a stat value by its name, as it appears in the keys of
        the `statAbbrs` property.

        Args:
            statName (str): A stat name, as it appears in the keys of
                the `statAbbrs` property.
            value (int or float): The value to assign.

        &#34;&#34;&#34;
        setattr(self, self.statAbbrs[statName], value)

    def update(self, statDict):
        &#34;&#34;&#34;Sets the stat attributes to those contained in the given stat
        dictionary.

        Args:
            statDict (dict): {`str`:`int or float`} A dictionary mapping
                stat names to numerical values. The keys of `statDict`
                should match the keys of the `statAbbrs` attribute.

        &#34;&#34;&#34;
        for statName, statVal in statDict.items():
            setattr(self, self.statAbbrs[statName], statVal)

    def __add__(self, other):
        result = self.__class__(self.statAbbrs)
        for statAbbr in self.statAbbrs.values():
            statSum = getattr(self, statAbbr) + getattr(other, statAbbr)
            setattr(result, statAbbr, statSum)
        return result

    def __mul__(self, other):
        result = self.__class__(self.statAbbrs)
        for statAbbr in self.statAbbrs.values():
            statProd = getattr(self, statAbbr) * getattr(other, statAbbr)
            setattr(result, statAbbr, statProd)
        return result

    def __repr__(self):
        return &#39;StatObject({})&#39;.format(formatDict({
            statAbbr: getattr(self, statAbbr) for statAbbr in self.statAbbrs
        }))</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="legends.stats.PartEffects" href="#legends.stats.PartEffects">PartEffects</a></li>
<li><a title="legends.stats.Stats" href="#legends.stats.Stats">Stats</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="legends.stats.StatObject.statAbbrs"><code class="name">var <span class="ident">statAbbrs</span></code></dt>
<dd>
<div class="desc"><p>dict: {<code>str</code>:<code>str</code>} A dictionary mapping the names of stats
to be stored to the abbreviations that are to be used as
attribute names.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def statAbbrs(self):
    &#34;&#34;&#34;dict: {`str`:`str`} A dictionary mapping the names of stats
    to be stored to the abbreviations that are to be used as
    attribute names.
    &#34;&#34;&#34;
    return self._statAbbrs</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="legends.stats.StatObject.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, statName)</span>
</code></dt>
<dd>
<div class="desc"><p>Looks up a stat value by its name, as it appears in the keys
of the <code>statAbbrs</code> property.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>statName</code></strong> :&ensp;<code>str</code></dt>
<dd>A stat name, as it appears in the keys of
the <code>statAbbrs</code> property.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code> or <code>float</code></dt>
<dd>The value of the given stat.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, statName):
    &#34;&#34;&#34;Looks up a stat value by its name, as it appears in the keys
    of the `statAbbrs` property.

    Args:
        statName (str): A stat name, as it appears in the keys of
            the `statAbbrs` property.

    Returns:
        int or float: The value of the given stat.

    &#34;&#34;&#34;
    return getattr(self, self.statAbbrs[statName])</code></pre>
</details>
</dd>
<dt id="legends.stats.StatObject.set"><code class="name flex">
<span>def <span class="ident">set</span></span>(<span>self, statName, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets a stat value by its name, as it appears in the keys of
the <code>statAbbrs</code> property.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>statName</code></strong> :&ensp;<code>str</code></dt>
<dd>A stat name, as it appears in the keys of
the <code>statAbbrs</code> property.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>int</code> or <code>float</code></dt>
<dd>The value to assign.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set(self, statName, value):
    &#34;&#34;&#34;Sets a stat value by its name, as it appears in the keys of
    the `statAbbrs` property.

    Args:
        statName (str): A stat name, as it appears in the keys of
            the `statAbbrs` property.
        value (int or float): The value to assign.

    &#34;&#34;&#34;
    setattr(self, self.statAbbrs[statName], value)</code></pre>
</details>
</dd>
<dt id="legends.stats.StatObject.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, statDict)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the stat attributes to those contained in the given stat
dictionary.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>statDict</code></strong> :&ensp;<code>dict</code></dt>
<dd>{<code>str</code>:<code>int or float</code>} A dictionary mapping
stat names to numerical values. The keys of <code>statDict</code>
should match the keys of the <code>statAbbrs</code> attribute.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, statDict):
    &#34;&#34;&#34;Sets the stat attributes to those contained in the given stat
    dictionary.

    Args:
        statDict (dict): {`str`:`int or float`} A dictionary mapping
            stat names to numerical values. The keys of `statDict`
            should match the keys of the `statAbbrs` attribute.

    &#34;&#34;&#34;
    for statName, statVal in statDict.items():
        setattr(self, self.statAbbrs[statName], statVal)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="legends.stats.Stats"><code class="flex name class">
<span>class <span class="ident">Stats</span></span>
<span>(</span><span>parent=None, initDict=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Stores the basic stats in STL.</p>
<p>A subclass of <code><a title="legends.stats.StatObject" href="#legends.stats.StatObject">StatObject</a></code> whose <code>statAbbrs</code> property is set to
<code>STAT_ABBREVIATIONS</code>.</p>
<p>If a dictionary of stat values is provided, the constructor
initializes the instance with these values.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>statAbbrs</code></strong> :&ensp;<code>dict</code></dt>
<dd>{<code>str</code>:<code>str</code>} The dictionary to assign to
the <code>statAbbrs</code> property.</dd>
<dt><strong><code>initDict</code></strong> :&ensp;<code>dict</code></dt>
<dd>{<code>str</code>:<code>int or float</code>} A dictionary mapping
stat names to numerical values. The keys of <code>initDict</code>
should match the keys of the <code>statAbbrs</code> property.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Stats(StatObject):
    &#34;&#34;&#34;Stores the basic stats in STL.

    A subclass of `StatObject` whose `statAbbrs` property is set to
    `STAT_ABBREVIATIONS`.

    &#34;&#34;&#34;

    def __init__(self, parent=None, initDict=None):
        StatObject.__init__(self, STAT_ABBREVIATIONS.copy(), parent, initDict)

    @property
    def power(self):
        &#34;&#34;&#34;The additional power that would be added to a character if
        its stats increased by the amounts given in the calling
        instance.
        &#34;&#34;&#34;
        powerDelta = 0
        for statName in STAT_ABBREVIATIONS:
            statVal = self.get(statName)
            powerDelta += POWER_GRADIENT[statName] * statVal
        return powerDelta</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="legends.stats.StatObject" href="#legends.stats.StatObject">StatObject</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="legends.stats.Stats.power"><code class="name">var <span class="ident">power</span></code></dt>
<dd>
<div class="desc"><p>The additional power that would be added to a character if
its stats increased by the amounts given in the calling
instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def power(self):
    &#34;&#34;&#34;The additional power that would be added to a character if
    its stats increased by the amounts given in the calling
    instance.
    &#34;&#34;&#34;
    powerDelta = 0
    for statName in STAT_ABBREVIATIONS:
        statVal = self.get(statName)
        powerDelta += POWER_GRADIENT[statName] * statVal
    return powerDelta</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="legends.stats.StatObject" href="#legends.stats.StatObject">StatObject</a></b></code>:
<ul class="hlist">
<li><code><a title="legends.stats.StatObject.get" href="#legends.stats.StatObject.get">get</a></code></li>
<li><code><a title="legends.stats.StatObject.set" href="#legends.stats.StatObject.set">set</a></code></li>
<li><code><a title="legends.stats.StatObject.statAbbrs" href="#legends.stats.StatObject.statAbbrs">statAbbrs</a></code></li>
<li><code><a title="legends.stats.StatObject.update" href="#legends.stats.StatObject.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="legends" href="index.html">legends</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="legends.stats.checkForStats" href="#legends.stats.checkForStats">checkForStats</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="legends.stats.PartEffects" href="#legends.stats.PartEffects">PartEffects</a></code></h4>
</li>
<li>
<h4><code><a title="legends.stats.StatChangeEvent" href="#legends.stats.StatChangeEvent">StatChangeEvent</a></code></h4>
</li>
<li>
<h4><code><a title="legends.stats.StatObject" href="#legends.stats.StatObject">StatObject</a></code></h4>
<ul class="">
<li><code><a title="legends.stats.StatObject.get" href="#legends.stats.StatObject.get">get</a></code></li>
<li><code><a title="legends.stats.StatObject.set" href="#legends.stats.StatObject.set">set</a></code></li>
<li><code><a title="legends.stats.StatObject.statAbbrs" href="#legends.stats.StatObject.statAbbrs">statAbbrs</a></code></li>
<li><code><a title="legends.stats.StatObject.update" href="#legends.stats.StatObject.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="legends.stats.Stats" href="#legends.stats.Stats">Stats</a></code></h4>
<ul class="">
<li><code><a title="legends.stats.Stats.power" href="#legends.stats.Stats.power">power</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>