<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>legends.stats API documentation</title>
<meta name="description" content="Tools for storing and manipulating STL object statistics." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>legends.stats</code></h1>
</header>
<section id="section-intro">
<p>Tools for storing and manipulating STL object statistics.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Tools for storing and manipulating STL object statistics.

&#34;&#34;&#34;

from legends.utils.functions import formatDict, objDict
from legends.utils.eventhandler import Event, EventHandler
from legends.constants import (
    PART_EFFECTS, POWER_GRADIENT, STAT_ABBREVIATIONS, THREAT_STATS
)

__all__ = [
    &#39;checkForStats&#39;,
    &#39;PartEffects&#39;,
    &#39;StatChangeEvent&#39;,
    &#39;StatMods&#39;,
    &#39;StatObject&#39;,
    &#39;Stats&#39;,
    &#39;ThreatStats&#39;
]

def checkForStats(obj):
    &#34;&#34;&#34;Checks if the given objects has a &#39;stats&#39; attribute that points
    to a `StatObject` instance.

    Args:
        obj (obj): The object to check.

    Raises:
        ValueError: If the object fails the check.

    &#34;&#34;&#34;
    if not hasattr(obj, &#39;stats&#39;):
        raise ValueError(&#39;{} has no `stats` attribute&#39;.format(obj))
    if not isinstance(obj.stats, StatObject):
        raise ValueError(
            &#39;{} is not an instance of `StatObject`&#39;.format(obj.stats)
        )

class StatChangeEvent(Event): # pylint: disable=too-few-public-methods
    &#34;&#34;&#34;Created when one of a `StatObject`&#39;s attributes changes.

    Should only be created when the changing attribute is a statistic.

    Attributes:
        parent (obj): The object whose statistics have changed.
        statObj (StatObject): The stat object that has changed.
        oldStats (dict): {`str`:`int` or `float`} A dictionary mapping
            stat names (the keys of the `StatObject`&#39;s `statAbbrs`
            property) to their previous values (at the time of the last
            issuance of a `StatChangeEvent`).

    &#34;&#34;&#34;

    def __init__(self, parent, statObj, oldStats):
        self.parent = parent
        self.statObj = statObj
        self.oldStats = oldStats

class StatObject():
    &#34;&#34;&#34;An object that stores named statistics as attributes.

    The `StatObject` class is meant to be subclassed. Subclasses must
    set `statAbbrs` to an iterable that iterates over the names
    (typically abbreviations) of the statistics being stored in the
    subclass. The subclass constructor must be able to accept no
    arguments, and when it does, it should create an object, all of
    whose statistics are zero.

    Two `StatObject` instances can be added/multiplied. The result is a
    new `StatObject` instance whose statistics are the sum/product of
    the statistics of the given instances.

    Attributes:
        parent (obj): The object to which these stats belong.
        onChange (legends.utils.eventhandler.EventHandler): Sends a
            `StatChangeEvent` to subscribers when a statistic changes.
        silent (bool): Set to `True` to prevent the sending of a
            `StatChangeEvent` when a statistic changes. Defaults to
            `False`.

    &#34;&#34;&#34;

    def __init__(self, statAbbrs, parent=None, initDict=None):
        &#34;&#34;&#34;If a dictionary of stat values is provided, the constructor
        initializes the instance with these values.

        Args:
            statAbbrs (dict): {`str`:`str`} The dictionary to assign to
                the `statAbbrs` property.
            initDict (dict): {`str`:`int or float`} A dictionary mapping
                stat names to numerical values. The keys of `initDict`
                should match the keys of the `statAbbrs` property.

        &#34;&#34;&#34;
        self._statAbbrs = statAbbrs
        self.parent = parent
        self.silent = False
        self.onChange = EventHandler()
        self._oldStats = {statName: 0 for statName in self.statAbbrs}
        if initDict is None:
            initDict = self._oldStats.copy()
        self.update(initDict)

    @property
    def statAbbrs(self):
        &#34;&#34;&#34;`dict`: {`str`:`str`} A dictionary mapping the names of stats
        to be stored to the abbreviations that are to be used as
        attribute names.
        &#34;&#34;&#34;
        return self._statAbbrs

    @property
    def oldStats(self):
        &#34;&#34;&#34;`dict`: {`str`:`int or float`} A dictionary mapping stat
        names to the values they held the last time a `StatChangeEvent`
        was issued. If no `StatChangeEvent` has been issued, all values
        of this dictionary will be 0.
        &#34;&#34;&#34;
        return self._oldStats

    @property
    def asDict(self):
        &#34;&#34;&#34;`dict`: {`str`:`int or float`} A dictionary mapping stat
        names to their current values.
        &#34;&#34;&#34;
        return {statName: self.get(statName) for statName in self.statAbbrs}

    def __setattr__(self, attrName, value):
        self.__dict__[attrName] = value
        if attrName in self.statAbbrs.values() and not self.silent:
            self.notify()

    def notify(self):
        &#34;&#34;&#34;Sends a `StatChangeEvent` to the `onChange` subscribers, and
        updates the `oldStats` property.
        &#34;&#34;&#34;
        self.onChange.notify(StatChangeEvent(self.parent, self, self.oldStats))
        self._oldStats = self.asDict

    def get(self, statName):
        &#34;&#34;&#34;Looks up a stat value by its name, as it appears in the keys
        of the `statAbbrs` property.

        Args:
            statName (str): A stat name, as it appears in the keys of
                the `statAbbrs` property.

        Returns:
            int or float: The value of the given stat.

        &#34;&#34;&#34;
        return getattr(self, self.statAbbrs[statName])

    def set(self, statName, value):
        &#34;&#34;&#34;Sets a stat value by its name, as it appears in the keys of
        the `statAbbrs` property.

        Args:
            statName (str): A stat name, as it appears in the keys of
                the `statAbbrs` property.
            value (int or float): The value to assign.

        &#34;&#34;&#34;
        setattr(self, self.statAbbrs[statName], value)

    def update(self, statDict):
        &#34;&#34;&#34;Sets the stat attributes to those contained in the given stat
        dictionary. Suppresses all issuing of `StatChangeEvent`
        instances until the update is completed, then issues a single
        event to cover the entire update.

        Args:
            statDict (dict): {`str`:`int or float`} A dictionary mapping
                stat names to numerical values. The keys of `statDict`
                should match the keys of the `statAbbrs` attribute.

        &#34;&#34;&#34;
        initSilent = self.silent
        self.silent = True
        for statName, statVal in statDict.items():
            setattr(self, self.statAbbrs[statName], statVal)
        self.silent = initSilent
        if not self.silent:
            self.notify()

    def __add__(self, other):
        result = self.__class__(self.statAbbrs)
        for statAbbr in self.statAbbrs.values():
            statSum = getattr(self, statAbbr) + getattr(other, statAbbr)
            setattr(result, statAbbr, statSum)
        return result

    def __mul__(self, other):
        result = self.__class__(self.statAbbrs)
        for statAbbr in self.statAbbrs.values():
            statProd = getattr(self, statAbbr) * getattr(other, statAbbr)
            setattr(result, statAbbr, statProd)
        return result

    def __repr__(self):
        return &#39;StatObject({})&#39;.format(formatDict({
            statAbbr: getattr(self, statAbbr)
            for statAbbr in self.statAbbrs.values()
        }))

class Stats(StatObject):
    &#34;&#34;&#34;Stores the basic stats in STL.

    A subclass of `StatObject` whose `statAbbrs` property is set to
    `STAT_ABBREVIATIONS`.

    &#34;&#34;&#34;

    def __init__(self, parent=None, initDict=None):
        &#34;&#34;&#34;The constructor passes the arguments to the `StatObject`
        constructor, along with a copy of the `STAT_ABBREVIATIONS`
        dictionary.

        &#34;&#34;&#34;
        StatObject.__init__(self, STAT_ABBREVIATIONS.copy(), parent, initDict)

    @property
    def power(self):
        &#34;&#34;&#34;The additional power that would be added to a character if
        its stats increased by the amounts given in the calling
        instance.
        &#34;&#34;&#34;
        powerDelta = 0
        for statName in STAT_ABBREVIATIONS:
            statVal = self.get(statName)
            powerDelta += POWER_GRADIENT[statName] * statVal
        return powerDelta

class StatMods():
    &#34;&#34;&#34;A collection of stat modifiers.

    Attributes:
        mult (Stats): Multiplicative modifiers. Defaults to all 1&#39;s.
        preAdd (Stats): Additive modifiers, applied before the
            multiplicative modifiers. Defaults to all 0&#39;s.
        postAdd (Stats): Additive modifiers, applied after the
            multiplicative modifiers. Defaults to all 0&#39;s.
        onChange (legends.utils.eventhandler.EventHandler): When any of
            `mult`, `preAdd`, or `postAdd` changes, this event handler
            passes on the `StatChangeEvent` to its subscribers.

    &#34;&#34;&#34;

    def __init__(self):
        self.mult = Stats({statName: 1 for statName in STAT_ABBREVIATIONS})
        self.preAdd = Stats()
        self.postAdd = Stats()
        self.onChange = EventHandler()
        self.mult.onChange.subscribe(self.onChange.notify)
        self.preAdd.onChange.subscribe(self.onChange.notify)
        self.postAdd.onChange.subscribe(self.onChange.notify)

    def apply(self, stats):
        &#34;&#34;&#34;Creates and returns a new `Stats` object by applying the
        modifiers to the given `Stats` object.

        Args:
            stats (`Stats`): The stats to which the modifiers should be
                applied.

        &#34;&#34;&#34;
        return (stats + self.preAdd) * self.mult + self.postAdd

    def __repr__(self):
        return &#39;{}({})&#39;.format(
            self.__class__.__name__, formatDict(objDict(self))
        )

class PartEffects(StatObject):
    &#34;&#34;&#34;Stats describing effects of particles in STL.

    A subclass of `StatObject` whose `statAbbrs` property is set to
    `PART_EFFECTS`.

    &#34;&#34;&#34;

    def __init__(self, parent=None, initDict=None):
        &#34;&#34;&#34;The constructor passes the arguments to the `StatObject`
        constructor, along with a copy of the `PART_EFFECTS` dictionary.

        &#34;&#34;&#34;
        StatObject.__init__(self, PART_EFFECTS.copy(), parent, initDict)

class ThreatStats(StatObject):
    &#34;&#34;&#34;Stats describing the threat posed by enemies in battle.

    A subclass of `StatObject` whose `statAbbrs` property is set to
    `THREAT_STATS`.

    &#34;&#34;&#34;

    def __init__(self, parent=None, initDict=None):
        &#34;&#34;&#34;The constructor passes the arguments to the `StatObject`
        constructor, along with a copy of the `THREAT_STATS` dictionary.

        &#34;&#34;&#34;
        StatObject.__init__(self, THREAT_STATS.copy(), parent, initDict)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="legends.stats.checkForStats"><code class="name flex">
<span>def <span class="ident">checkForStats</span></span>(<span>obj)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if the given objects has a 'stats' attribute that points
to a <code><a title="legends.stats.StatObject" href="#legends.stats.StatObject">StatObject</a></code> instance.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>obj</code></strong> :&ensp;<code>obj</code></dt>
<dd>The object to check.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the object fails the check.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def checkForStats(obj):
    &#34;&#34;&#34;Checks if the given objects has a &#39;stats&#39; attribute that points
    to a `StatObject` instance.

    Args:
        obj (obj): The object to check.

    Raises:
        ValueError: If the object fails the check.

    &#34;&#34;&#34;
    if not hasattr(obj, &#39;stats&#39;):
        raise ValueError(&#39;{} has no `stats` attribute&#39;.format(obj))
    if not isinstance(obj.stats, StatObject):
        raise ValueError(
            &#39;{} is not an instance of `StatObject`&#39;.format(obj.stats)
        )</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="legends.stats.PartEffects"><code class="flex name class">
<span>class <span class="ident">PartEffects</span></span>
<span>(</span><span>parent=None, initDict=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Stats describing effects of particles in STL.</p>
<p>A subclass of <code><a title="legends.stats.StatObject" href="#legends.stats.StatObject">StatObject</a></code> whose <code>statAbbrs</code> property is set to
<code>PART_EFFECTS</code>.</p>
<p>The constructor passes the arguments to the <code><a title="legends.stats.StatObject" href="#legends.stats.StatObject">StatObject</a></code>
constructor, along with a copy of the <code>PART_EFFECTS</code> dictionary.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PartEffects(StatObject):
    &#34;&#34;&#34;Stats describing effects of particles in STL.

    A subclass of `StatObject` whose `statAbbrs` property is set to
    `PART_EFFECTS`.

    &#34;&#34;&#34;

    def __init__(self, parent=None, initDict=None):
        &#34;&#34;&#34;The constructor passes the arguments to the `StatObject`
        constructor, along with a copy of the `PART_EFFECTS` dictionary.

        &#34;&#34;&#34;
        StatObject.__init__(self, PART_EFFECTS.copy(), parent, initDict)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="legends.stats.StatObject" href="#legends.stats.StatObject">StatObject</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="legends.stats.StatObject" href="#legends.stats.StatObject">StatObject</a></b></code>:
<ul class="hlist">
<li><code><a title="legends.stats.StatObject.asDict" href="#legends.stats.StatObject.asDict">asDict</a></code></li>
<li><code><a title="legends.stats.StatObject.get" href="#legends.stats.StatObject.get">get</a></code></li>
<li><code><a title="legends.stats.StatObject.notify" href="#legends.stats.StatObject.notify">notify</a></code></li>
<li><code><a title="legends.stats.StatObject.oldStats" href="#legends.stats.StatObject.oldStats">oldStats</a></code></li>
<li><code><a title="legends.stats.StatObject.set" href="#legends.stats.StatObject.set">set</a></code></li>
<li><code><a title="legends.stats.StatObject.statAbbrs" href="#legends.stats.StatObject.statAbbrs">statAbbrs</a></code></li>
<li><code><a title="legends.stats.StatObject.update" href="#legends.stats.StatObject.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="legends.stats.StatChangeEvent"><code class="flex name class">
<span>class <span class="ident">StatChangeEvent</span></span>
<span>(</span><span>parent, statObj, oldStats)</span>
</code></dt>
<dd>
<div class="desc"><p>Created when one of a <code><a title="legends.stats.StatObject" href="#legends.stats.StatObject">StatObject</a></code>'s attributes changes.</p>
<p>Should only be created when the changing attribute is a statistic.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>parent</code></strong> :&ensp;<code>obj</code></dt>
<dd>The object whose statistics have changed.</dd>
<dt><strong><code>statObj</code></strong> :&ensp;<code><a title="legends.stats.StatObject" href="#legends.stats.StatObject">StatObject</a></code></dt>
<dd>The stat object that has changed.</dd>
<dt><strong><code>oldStats</code></strong> :&ensp;<code>dict</code></dt>
<dd>{<code>str</code>:<code>int</code> or <code>float</code>} A dictionary mapping
stat names (the keys of the <code><a title="legends.stats.StatObject" href="#legends.stats.StatObject">StatObject</a></code>'s <code>statAbbrs</code>
property) to their previous values (at the time of the last
issuance of a <code><a title="legends.stats.StatChangeEvent" href="#legends.stats.StatChangeEvent">StatChangeEvent</a></code>).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StatChangeEvent(Event): # pylint: disable=too-few-public-methods
    &#34;&#34;&#34;Created when one of a `StatObject`&#39;s attributes changes.

    Should only be created when the changing attribute is a statistic.

    Attributes:
        parent (obj): The object whose statistics have changed.
        statObj (StatObject): The stat object that has changed.
        oldStats (dict): {`str`:`int` or `float`} A dictionary mapping
            stat names (the keys of the `StatObject`&#39;s `statAbbrs`
            property) to their previous values (at the time of the last
            issuance of a `StatChangeEvent`).

    &#34;&#34;&#34;

    def __init__(self, parent, statObj, oldStats):
        self.parent = parent
        self.statObj = statObj
        self.oldStats = oldStats</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="legends.utils.eventhandler.Event" href="utils/eventhandler.html#legends.utils.eventhandler.Event">Event</a></li>
</ul>
</dd>
<dt id="legends.stats.StatMods"><code class="flex name class">
<span>class <span class="ident">StatMods</span></span>
</code></dt>
<dd>
<div class="desc"><p>A collection of stat modifiers.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>mult</code></strong> :&ensp;<code><a title="legends.stats.Stats" href="#legends.stats.Stats">Stats</a></code></dt>
<dd>Multiplicative modifiers. Defaults to all 1's.</dd>
<dt><strong><code>preAdd</code></strong> :&ensp;<code><a title="legends.stats.Stats" href="#legends.stats.Stats">Stats</a></code></dt>
<dd>Additive modifiers, applied before the
multiplicative modifiers. Defaults to all 0's.</dd>
<dt><strong><code>postAdd</code></strong> :&ensp;<code><a title="legends.stats.Stats" href="#legends.stats.Stats">Stats</a></code></dt>
<dd>Additive modifiers, applied after the
multiplicative modifiers. Defaults to all 0's.</dd>
<dt><strong><code>onChange</code></strong> :&ensp;<code><a title="legends.utils.eventhandler.EventHandler" href="utils/eventhandler.html#legends.utils.eventhandler.EventHandler">EventHandler</a></code></dt>
<dd>When any of
<code>mult</code>, <code>preAdd</code>, or <code>postAdd</code> changes, this event handler
passes on the <code><a title="legends.stats.StatChangeEvent" href="#legends.stats.StatChangeEvent">StatChangeEvent</a></code> to its subscribers.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StatMods():
    &#34;&#34;&#34;A collection of stat modifiers.

    Attributes:
        mult (Stats): Multiplicative modifiers. Defaults to all 1&#39;s.
        preAdd (Stats): Additive modifiers, applied before the
            multiplicative modifiers. Defaults to all 0&#39;s.
        postAdd (Stats): Additive modifiers, applied after the
            multiplicative modifiers. Defaults to all 0&#39;s.
        onChange (legends.utils.eventhandler.EventHandler): When any of
            `mult`, `preAdd`, or `postAdd` changes, this event handler
            passes on the `StatChangeEvent` to its subscribers.

    &#34;&#34;&#34;

    def __init__(self):
        self.mult = Stats({statName: 1 for statName in STAT_ABBREVIATIONS})
        self.preAdd = Stats()
        self.postAdd = Stats()
        self.onChange = EventHandler()
        self.mult.onChange.subscribe(self.onChange.notify)
        self.preAdd.onChange.subscribe(self.onChange.notify)
        self.postAdd.onChange.subscribe(self.onChange.notify)

    def apply(self, stats):
        &#34;&#34;&#34;Creates and returns a new `Stats` object by applying the
        modifiers to the given `Stats` object.

        Args:
            stats (`Stats`): The stats to which the modifiers should be
                applied.

        &#34;&#34;&#34;
        return (stats + self.preAdd) * self.mult + self.postAdd

    def __repr__(self):
        return &#39;{}({})&#39;.format(
            self.__class__.__name__, formatDict(objDict(self))
        )</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="legends.stats.StatMods.apply"><code class="name flex">
<span>def <span class="ident">apply</span></span>(<span>self, stats)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and returns a new <code><a title="legends.stats.Stats" href="#legends.stats.Stats">Stats</a></code> object by applying the
modifiers to the given <code><a title="legends.stats.Stats" href="#legends.stats.Stats">Stats</a></code> object.</p>
<h2 id="args">Args</h2>
<p>stats (<code><a title="legends.stats.Stats" href="#legends.stats.Stats">Stats</a></code>): The stats to which the modifiers should be
applied.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply(self, stats):
    &#34;&#34;&#34;Creates and returns a new `Stats` object by applying the
    modifiers to the given `Stats` object.

    Args:
        stats (`Stats`): The stats to which the modifiers should be
            applied.

    &#34;&#34;&#34;
    return (stats + self.preAdd) * self.mult + self.postAdd</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="legends.stats.StatObject"><code class="flex name class">
<span>class <span class="ident">StatObject</span></span>
<span>(</span><span>statAbbrs, parent=None, initDict=None)</span>
</code></dt>
<dd>
<div class="desc"><p>An object that stores named statistics as attributes.</p>
<p>The <code><a title="legends.stats.StatObject" href="#legends.stats.StatObject">StatObject</a></code> class is meant to be subclassed. Subclasses must
set <code>statAbbrs</code> to an iterable that iterates over the names
(typically abbreviations) of the statistics being stored in the
subclass. The subclass constructor must be able to accept no
arguments, and when it does, it should create an object, all of
whose statistics are zero.</p>
<p>Two <code><a title="legends.stats.StatObject" href="#legends.stats.StatObject">StatObject</a></code> instances can be added/multiplied. The result is a
new <code><a title="legends.stats.StatObject" href="#legends.stats.StatObject">StatObject</a></code> instance whose statistics are the sum/product of
the statistics of the given instances.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>parent</code></strong> :&ensp;<code>obj</code></dt>
<dd>The object to which these stats belong.</dd>
<dt><strong><code>onChange</code></strong> :&ensp;<code><a title="legends.utils.eventhandler.EventHandler" href="utils/eventhandler.html#legends.utils.eventhandler.EventHandler">EventHandler</a></code></dt>
<dd>Sends a
<code><a title="legends.stats.StatChangeEvent" href="#legends.stats.StatChangeEvent">StatChangeEvent</a></code> to subscribers when a statistic changes.</dd>
<dt><strong><code>silent</code></strong> :&ensp;<code>bool</code></dt>
<dd>Set to <code>True</code> to prevent the sending of a
<code><a title="legends.stats.StatChangeEvent" href="#legends.stats.StatChangeEvent">StatChangeEvent</a></code> when a statistic changes. Defaults to
<code>False</code>.</dd>
</dl>
<p>If a dictionary of stat values is provided, the constructor
initializes the instance with these values.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>statAbbrs</code></strong> :&ensp;<code>dict</code></dt>
<dd>{<code>str</code>:<code>str</code>} The dictionary to assign to
the <code>statAbbrs</code> property.</dd>
<dt><strong><code>initDict</code></strong> :&ensp;<code>dict</code></dt>
<dd>{<code>str</code>:<code>int or float</code>} A dictionary mapping
stat names to numerical values. The keys of <code>initDict</code>
should match the keys of the <code>statAbbrs</code> property.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StatObject():
    &#34;&#34;&#34;An object that stores named statistics as attributes.

    The `StatObject` class is meant to be subclassed. Subclasses must
    set `statAbbrs` to an iterable that iterates over the names
    (typically abbreviations) of the statistics being stored in the
    subclass. The subclass constructor must be able to accept no
    arguments, and when it does, it should create an object, all of
    whose statistics are zero.

    Two `StatObject` instances can be added/multiplied. The result is a
    new `StatObject` instance whose statistics are the sum/product of
    the statistics of the given instances.

    Attributes:
        parent (obj): The object to which these stats belong.
        onChange (legends.utils.eventhandler.EventHandler): Sends a
            `StatChangeEvent` to subscribers when a statistic changes.
        silent (bool): Set to `True` to prevent the sending of a
            `StatChangeEvent` when a statistic changes. Defaults to
            `False`.

    &#34;&#34;&#34;

    def __init__(self, statAbbrs, parent=None, initDict=None):
        &#34;&#34;&#34;If a dictionary of stat values is provided, the constructor
        initializes the instance with these values.

        Args:
            statAbbrs (dict): {`str`:`str`} The dictionary to assign to
                the `statAbbrs` property.
            initDict (dict): {`str`:`int or float`} A dictionary mapping
                stat names to numerical values. The keys of `initDict`
                should match the keys of the `statAbbrs` property.

        &#34;&#34;&#34;
        self._statAbbrs = statAbbrs
        self.parent = parent
        self.silent = False
        self.onChange = EventHandler()
        self._oldStats = {statName: 0 for statName in self.statAbbrs}
        if initDict is None:
            initDict = self._oldStats.copy()
        self.update(initDict)

    @property
    def statAbbrs(self):
        &#34;&#34;&#34;`dict`: {`str`:`str`} A dictionary mapping the names of stats
        to be stored to the abbreviations that are to be used as
        attribute names.
        &#34;&#34;&#34;
        return self._statAbbrs

    @property
    def oldStats(self):
        &#34;&#34;&#34;`dict`: {`str`:`int or float`} A dictionary mapping stat
        names to the values they held the last time a `StatChangeEvent`
        was issued. If no `StatChangeEvent` has been issued, all values
        of this dictionary will be 0.
        &#34;&#34;&#34;
        return self._oldStats

    @property
    def asDict(self):
        &#34;&#34;&#34;`dict`: {`str`:`int or float`} A dictionary mapping stat
        names to their current values.
        &#34;&#34;&#34;
        return {statName: self.get(statName) for statName in self.statAbbrs}

    def __setattr__(self, attrName, value):
        self.__dict__[attrName] = value
        if attrName in self.statAbbrs.values() and not self.silent:
            self.notify()

    def notify(self):
        &#34;&#34;&#34;Sends a `StatChangeEvent` to the `onChange` subscribers, and
        updates the `oldStats` property.
        &#34;&#34;&#34;
        self.onChange.notify(StatChangeEvent(self.parent, self, self.oldStats))
        self._oldStats = self.asDict

    def get(self, statName):
        &#34;&#34;&#34;Looks up a stat value by its name, as it appears in the keys
        of the `statAbbrs` property.

        Args:
            statName (str): A stat name, as it appears in the keys of
                the `statAbbrs` property.

        Returns:
            int or float: The value of the given stat.

        &#34;&#34;&#34;
        return getattr(self, self.statAbbrs[statName])

    def set(self, statName, value):
        &#34;&#34;&#34;Sets a stat value by its name, as it appears in the keys of
        the `statAbbrs` property.

        Args:
            statName (str): A stat name, as it appears in the keys of
                the `statAbbrs` property.
            value (int or float): The value to assign.

        &#34;&#34;&#34;
        setattr(self, self.statAbbrs[statName], value)

    def update(self, statDict):
        &#34;&#34;&#34;Sets the stat attributes to those contained in the given stat
        dictionary. Suppresses all issuing of `StatChangeEvent`
        instances until the update is completed, then issues a single
        event to cover the entire update.

        Args:
            statDict (dict): {`str`:`int or float`} A dictionary mapping
                stat names to numerical values. The keys of `statDict`
                should match the keys of the `statAbbrs` attribute.

        &#34;&#34;&#34;
        initSilent = self.silent
        self.silent = True
        for statName, statVal in statDict.items():
            setattr(self, self.statAbbrs[statName], statVal)
        self.silent = initSilent
        if not self.silent:
            self.notify()

    def __add__(self, other):
        result = self.__class__(self.statAbbrs)
        for statAbbr in self.statAbbrs.values():
            statSum = getattr(self, statAbbr) + getattr(other, statAbbr)
            setattr(result, statAbbr, statSum)
        return result

    def __mul__(self, other):
        result = self.__class__(self.statAbbrs)
        for statAbbr in self.statAbbrs.values():
            statProd = getattr(self, statAbbr) * getattr(other, statAbbr)
            setattr(result, statAbbr, statProd)
        return result

    def __repr__(self):
        return &#39;StatObject({})&#39;.format(formatDict({
            statAbbr: getattr(self, statAbbr)
            for statAbbr in self.statAbbrs.values()
        }))</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="legends.stats.PartEffects" href="#legends.stats.PartEffects">PartEffects</a></li>
<li><a title="legends.stats.Stats" href="#legends.stats.Stats">Stats</a></li>
<li><a title="legends.stats.ThreatStats" href="#legends.stats.ThreatStats">ThreatStats</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="legends.stats.StatObject.asDict"><code class="name">var <span class="ident">asDict</span></code></dt>
<dd>
<div class="desc"><p><code>dict</code>: {<code>str</code>:<code>int or float</code>} A dictionary mapping stat
names to their current values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def asDict(self):
    &#34;&#34;&#34;`dict`: {`str`:`int or float`} A dictionary mapping stat
    names to their current values.
    &#34;&#34;&#34;
    return {statName: self.get(statName) for statName in self.statAbbrs}</code></pre>
</details>
</dd>
<dt id="legends.stats.StatObject.oldStats"><code class="name">var <span class="ident">oldStats</span></code></dt>
<dd>
<div class="desc"><p><code>dict</code>: {<code>str</code>:<code>int or float</code>} A dictionary mapping stat
names to the values they held the last time a <code><a title="legends.stats.StatChangeEvent" href="#legends.stats.StatChangeEvent">StatChangeEvent</a></code>
was issued. If no <code><a title="legends.stats.StatChangeEvent" href="#legends.stats.StatChangeEvent">StatChangeEvent</a></code> has been issued, all values
of this dictionary will be 0.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def oldStats(self):
    &#34;&#34;&#34;`dict`: {`str`:`int or float`} A dictionary mapping stat
    names to the values they held the last time a `StatChangeEvent`
    was issued. If no `StatChangeEvent` has been issued, all values
    of this dictionary will be 0.
    &#34;&#34;&#34;
    return self._oldStats</code></pre>
</details>
</dd>
<dt id="legends.stats.StatObject.statAbbrs"><code class="name">var <span class="ident">statAbbrs</span></code></dt>
<dd>
<div class="desc"><p><code>dict</code>: {<code>str</code>:<code>str</code>} A dictionary mapping the names of stats
to be stored to the abbreviations that are to be used as
attribute names.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def statAbbrs(self):
    &#34;&#34;&#34;`dict`: {`str`:`str`} A dictionary mapping the names of stats
    to be stored to the abbreviations that are to be used as
    attribute names.
    &#34;&#34;&#34;
    return self._statAbbrs</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="legends.stats.StatObject.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, statName)</span>
</code></dt>
<dd>
<div class="desc"><p>Looks up a stat value by its name, as it appears in the keys
of the <code>statAbbrs</code> property.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>statName</code></strong> :&ensp;<code>str</code></dt>
<dd>A stat name, as it appears in the keys of
the <code>statAbbrs</code> property.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code> or <code>float</code></dt>
<dd>The value of the given stat.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, statName):
    &#34;&#34;&#34;Looks up a stat value by its name, as it appears in the keys
    of the `statAbbrs` property.

    Args:
        statName (str): A stat name, as it appears in the keys of
            the `statAbbrs` property.

    Returns:
        int or float: The value of the given stat.

    &#34;&#34;&#34;
    return getattr(self, self.statAbbrs[statName])</code></pre>
</details>
</dd>
<dt id="legends.stats.StatObject.notify"><code class="name flex">
<span>def <span class="ident">notify</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Sends a <code><a title="legends.stats.StatChangeEvent" href="#legends.stats.StatChangeEvent">StatChangeEvent</a></code> to the <code>onChange</code> subscribers, and
updates the <code>oldStats</code> property.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def notify(self):
    &#34;&#34;&#34;Sends a `StatChangeEvent` to the `onChange` subscribers, and
    updates the `oldStats` property.
    &#34;&#34;&#34;
    self.onChange.notify(StatChangeEvent(self.parent, self, self.oldStats))
    self._oldStats = self.asDict</code></pre>
</details>
</dd>
<dt id="legends.stats.StatObject.set"><code class="name flex">
<span>def <span class="ident">set</span></span>(<span>self, statName, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets a stat value by its name, as it appears in the keys of
the <code>statAbbrs</code> property.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>statName</code></strong> :&ensp;<code>str</code></dt>
<dd>A stat name, as it appears in the keys of
the <code>statAbbrs</code> property.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>int</code> or <code>float</code></dt>
<dd>The value to assign.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set(self, statName, value):
    &#34;&#34;&#34;Sets a stat value by its name, as it appears in the keys of
    the `statAbbrs` property.

    Args:
        statName (str): A stat name, as it appears in the keys of
            the `statAbbrs` property.
        value (int or float): The value to assign.

    &#34;&#34;&#34;
    setattr(self, self.statAbbrs[statName], value)</code></pre>
</details>
</dd>
<dt id="legends.stats.StatObject.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, statDict)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the stat attributes to those contained in the given stat
dictionary. Suppresses all issuing of <code><a title="legends.stats.StatChangeEvent" href="#legends.stats.StatChangeEvent">StatChangeEvent</a></code>
instances until the update is completed, then issues a single
event to cover the entire update.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>statDict</code></strong> :&ensp;<code>dict</code></dt>
<dd>{<code>str</code>:<code>int or float</code>} A dictionary mapping
stat names to numerical values. The keys of <code>statDict</code>
should match the keys of the <code>statAbbrs</code> attribute.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, statDict):
    &#34;&#34;&#34;Sets the stat attributes to those contained in the given stat
    dictionary. Suppresses all issuing of `StatChangeEvent`
    instances until the update is completed, then issues a single
    event to cover the entire update.

    Args:
        statDict (dict): {`str`:`int or float`} A dictionary mapping
            stat names to numerical values. The keys of `statDict`
            should match the keys of the `statAbbrs` attribute.

    &#34;&#34;&#34;
    initSilent = self.silent
    self.silent = True
    for statName, statVal in statDict.items():
        setattr(self, self.statAbbrs[statName], statVal)
    self.silent = initSilent
    if not self.silent:
        self.notify()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="legends.stats.Stats"><code class="flex name class">
<span>class <span class="ident">Stats</span></span>
<span>(</span><span>parent=None, initDict=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Stores the basic stats in STL.</p>
<p>A subclass of <code><a title="legends.stats.StatObject" href="#legends.stats.StatObject">StatObject</a></code> whose <code>statAbbrs</code> property is set to
<code>STAT_ABBREVIATIONS</code>.</p>
<p>The constructor passes the arguments to the <code><a title="legends.stats.StatObject" href="#legends.stats.StatObject">StatObject</a></code>
constructor, along with a copy of the <code>STAT_ABBREVIATIONS</code>
dictionary.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Stats(StatObject):
    &#34;&#34;&#34;Stores the basic stats in STL.

    A subclass of `StatObject` whose `statAbbrs` property is set to
    `STAT_ABBREVIATIONS`.

    &#34;&#34;&#34;

    def __init__(self, parent=None, initDict=None):
        &#34;&#34;&#34;The constructor passes the arguments to the `StatObject`
        constructor, along with a copy of the `STAT_ABBREVIATIONS`
        dictionary.

        &#34;&#34;&#34;
        StatObject.__init__(self, STAT_ABBREVIATIONS.copy(), parent, initDict)

    @property
    def power(self):
        &#34;&#34;&#34;The additional power that would be added to a character if
        its stats increased by the amounts given in the calling
        instance.
        &#34;&#34;&#34;
        powerDelta = 0
        for statName in STAT_ABBREVIATIONS:
            statVal = self.get(statName)
            powerDelta += POWER_GRADIENT[statName] * statVal
        return powerDelta</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="legends.stats.StatObject" href="#legends.stats.StatObject">StatObject</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="legends.stats.Stats.power"><code class="name">var <span class="ident">power</span></code></dt>
<dd>
<div class="desc"><p>The additional power that would be added to a character if
its stats increased by the amounts given in the calling
instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def power(self):
    &#34;&#34;&#34;The additional power that would be added to a character if
    its stats increased by the amounts given in the calling
    instance.
    &#34;&#34;&#34;
    powerDelta = 0
    for statName in STAT_ABBREVIATIONS:
        statVal = self.get(statName)
        powerDelta += POWER_GRADIENT[statName] * statVal
    return powerDelta</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="legends.stats.StatObject" href="#legends.stats.StatObject">StatObject</a></b></code>:
<ul class="hlist">
<li><code><a title="legends.stats.StatObject.asDict" href="#legends.stats.StatObject.asDict">asDict</a></code></li>
<li><code><a title="legends.stats.StatObject.get" href="#legends.stats.StatObject.get">get</a></code></li>
<li><code><a title="legends.stats.StatObject.notify" href="#legends.stats.StatObject.notify">notify</a></code></li>
<li><code><a title="legends.stats.StatObject.oldStats" href="#legends.stats.StatObject.oldStats">oldStats</a></code></li>
<li><code><a title="legends.stats.StatObject.set" href="#legends.stats.StatObject.set">set</a></code></li>
<li><code><a title="legends.stats.StatObject.statAbbrs" href="#legends.stats.StatObject.statAbbrs">statAbbrs</a></code></li>
<li><code><a title="legends.stats.StatObject.update" href="#legends.stats.StatObject.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="legends.stats.ThreatStats"><code class="flex name class">
<span>class <span class="ident">ThreatStats</span></span>
<span>(</span><span>parent=None, initDict=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Stats describing the threat posed by enemies in battle.</p>
<p>A subclass of <code><a title="legends.stats.StatObject" href="#legends.stats.StatObject">StatObject</a></code> whose <code>statAbbrs</code> property is set to
<code>THREAT_STATS</code>.</p>
<p>The constructor passes the arguments to the <code><a title="legends.stats.StatObject" href="#legends.stats.StatObject">StatObject</a></code>
constructor, along with a copy of the <code>THREAT_STATS</code> dictionary.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ThreatStats(StatObject):
    &#34;&#34;&#34;Stats describing the threat posed by enemies in battle.

    A subclass of `StatObject` whose `statAbbrs` property is set to
    `THREAT_STATS`.

    &#34;&#34;&#34;

    def __init__(self, parent=None, initDict=None):
        &#34;&#34;&#34;The constructor passes the arguments to the `StatObject`
        constructor, along with a copy of the `THREAT_STATS` dictionary.

        &#34;&#34;&#34;
        StatObject.__init__(self, THREAT_STATS.copy(), parent, initDict)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="legends.stats.StatObject" href="#legends.stats.StatObject">StatObject</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="legends.stats.StatObject" href="#legends.stats.StatObject">StatObject</a></b></code>:
<ul class="hlist">
<li><code><a title="legends.stats.StatObject.asDict" href="#legends.stats.StatObject.asDict">asDict</a></code></li>
<li><code><a title="legends.stats.StatObject.get" href="#legends.stats.StatObject.get">get</a></code></li>
<li><code><a title="legends.stats.StatObject.notify" href="#legends.stats.StatObject.notify">notify</a></code></li>
<li><code><a title="legends.stats.StatObject.oldStats" href="#legends.stats.StatObject.oldStats">oldStats</a></code></li>
<li><code><a title="legends.stats.StatObject.set" href="#legends.stats.StatObject.set">set</a></code></li>
<li><code><a title="legends.stats.StatObject.statAbbrs" href="#legends.stats.StatObject.statAbbrs">statAbbrs</a></code></li>
<li><code><a title="legends.stats.StatObject.update" href="#legends.stats.StatObject.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="legends" href="index.html">legends</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="legends.stats.checkForStats" href="#legends.stats.checkForStats">checkForStats</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="legends.stats.PartEffects" href="#legends.stats.PartEffects">PartEffects</a></code></h4>
</li>
<li>
<h4><code><a title="legends.stats.StatChangeEvent" href="#legends.stats.StatChangeEvent">StatChangeEvent</a></code></h4>
</li>
<li>
<h4><code><a title="legends.stats.StatMods" href="#legends.stats.StatMods">StatMods</a></code></h4>
<ul class="">
<li><code><a title="legends.stats.StatMods.apply" href="#legends.stats.StatMods.apply">apply</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="legends.stats.StatObject" href="#legends.stats.StatObject">StatObject</a></code></h4>
<ul class="two-column">
<li><code><a title="legends.stats.StatObject.asDict" href="#legends.stats.StatObject.asDict">asDict</a></code></li>
<li><code><a title="legends.stats.StatObject.get" href="#legends.stats.StatObject.get">get</a></code></li>
<li><code><a title="legends.stats.StatObject.notify" href="#legends.stats.StatObject.notify">notify</a></code></li>
<li><code><a title="legends.stats.StatObject.oldStats" href="#legends.stats.StatObject.oldStats">oldStats</a></code></li>
<li><code><a title="legends.stats.StatObject.set" href="#legends.stats.StatObject.set">set</a></code></li>
<li><code><a title="legends.stats.StatObject.statAbbrs" href="#legends.stats.StatObject.statAbbrs">statAbbrs</a></code></li>
<li><code><a title="legends.stats.StatObject.update" href="#legends.stats.StatObject.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="legends.stats.Stats" href="#legends.stats.Stats">Stats</a></code></h4>
<ul class="">
<li><code><a title="legends.stats.Stats.power" href="#legends.stats.Stats.power">power</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="legends.stats.ThreatStats" href="#legends.stats.ThreatStats">ThreatStats</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>