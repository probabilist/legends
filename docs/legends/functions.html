<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>legends.functions API documentation</title>
<meta name="description" content="Functions use in the `legends` package." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>legends.functions</code></h1>
</header>
<section id="section-intro">
<p>Functions use in the <code><a title="legends" href="index.html">legends</a></code> package.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Functions use in the `legends` package.

&#34;&#34;&#34;

from base64 import b64decode
from zlib import decompress
from json import loads
from getpass import getuser
from plistlib import load
from legends.utils.functions import AESdecrypt
#pylint: disable-next=no-name-in-module
from legends.constants import (
    GSBaseStat, GSCharacter, GSGear, GSGearLevel, GSLevel, GSRank,
    GSSkillUpgrade
)
from legends.constants import Inventory, ITEMS, PART_STAT_VALUES, RARITIES

__all__ = [
    &#39;charGearToMaxCost&#39;,
    &#39;cleanTime&#39;,
    &#39;decompressData&#39;,
    &#39;decryptSaveFile&#39;,
    &#39;gearToMaxCost&#39;,
    &#39;gearUpgradeCost&#39;,
    &#39;getBasicGearID&#39;,
    &#39;getCharStats&#39;,
    &#39;getGearStats&#39;,
    &#39;getPartStats&#39;,
    &#39;levelFromXP&#39;,
    &#39;saveFilePath&#39;,
    &#39;skillToMaxCost&#39;,
    &#39;skillUpgradeCost&#39;,
    &#39;tokensNeeded&#39;,
    &#39;xpFromLevel&#39;
]

def charGearToMaxCost(rarity, role=&#39;Command&#39;):
    &#34;&#34;&#34;Computes and returns the cost of leveling all gear on a character
    of the given rarity and role from level 1 to the maximum possible
    level for that character.

    Args:
        rarity (str): The rarity of the character.
        role (str): The role of the character.

    Returns:
        legends.constants.Inventory: The items needed to upgrade are
            stored and returned in an `legends.constants.Inventory`
            instance.

    &#34;&#34;&#34;
    maxGearLevel = 5 + 5 * RARITIES.index(rarity)
    cost = Inventory()
    for gearID, data in GSGear.items():
        if data[&#39;m_Role&#39;] != role:
            continue
        cost += gearToMaxCost(gearID, 1, maxGearLevel)
    return cost

def cleanTime(delta):
    &#34;&#34;&#34;Converts a `timedelta` object into a string description that
    shows the number of days (if positive), hours, and minutes.

    Args:
        delta (timedelta): The `timedelta` object to convert.

    Returns:
        str: The string description.

    &#34;&#34;&#34;
    minutes = int(delta.total_seconds()/60)
    hours, minutes = minutes//60, minutes % 60
    days, hours = hours//24, hours % 24
    display = &#39;{} days &#39;.format(days) if days &gt; 1 else &#39;&#39;
    display += &#39;{} hrs {} min&#39;.format(hours, minutes)
    return display

def decompressData(text):
    &#34;&#34;&#34;STL data is sometimes compressed in the following manner,
    converting a dictionary-like data object into a text string. First,
    it is serialized to a json string. Then, it is compressed with zlib
    deflate to binary data. Finally, it is encoded to base-64 to make
    the binary data text friendly.

    This function does the reverse. It takes a text string, which is a
    base-64 encoding of binary data, and converts it back to binary. It
    then decompresses it, then encodes the resulting decompressed binary
    data to plain text (typically a json string).

    This kind of compression can be found in support emails in STL.
    Also, since STL v1.0.13, it is sometimes used in the save file to
    compress slot data before encrypting (in which case, the slot data
    must first be decrypted, then decompressed).

    NOTE: Since STL v1.0.13, the data in support emails may be
    compressed twice. First, it is compressed in the manner described
    above. The resulting compressed string may then prepended with
    &#34;compr-&#34; and compressed once more.

    Args:
        text (str): The text data to be decompressed.

    Returns:
        str: The decompressed data, typically a json string.

    &#34;&#34;&#34;
    b64data = text.encode(&#39;utf-16&#39;)
    compressedData = b64decode(b64data)
    data = decompress(compressedData, -15)
    return data.decode(&#39;ascii&#39;)

def decryptSaveFile():
    &#34;&#34;&#34;Finds the STL save file on the local hard drive, then decrypts
    and parses it into a dictionary.

    Returns:
        dict: The decrypted save file as a dictionary.

    &#34;&#34;&#34;
    with open(saveFilePath(), &#39;rb&#39;) as f:
        saveFile = load(f)
    saveFile.pop(&#39;CloudKitAccountInfoCache&#39;, None)
    for i in range(3):
        key = str(i) + &#39; data&#39;
        if len(saveFile.get(key, &#39;&#39;)) == 0:
            saveFile[key] = {}
            continue
        slotData = AESdecrypt(
            saveFile[key],
            &#39;K1FjcmVkc2Vhc29u&#39;,
            &#39;LH75Qxpyf0prVvImu4gqxg==&#39;
        )
        if slotData[:6] == &#39;compr-&#39;:
            slotData = decompressData(slotData[6:])
        saveFile[key] = loads(slotData)
    return saveFile

def gearToMaxCost(gearID, currLvl, finalLvl):
    &#34;&#34;&#34;Computes and returns the cost of leveling the given gear from the
    given current level to the given final level.

    Args:
        gearID (str): The gear ID, as it appears in `GSGear`, of the
            given skill.
        currLevel (int): The current level of the gear.
        finalLevel (int): The final level of the gear.

    Returns:
        legends.constants.Inventory: The items needed to upgrade are
            stored and returned in an `legends.constants.Inventory`
            instance.

    &#34;&#34;&#34;
    cost = Inventory()
    while currLvl &lt; finalLvl:
        currLvl += 1
        cost += gearUpgradeCost(gearID, currLvl)
    return cost

def gearUpgradeCost(gearID, level):
    &#34;&#34;&#34;Computes and returns the cost of leveling the given gear to the
    given level, from the previous level.

    Args:
        gearID (str): The gear ID, as it appears in `GSGear`, of the
            given skill.
        level (int): The level to which the gear is being upgraded.

    Returns:
        legends.constants.Inventory: The items needed to upgrade are
            stored and returned in an `legends.constants.Inventory`
            instance.

    &#34;&#34;&#34;
    key = &#39;[{}, {}]&#39;.format(gearID, level)
    cost = Inventory()
    for itemID, qty in GSGearLevel[key][&#39;m_UpgradePrice&#39;][&#39;AllItems&#39;].items():
        cost[ITEMS[itemID]] += qty
    return cost

def getBasicGearID(role, slotIndex):
    &#34;&#34;&#34;Finds and returns the gear ID for the non-unique gear piece
    corresponding to the given role and meant for the gear slot with the
    given index.

    Args:
        role (str): The role of the gear piece.
        slotIndex (int): The slot index of the gear piece.

    Returns:
        str: The gear ID, as it appears in `GSGear`, of the gear piece.

    &#34;&#34;&#34;
    for gearID, data in GSGear.items():
        if (
            data[&#39;m_Type&#39;] == &#39;Role&#39;
            and data[&#39;m_Role&#39;] == role
            and data[&#39;m_Slot&#39;] == slotIndex
        ):
            return gearID
    raise ValueError(
        &#39;Could not find basic gear matching role {} and slot {}&#39;.format(
            role, slotIndex
        )
    )

def getCharStats(nameID, rank, level):
    &#34;&#34;&#34;Calculates a character&#39;s naked stats from its nameID, rank, and
    level.

    Args:
        nameID (str): The name ID of the character, as it appears in
            `GSCharacter`.
        rank (int): The rank of the character.
        level (int): The level of the character.

    Returns:
        dict: A dictionary mapping stat names, as they appear in
            `GSBaseStat`, to stat values.

    &#34;&#34;&#34;
    rarity = GSCharacter[nameID][&#39;Rarity&#39;]
    stats = {}
    for statName, data in GSBaseStat.items():
        m = data[&#39;MinValue&#39;] #pylint: disable=invalid-name
        M = data[&#39;MaxValue&#39;] #pylint: disable=invalid-name
        t = GSCharacter[nameID][statName] #pylint: disable=invalid-name
        baseStat = m + t * (M - m)
        try:
            levelMod = GSLevel[rarity + &#39;_&#39; + str(level)][
                    statName + &#39;Modifier&#39;
                ]
            rankMod = GSRank[rarity + &#39;_&#39; + str(rank)][
                    statName + &#39;Modifier&#39;
                ]
        except KeyError:
            levelMod = 1
            rankMod = 1
        statVal = baseStat * levelMod * rankMod
        stats[statName] = statVal
    return stats

def getGearStats(gearID, level):
    &#34;&#34;&#34;Calculates a gear&#39;s stats from its gear ID and level.

    Args:
        gearID (str): The gear ID as it appears in `GSGear`.
        level (int): The level of the gear. (See `Gear.level`.)

    Returns:
        dict: A dictionary mapping stat names, as they appear in
            `GSBaseStat`, to stat values.

    &#34;&#34;&#34;
    stats = {statName: 0 for statName in GSBaseStat}
    gearLevelID = &#39;[{}, {}]&#39;.format(gearID, level)
    numStats = GSGearLevel[gearLevelID][&#39;m_StatBrancheCount&#39;]
    for i in range(numStats):
        data = GSGear[gearID][&#39;m_Stats&#39;][i]
        statName = data[&#39;m_Type&#39;]
        statBase = data[&#39;m_BaseValue&#39;]
        statIncr = data[&#39;m_IncreaseValue&#39;]
        statVal = statBase + (level - 10 * i) * statIncr
        stats[statName] += statVal
    return stats

def getPartStats(rarity, level, statList):
    &#34;&#34;&#34;Calculates a particle&#39;s stats from its rarity, level, and list of
    stat names.

    Args:
        rarity (str): The particle&#39;s rarity.
        level (int): The particle&#39;s level.
        statList (list of str): The stat names on the particle.

    Returns:
        dict: A dictionary mapping stat names, as they appear in
            `GSBaseStat`, to stat values.

    &#34;&#34;&#34;
    stats = {statName: 0 for statName in GSBaseStat}
    for statName in statList:
        stats[statName] = (
            PART_STAT_VALUES[statName][rarity][level - 1]
        )
    return stats

def levelFromXP(xp, rarity=&#39;Common&#39;):
    &#34;&#34;&#34;Calculates the level of a character from its XP.

    Args:
        xp (int): The XP of the character.
        rarity (str): The rarity of the character.

    Returns:
        int: The level of the character.

    Raises:
        ValueError: If the level cannot be determined from the given xp
            value and the data in `GSLevel`.

    &#34;&#34;&#34;
    level = None
    for j in reversed(range(100)):
        xpNeeded = GSLevel[rarity + &#39;_&#39; + str(j)][&#39;Experience&#39;]
        if xp &gt;= xpNeeded:
            level = j
            break
    else:
        raise ValueError(repr(xp) + &#39; could not be converted from XP to level&#39;)
    return level

def saveFilePath():
    &#34;&#34;&#34;Creates and return the complete path of the STL save file.

    Returns:
        str: The complete path of the save file.

    &#34;&#34;&#34;
    return (
        &#39;/Users/&#39; + getuser() + &#39;/Library/Containers/&#39;
        + &#39;com.tiltingpoint.startrek/Data/Library/Preferences/&#39;
        + &#39;com.tiltingpoint.startrek.plist&#39;
    )

def skillToMaxCost(skillID, currLvl):
    &#34;&#34;&#34;Computes and returns the cost of leveling the given skill to
    Level 2, from the given current level.

    Args:
        skillID (str): The skill ID, as it appears in `GSSkill`, of the
            given skill.
        currLevel (int): The current level of the skill. If set to 0,
            the skill is currently locked.

    Returns:
        legends.constants.Inventory: The items needed to upgrade are
            stored and returned in an `legends.constants.Inventory`
            instance.

    &#34;&#34;&#34;
    cost = Inventory()
    while currLvl &lt; 2:
        currLvl += 1
        cost += skillUpgradeCost(skillID, currLvl)
    return cost

def skillUpgradeCost(skillID, level):
    &#34;&#34;&#34;Computes and returns the cost of leveling the given skill to the
    given level, from the previous level.

    Args:
        skillID (str): The skill ID, as it appears in `GSSkill`, of the
            given skill.
        level (int): The level to which the skill is being upgraded. If
            set to 1, returns the cost of unlocking the skill.

    Returns:
        legends.constants.Inventory: The items needed to upgrade are
            stored and returned in an `legends.constants.Inventory`
            instance.

    &#34;&#34;&#34;
    key = &#39;GSSkillKey(id = &#34;{}&#34;, level = &#34;{}&#34;)&#39;.format(skillID, level)
    cost = Inventory()
    for itemID, qty in GSSkillUpgrade[key][&#39;price&#39;][&#39;AllItems&#39;].items():
        cost[ITEMS[itemID]] += qty
    return cost

def tokensNeeded(rarity, rank):
    &#34;&#34;&#34;Returns the number of tokens needed by a character of the given
    rarity and rank to move up to the next rank.

    Args:
        rarity (str): The rarity of the character.
        rank (int): The current rank of the character.

    Returns:
        int: The total number of tokens need for the character to
            advance to the next rank.

    &#34;&#34;&#34;
    if rank == 9:
        return 0
    # pylint: disable-next=undefined-variable
    return GSRank[&#39;{}_{}&#39;.format(rarity, rank + 1)][&#39;RequiredTokenCount&#39;]

def xpFromLevel(level, rarity=&#39;Common&#39;):
    &#34;&#34;&#34;Calculates the minimum XP of a character from its level.

    Args:
        level (int): The level of the character.
        rarity (str): The rarity of the character.

    Returns:
        int: The minimum possible XP the character could have.

    &#34;&#34;&#34;
    return GSLevel[rarity + &#39;_&#39; + str(level)][&#39;Experience&#39;]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="legends.functions.charGearToMaxCost"><code class="name flex">
<span>def <span class="ident">charGearToMaxCost</span></span>(<span>rarity, role='Command')</span>
</code></dt>
<dd>
<div class="desc"><p>Computes and returns the cost of leveling all gear on a character
of the given rarity and role from level 1 to the maximum possible
level for that character.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>rarity</code></strong> :&ensp;<code>str</code></dt>
<dd>The rarity of the character.</dd>
<dt><strong><code>role</code></strong> :&ensp;<code>str</code></dt>
<dd>The role of the character.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="legends.constants.Inventory" href="constants.html#legends.constants.Inventory">Inventory</a></code></dt>
<dd>The items needed to upgrade are
stored and returned in an <code><a title="legends.constants.Inventory" href="constants.html#legends.constants.Inventory">Inventory</a></code>
instance.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def charGearToMaxCost(rarity, role=&#39;Command&#39;):
    &#34;&#34;&#34;Computes and returns the cost of leveling all gear on a character
    of the given rarity and role from level 1 to the maximum possible
    level for that character.

    Args:
        rarity (str): The rarity of the character.
        role (str): The role of the character.

    Returns:
        legends.constants.Inventory: The items needed to upgrade are
            stored and returned in an `legends.constants.Inventory`
            instance.

    &#34;&#34;&#34;
    maxGearLevel = 5 + 5 * RARITIES.index(rarity)
    cost = Inventory()
    for gearID, data in GSGear.items():
        if data[&#39;m_Role&#39;] != role:
            continue
        cost += gearToMaxCost(gearID, 1, maxGearLevel)
    return cost</code></pre>
</details>
</dd>
<dt id="legends.functions.cleanTime"><code class="name flex">
<span>def <span class="ident">cleanTime</span></span>(<span>delta)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts a <code>timedelta</code> object into a string description that
shows the number of days (if positive), hours, and minutes.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>delta</code></strong> :&ensp;<code>timedelta</code></dt>
<dd>The <code>timedelta</code> object to convert.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The string description.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cleanTime(delta):
    &#34;&#34;&#34;Converts a `timedelta` object into a string description that
    shows the number of days (if positive), hours, and minutes.

    Args:
        delta (timedelta): The `timedelta` object to convert.

    Returns:
        str: The string description.

    &#34;&#34;&#34;
    minutes = int(delta.total_seconds()/60)
    hours, minutes = minutes//60, minutes % 60
    days, hours = hours//24, hours % 24
    display = &#39;{} days &#39;.format(days) if days &gt; 1 else &#39;&#39;
    display += &#39;{} hrs {} min&#39;.format(hours, minutes)
    return display</code></pre>
</details>
</dd>
<dt id="legends.functions.decompressData"><code class="name flex">
<span>def <span class="ident">decompressData</span></span>(<span>text)</span>
</code></dt>
<dd>
<div class="desc"><p>STL data is sometimes compressed in the following manner,
converting a dictionary-like data object into a text string. First,
it is serialized to a json string. Then, it is compressed with zlib
deflate to binary data. Finally, it is encoded to base-64 to make
the binary data text friendly.</p>
<p>This function does the reverse. It takes a text string, which is a
base-64 encoding of binary data, and converts it back to binary. It
then decompresses it, then encodes the resulting decompressed binary
data to plain text (typically a json string).</p>
<p>This kind of compression can be found in support emails in STL.
Also, since STL v1.0.13, it is sometimes used in the save file to
compress slot data before encrypting (in which case, the slot data
must first be decrypted, then decompressed).</p>
<p>NOTE: Since STL v1.0.13, the data in support emails may be
compressed twice. First, it is compressed in the manner described
above. The resulting compressed string may then prepended with
"compr-" and compressed once more.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>The text data to be decompressed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The decompressed data, typically a json string.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decompressData(text):
    &#34;&#34;&#34;STL data is sometimes compressed in the following manner,
    converting a dictionary-like data object into a text string. First,
    it is serialized to a json string. Then, it is compressed with zlib
    deflate to binary data. Finally, it is encoded to base-64 to make
    the binary data text friendly.

    This function does the reverse. It takes a text string, which is a
    base-64 encoding of binary data, and converts it back to binary. It
    then decompresses it, then encodes the resulting decompressed binary
    data to plain text (typically a json string).

    This kind of compression can be found in support emails in STL.
    Also, since STL v1.0.13, it is sometimes used in the save file to
    compress slot data before encrypting (in which case, the slot data
    must first be decrypted, then decompressed).

    NOTE: Since STL v1.0.13, the data in support emails may be
    compressed twice. First, it is compressed in the manner described
    above. The resulting compressed string may then prepended with
    &#34;compr-&#34; and compressed once more.

    Args:
        text (str): The text data to be decompressed.

    Returns:
        str: The decompressed data, typically a json string.

    &#34;&#34;&#34;
    b64data = text.encode(&#39;utf-16&#39;)
    compressedData = b64decode(b64data)
    data = decompress(compressedData, -15)
    return data.decode(&#39;ascii&#39;)</code></pre>
</details>
</dd>
<dt id="legends.functions.decryptSaveFile"><code class="name flex">
<span>def <span class="ident">decryptSaveFile</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Finds the STL save file on the local hard drive, then decrypts
and parses it into a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>The decrypted save file as a dictionary.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decryptSaveFile():
    &#34;&#34;&#34;Finds the STL save file on the local hard drive, then decrypts
    and parses it into a dictionary.

    Returns:
        dict: The decrypted save file as a dictionary.

    &#34;&#34;&#34;
    with open(saveFilePath(), &#39;rb&#39;) as f:
        saveFile = load(f)
    saveFile.pop(&#39;CloudKitAccountInfoCache&#39;, None)
    for i in range(3):
        key = str(i) + &#39; data&#39;
        if len(saveFile.get(key, &#39;&#39;)) == 0:
            saveFile[key] = {}
            continue
        slotData = AESdecrypt(
            saveFile[key],
            &#39;K1FjcmVkc2Vhc29u&#39;,
            &#39;LH75Qxpyf0prVvImu4gqxg==&#39;
        )
        if slotData[:6] == &#39;compr-&#39;:
            slotData = decompressData(slotData[6:])
        saveFile[key] = loads(slotData)
    return saveFile</code></pre>
</details>
</dd>
<dt id="legends.functions.gearToMaxCost"><code class="name flex">
<span>def <span class="ident">gearToMaxCost</span></span>(<span>gearID, currLvl, finalLvl)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes and returns the cost of leveling the given gear from the
given current level to the given final level.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>gearID</code></strong> :&ensp;<code>str</code></dt>
<dd>The gear ID, as it appears in <code>GSGear</code>, of the
given skill.</dd>
<dt><strong><code>currLevel</code></strong> :&ensp;<code>int</code></dt>
<dd>The current level of the gear.</dd>
<dt><strong><code>finalLevel</code></strong> :&ensp;<code>int</code></dt>
<dd>The final level of the gear.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="legends.constants.Inventory" href="constants.html#legends.constants.Inventory">Inventory</a></code></dt>
<dd>The items needed to upgrade are
stored and returned in an <code><a title="legends.constants.Inventory" href="constants.html#legends.constants.Inventory">Inventory</a></code>
instance.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gearToMaxCost(gearID, currLvl, finalLvl):
    &#34;&#34;&#34;Computes and returns the cost of leveling the given gear from the
    given current level to the given final level.

    Args:
        gearID (str): The gear ID, as it appears in `GSGear`, of the
            given skill.
        currLevel (int): The current level of the gear.
        finalLevel (int): The final level of the gear.

    Returns:
        legends.constants.Inventory: The items needed to upgrade are
            stored and returned in an `legends.constants.Inventory`
            instance.

    &#34;&#34;&#34;
    cost = Inventory()
    while currLvl &lt; finalLvl:
        currLvl += 1
        cost += gearUpgradeCost(gearID, currLvl)
    return cost</code></pre>
</details>
</dd>
<dt id="legends.functions.gearUpgradeCost"><code class="name flex">
<span>def <span class="ident">gearUpgradeCost</span></span>(<span>gearID, level)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes and returns the cost of leveling the given gear to the
given level, from the previous level.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>gearID</code></strong> :&ensp;<code>str</code></dt>
<dd>The gear ID, as it appears in <code>GSGear</code>, of the
given skill.</dd>
<dt><strong><code>level</code></strong> :&ensp;<code>int</code></dt>
<dd>The level to which the gear is being upgraded.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="legends.constants.Inventory" href="constants.html#legends.constants.Inventory">Inventory</a></code></dt>
<dd>The items needed to upgrade are
stored and returned in an <code><a title="legends.constants.Inventory" href="constants.html#legends.constants.Inventory">Inventory</a></code>
instance.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gearUpgradeCost(gearID, level):
    &#34;&#34;&#34;Computes and returns the cost of leveling the given gear to the
    given level, from the previous level.

    Args:
        gearID (str): The gear ID, as it appears in `GSGear`, of the
            given skill.
        level (int): The level to which the gear is being upgraded.

    Returns:
        legends.constants.Inventory: The items needed to upgrade are
            stored and returned in an `legends.constants.Inventory`
            instance.

    &#34;&#34;&#34;
    key = &#39;[{}, {}]&#39;.format(gearID, level)
    cost = Inventory()
    for itemID, qty in GSGearLevel[key][&#39;m_UpgradePrice&#39;][&#39;AllItems&#39;].items():
        cost[ITEMS[itemID]] += qty
    return cost</code></pre>
</details>
</dd>
<dt id="legends.functions.getBasicGearID"><code class="name flex">
<span>def <span class="ident">getBasicGearID</span></span>(<span>role, slotIndex)</span>
</code></dt>
<dd>
<div class="desc"><p>Finds and returns the gear ID for the non-unique gear piece
corresponding to the given role and meant for the gear slot with the
given index.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>role</code></strong> :&ensp;<code>str</code></dt>
<dd>The role of the gear piece.</dd>
<dt><strong><code>slotIndex</code></strong> :&ensp;<code>int</code></dt>
<dd>The slot index of the gear piece.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The gear ID, as it appears in <code>GSGear</code>, of the gear piece.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getBasicGearID(role, slotIndex):
    &#34;&#34;&#34;Finds and returns the gear ID for the non-unique gear piece
    corresponding to the given role and meant for the gear slot with the
    given index.

    Args:
        role (str): The role of the gear piece.
        slotIndex (int): The slot index of the gear piece.

    Returns:
        str: The gear ID, as it appears in `GSGear`, of the gear piece.

    &#34;&#34;&#34;
    for gearID, data in GSGear.items():
        if (
            data[&#39;m_Type&#39;] == &#39;Role&#39;
            and data[&#39;m_Role&#39;] == role
            and data[&#39;m_Slot&#39;] == slotIndex
        ):
            return gearID
    raise ValueError(
        &#39;Could not find basic gear matching role {} and slot {}&#39;.format(
            role, slotIndex
        )
    )</code></pre>
</details>
</dd>
<dt id="legends.functions.getCharStats"><code class="name flex">
<span>def <span class="ident">getCharStats</span></span>(<span>nameID, rank, level)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates a character's naked stats from its nameID, rank, and
level.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>nameID</code></strong> :&ensp;<code>str</code></dt>
<dd>The name ID of the character, as it appears in
<code>GSCharacter</code>.</dd>
<dt><strong><code>rank</code></strong> :&ensp;<code>int</code></dt>
<dd>The rank of the character.</dd>
<dt><strong><code>level</code></strong> :&ensp;<code>int</code></dt>
<dd>The level of the character.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary mapping stat names, as they appear in
<code>GSBaseStat</code>, to stat values.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getCharStats(nameID, rank, level):
    &#34;&#34;&#34;Calculates a character&#39;s naked stats from its nameID, rank, and
    level.

    Args:
        nameID (str): The name ID of the character, as it appears in
            `GSCharacter`.
        rank (int): The rank of the character.
        level (int): The level of the character.

    Returns:
        dict: A dictionary mapping stat names, as they appear in
            `GSBaseStat`, to stat values.

    &#34;&#34;&#34;
    rarity = GSCharacter[nameID][&#39;Rarity&#39;]
    stats = {}
    for statName, data in GSBaseStat.items():
        m = data[&#39;MinValue&#39;] #pylint: disable=invalid-name
        M = data[&#39;MaxValue&#39;] #pylint: disable=invalid-name
        t = GSCharacter[nameID][statName] #pylint: disable=invalid-name
        baseStat = m + t * (M - m)
        try:
            levelMod = GSLevel[rarity + &#39;_&#39; + str(level)][
                    statName + &#39;Modifier&#39;
                ]
            rankMod = GSRank[rarity + &#39;_&#39; + str(rank)][
                    statName + &#39;Modifier&#39;
                ]
        except KeyError:
            levelMod = 1
            rankMod = 1
        statVal = baseStat * levelMod * rankMod
        stats[statName] = statVal
    return stats</code></pre>
</details>
</dd>
<dt id="legends.functions.getGearStats"><code class="name flex">
<span>def <span class="ident">getGearStats</span></span>(<span>gearID, level)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates a gear's stats from its gear ID and level.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>gearID</code></strong> :&ensp;<code>str</code></dt>
<dd>The gear ID as it appears in <code>GSGear</code>.</dd>
<dt><strong><code>level</code></strong> :&ensp;<code>int</code></dt>
<dd>The level of the gear. (See <code>Gear.level</code>.)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary mapping stat names, as they appear in
<code>GSBaseStat</code>, to stat values.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getGearStats(gearID, level):
    &#34;&#34;&#34;Calculates a gear&#39;s stats from its gear ID and level.

    Args:
        gearID (str): The gear ID as it appears in `GSGear`.
        level (int): The level of the gear. (See `Gear.level`.)

    Returns:
        dict: A dictionary mapping stat names, as they appear in
            `GSBaseStat`, to stat values.

    &#34;&#34;&#34;
    stats = {statName: 0 for statName in GSBaseStat}
    gearLevelID = &#39;[{}, {}]&#39;.format(gearID, level)
    numStats = GSGearLevel[gearLevelID][&#39;m_StatBrancheCount&#39;]
    for i in range(numStats):
        data = GSGear[gearID][&#39;m_Stats&#39;][i]
        statName = data[&#39;m_Type&#39;]
        statBase = data[&#39;m_BaseValue&#39;]
        statIncr = data[&#39;m_IncreaseValue&#39;]
        statVal = statBase + (level - 10 * i) * statIncr
        stats[statName] += statVal
    return stats</code></pre>
</details>
</dd>
<dt id="legends.functions.getPartStats"><code class="name flex">
<span>def <span class="ident">getPartStats</span></span>(<span>rarity, level, statList)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates a particle's stats from its rarity, level, and list of
stat names.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>rarity</code></strong> :&ensp;<code>str</code></dt>
<dd>The particle's rarity.</dd>
<dt><strong><code>level</code></strong> :&ensp;<code>int</code></dt>
<dd>The particle's level.</dd>
<dt><strong><code>statList</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>The stat names on the particle.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary mapping stat names, as they appear in
<code>GSBaseStat</code>, to stat values.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getPartStats(rarity, level, statList):
    &#34;&#34;&#34;Calculates a particle&#39;s stats from its rarity, level, and list of
    stat names.

    Args:
        rarity (str): The particle&#39;s rarity.
        level (int): The particle&#39;s level.
        statList (list of str): The stat names on the particle.

    Returns:
        dict: A dictionary mapping stat names, as they appear in
            `GSBaseStat`, to stat values.

    &#34;&#34;&#34;
    stats = {statName: 0 for statName in GSBaseStat}
    for statName in statList:
        stats[statName] = (
            PART_STAT_VALUES[statName][rarity][level - 1]
        )
    return stats</code></pre>
</details>
</dd>
<dt id="legends.functions.levelFromXP"><code class="name flex">
<span>def <span class="ident">levelFromXP</span></span>(<span>xp, rarity='Common')</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the level of a character from its XP.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>xp</code></strong> :&ensp;<code>int</code></dt>
<dd>The XP of the character.</dd>
<dt><strong><code>rarity</code></strong> :&ensp;<code>str</code></dt>
<dd>The rarity of the character.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The level of the character.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the level cannot be determined from the given xp
value and the data in <code>GSLevel</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def levelFromXP(xp, rarity=&#39;Common&#39;):
    &#34;&#34;&#34;Calculates the level of a character from its XP.

    Args:
        xp (int): The XP of the character.
        rarity (str): The rarity of the character.

    Returns:
        int: The level of the character.

    Raises:
        ValueError: If the level cannot be determined from the given xp
            value and the data in `GSLevel`.

    &#34;&#34;&#34;
    level = None
    for j in reversed(range(100)):
        xpNeeded = GSLevel[rarity + &#39;_&#39; + str(j)][&#39;Experience&#39;]
        if xp &gt;= xpNeeded:
            level = j
            break
    else:
        raise ValueError(repr(xp) + &#39; could not be converted from XP to level&#39;)
    return level</code></pre>
</details>
</dd>
<dt id="legends.functions.saveFilePath"><code class="name flex">
<span>def <span class="ident">saveFilePath</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and return the complete path of the STL save file.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The complete path of the save file.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def saveFilePath():
    &#34;&#34;&#34;Creates and return the complete path of the STL save file.

    Returns:
        str: The complete path of the save file.

    &#34;&#34;&#34;
    return (
        &#39;/Users/&#39; + getuser() + &#39;/Library/Containers/&#39;
        + &#39;com.tiltingpoint.startrek/Data/Library/Preferences/&#39;
        + &#39;com.tiltingpoint.startrek.plist&#39;
    )</code></pre>
</details>
</dd>
<dt id="legends.functions.skillToMaxCost"><code class="name flex">
<span>def <span class="ident">skillToMaxCost</span></span>(<span>skillID, currLvl)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes and returns the cost of leveling the given skill to
Level 2, from the given current level.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>skillID</code></strong> :&ensp;<code>str</code></dt>
<dd>The skill ID, as it appears in <code>GSSkill</code>, of the
given skill.</dd>
<dt><strong><code>currLevel</code></strong> :&ensp;<code>int</code></dt>
<dd>The current level of the skill. If set to 0,
the skill is currently locked.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="legends.constants.Inventory" href="constants.html#legends.constants.Inventory">Inventory</a></code></dt>
<dd>The items needed to upgrade are
stored and returned in an <code><a title="legends.constants.Inventory" href="constants.html#legends.constants.Inventory">Inventory</a></code>
instance.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def skillToMaxCost(skillID, currLvl):
    &#34;&#34;&#34;Computes and returns the cost of leveling the given skill to
    Level 2, from the given current level.

    Args:
        skillID (str): The skill ID, as it appears in `GSSkill`, of the
            given skill.
        currLevel (int): The current level of the skill. If set to 0,
            the skill is currently locked.

    Returns:
        legends.constants.Inventory: The items needed to upgrade are
            stored and returned in an `legends.constants.Inventory`
            instance.

    &#34;&#34;&#34;
    cost = Inventory()
    while currLvl &lt; 2:
        currLvl += 1
        cost += skillUpgradeCost(skillID, currLvl)
    return cost</code></pre>
</details>
</dd>
<dt id="legends.functions.skillUpgradeCost"><code class="name flex">
<span>def <span class="ident">skillUpgradeCost</span></span>(<span>skillID, level)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes and returns the cost of leveling the given skill to the
given level, from the previous level.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>skillID</code></strong> :&ensp;<code>str</code></dt>
<dd>The skill ID, as it appears in <code>GSSkill</code>, of the
given skill.</dd>
<dt><strong><code>level</code></strong> :&ensp;<code>int</code></dt>
<dd>The level to which the skill is being upgraded. If
set to 1, returns the cost of unlocking the skill.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="legends.constants.Inventory" href="constants.html#legends.constants.Inventory">Inventory</a></code></dt>
<dd>The items needed to upgrade are
stored and returned in an <code><a title="legends.constants.Inventory" href="constants.html#legends.constants.Inventory">Inventory</a></code>
instance.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def skillUpgradeCost(skillID, level):
    &#34;&#34;&#34;Computes and returns the cost of leveling the given skill to the
    given level, from the previous level.

    Args:
        skillID (str): The skill ID, as it appears in `GSSkill`, of the
            given skill.
        level (int): The level to which the skill is being upgraded. If
            set to 1, returns the cost of unlocking the skill.

    Returns:
        legends.constants.Inventory: The items needed to upgrade are
            stored and returned in an `legends.constants.Inventory`
            instance.

    &#34;&#34;&#34;
    key = &#39;GSSkillKey(id = &#34;{}&#34;, level = &#34;{}&#34;)&#39;.format(skillID, level)
    cost = Inventory()
    for itemID, qty in GSSkillUpgrade[key][&#39;price&#39;][&#39;AllItems&#39;].items():
        cost[ITEMS[itemID]] += qty
    return cost</code></pre>
</details>
</dd>
<dt id="legends.functions.tokensNeeded"><code class="name flex">
<span>def <span class="ident">tokensNeeded</span></span>(<span>rarity, rank)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the number of tokens needed by a character of the given
rarity and rank to move up to the next rank.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>rarity</code></strong> :&ensp;<code>str</code></dt>
<dd>The rarity of the character.</dd>
<dt><strong><code>rank</code></strong> :&ensp;<code>int</code></dt>
<dd>The current rank of the character.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The total number of tokens need for the character to
advance to the next rank.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tokensNeeded(rarity, rank):
    &#34;&#34;&#34;Returns the number of tokens needed by a character of the given
    rarity and rank to move up to the next rank.

    Args:
        rarity (str): The rarity of the character.
        rank (int): The current rank of the character.

    Returns:
        int: The total number of tokens need for the character to
            advance to the next rank.

    &#34;&#34;&#34;
    if rank == 9:
        return 0
    # pylint: disable-next=undefined-variable
    return GSRank[&#39;{}_{}&#39;.format(rarity, rank + 1)][&#39;RequiredTokenCount&#39;]</code></pre>
</details>
</dd>
<dt id="legends.functions.xpFromLevel"><code class="name flex">
<span>def <span class="ident">xpFromLevel</span></span>(<span>level, rarity='Common')</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the minimum XP of a character from its level.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>level</code></strong> :&ensp;<code>int</code></dt>
<dd>The level of the character.</dd>
<dt><strong><code>rarity</code></strong> :&ensp;<code>str</code></dt>
<dd>The rarity of the character.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The minimum possible XP the character could have.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xpFromLevel(level, rarity=&#39;Common&#39;):
    &#34;&#34;&#34;Calculates the minimum XP of a character from its level.

    Args:
        level (int): The level of the character.
        rarity (str): The rarity of the character.

    Returns:
        int: The minimum possible XP the character could have.

    &#34;&#34;&#34;
    return GSLevel[rarity + &#39;_&#39; + str(level)][&#39;Experience&#39;]</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="legends" href="index.html">legends</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="legends.functions.charGearToMaxCost" href="#legends.functions.charGearToMaxCost">charGearToMaxCost</a></code></li>
<li><code><a title="legends.functions.cleanTime" href="#legends.functions.cleanTime">cleanTime</a></code></li>
<li><code><a title="legends.functions.decompressData" href="#legends.functions.decompressData">decompressData</a></code></li>
<li><code><a title="legends.functions.decryptSaveFile" href="#legends.functions.decryptSaveFile">decryptSaveFile</a></code></li>
<li><code><a title="legends.functions.gearToMaxCost" href="#legends.functions.gearToMaxCost">gearToMaxCost</a></code></li>
<li><code><a title="legends.functions.gearUpgradeCost" href="#legends.functions.gearUpgradeCost">gearUpgradeCost</a></code></li>
<li><code><a title="legends.functions.getBasicGearID" href="#legends.functions.getBasicGearID">getBasicGearID</a></code></li>
<li><code><a title="legends.functions.getCharStats" href="#legends.functions.getCharStats">getCharStats</a></code></li>
<li><code><a title="legends.functions.getGearStats" href="#legends.functions.getGearStats">getGearStats</a></code></li>
<li><code><a title="legends.functions.getPartStats" href="#legends.functions.getPartStats">getPartStats</a></code></li>
<li><code><a title="legends.functions.levelFromXP" href="#legends.functions.levelFromXP">levelFromXP</a></code></li>
<li><code><a title="legends.functions.saveFilePath" href="#legends.functions.saveFilePath">saveFilePath</a></code></li>
<li><code><a title="legends.functions.skillToMaxCost" href="#legends.functions.skillToMaxCost">skillToMaxCost</a></code></li>
<li><code><a title="legends.functions.skillUpgradeCost" href="#legends.functions.skillUpgradeCost">skillUpgradeCost</a></code></li>
<li><code><a title="legends.functions.tokensNeeded" href="#legends.functions.tokensNeeded">tokensNeeded</a></code></li>
<li><code><a title="legends.functions.xpFromLevel" href="#legends.functions.xpFromLevel">xpFromLevel</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>