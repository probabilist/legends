<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>legends.ui.dialogs API documentation</title>
<meta name="description" content="Dialog windows for use with the `legends` package." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>legends.ui.dialogs</code></h1>
</header>
<section id="section-intro">
<p>Dialog windows for use with the <code><a title="legends" href="../index.html">legends</a></code> package.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Dialog windows for use with the `legends` package.

&#34;&#34;&#34;

import tkinter as tk
from tkinter import (
    ttk, E, W, HORIZONTAL, LEFT, RIGHT, ACTIVE, YES, X, DISABLED
)
from tkinter.messagebox import showerror as _showerror
from tkinter.messagebox import showinfo as _showinfo
from tkinter.messagebox import askyesno as _askyesno
from tkinter.simpledialog import Dialog
from tkinter.scrolledtext import ScrolledText
# pylint: disable-next=no-name-in-module
from legends.constants import GSCharacter
from legends.constants import (
    RARITIES, ROLES, ENABLED, UPCOMING, SUMMON_POOL, HELP, STAT_INITIALS
)
from legends.saveslot import SaveSlot

__all__ = [
    &#39;addroot&#39;, &#39;showerror&#39;, &#39;showinfo&#39;, &#39;askyesno&#39;, &#39;askSlot&#39;,
    &#39;askRosterFilter&#39;, &#39;askMaxChars&#39;, &#39;ModalMessage&#39;, &#39;ModalDialog&#39;, &#39;AskSlot&#39;,
    &#39;RosterFilter&#39;, &#39;AskRosterFilter&#39;, &#39;AskMaxChars&#39;, &#39;HelpScreen&#39;,
    &#39;OptimalSummons&#39;
]

def addroot(func):
    &#34;&#34;&#34;Creates and returns a new function from the given function by
    adding a `root` positional argument at the front, which should be
    the currently running `legends.ui.stlplanner.STLPlanner` instance.
    The new function will ensure that the menus of `root` are disabled
    before calling the given function, and will return the menus to
    their original state after calling the given function.

    &#34;&#34;&#34;
    def newFunc(root, *args, **kargs):
        state = root.menuEnabled
        if state:
            root.menuEnabled = False
        result = func(*args, **kargs)
        if state:
            root.menuEnabled = True
        return result
    return newFunc

def showerror(root, *args, **kargs):
    &#34;&#34;&#34;A wrapper around `tk.messagebox.showerror` that disables the root
    menu while the dialog is open.

    Args:
        root (legends.ui.stlplanner.STLPlanner): The currently running
            `legends.ui.stlplanner.STLPlanner` instance.

    &#34;&#34;&#34;
    return addroot(_showerror)(root, *args, **kargs)

def showinfo(root, *args, **kargs):
    &#34;&#34;&#34;A wrapper around `tk.messagebox.showinfo` that disables the root
    menu while the dialog is open.

    Args:
        root (legends.ui.stlplanner.STLPlanner): The currently running
            `legends.ui.stlplanner.STLPlanner` instance.

    &#34;&#34;&#34;
    return addroot(_showinfo)(root, *args, **kargs)

def askyesno(root, *args, **kargs):
    &#34;&#34;&#34;A wrapper around `tk.messagebox.askyesno` that disables the root
    menu while the dialog is open.

    Args:
        root (legends.ui.stlplanner.STLPlanner): The currently running
            `legends.ui.stlplanner.STLPlanner` instance.

    &#34;&#34;&#34;
    return addroot(_askyesno)(root, *args, **kargs)

def askSlot(root, save):
    &#34;&#34;&#34;Raises an `AskSlot` dialog window, prompting the user to select a
    save slot.

    Args:
        root (legends.ui.stlplanner.STLPlanner): The currently running
            `legends.ui.stlplanner.STLPlanner` instance.
        save (dict): A decrypted dictionary representation of the
            player&#39;s save file, as returned by the
            `legends.savefile.decryptSaveFile` function.

    Returns:
        legends.saveslot.SaveSlot or None: Returns a
            `legends.saveslot.SaveSlot` instance created from the chosen
            slot number. Returns `None` if no slot was selected.

    &#34;&#34;&#34;
    dialog = AskSlot(root, save)
    return dialog.result

def askRosterFilter(root, filt):
    &#34;&#34;&#34;Raises an `AskRosterFilter` dialog window, prompting the user to
    adjust the filters for the roster tab. The dialog window is
    initialized to display the filters passed by the `filt` argument.

    Args:
        root (legends.ui.stlplanner.STLPlanner): The currently running
            `legends.ui.stlplanner.STLPlanner` instance.
        filt (RosterFilter): The filter used to initialize the dialog
            window. This filter is not modified.

    Returns:
        RosterFilter or None: Returns a new `RosterFilter` object
            representing the user&#39;s choices. Returns `None` if no
            choices were confirmed.

    &#34;&#34;&#34;
    dialog = AskRosterFilter(root, filt)
    return dialog.result

def askMaxChars(root):
    &#34;&#34;&#34;Raises an `AskMaxChars` dialog window, prompting the user to
    select from an array of options for creating a roster of maxed
    characters.

    Args:
        root (legends.ui.stlplanner.STLPlanner): The currently running
            `legends.ui.stlplanner.STLPlanner` instance.

    Returns:
        tuple: ([`str`], `bool`) The first value in the tuple is the
            list of name IDs of characters the user wants to include in
            the roster. The second value is `True` if the user wants the
            maxed characters to also have maxed gear.

    &#34;&#34;&#34;
    dialog = AskMaxChars(root)
    return dialog.result

class ModalMessage(Dialog):
    &#34;&#34;&#34;A subclass of `tk.simpledialog.Dialog` that disables menus. Has
    an &#39;OK&#39; button, but no &#39;Cancel&#39; button.

    Attributes:
        root (legends.ui.stlplanner.STLPlanner): The currently running
            `legends.ui.stlplanner.STLPlanner` instance.
        initialMenuState (bool): `True` if the root menu is enabled at
            the moment the dialog opens.
        box (tk.Frame): The frame that holds the buttons.

    &#34;&#34;&#34;
    def __init__(self, root, parent=None, title=None):
        &#34;&#34;&#34;The constructor disables the root menu before calling the
        `tk.simpledialog.Dialog` constructor.

        &#34;&#34;&#34;
        self.root = root
        self.initialMenuState = self.root.menuEnabled
        if self.initialMenuState:
            self.root.menuEnabled = False
        if parent is None:
            parent = tk._default_root
        Dialog.__init__(self, parent, title)

    def buttonbox(self):
        &#34;&#34;&#34;Builds the standard &#39;OK&#39; button of the
        `tk.simpledialog.Dialog` class.

        &#34;&#34;&#34;
        self.box = tk.Frame(self)

        tk.Button(
            self.box, text=&#34;OK&#34;, width=10, command=self.ok, default=ACTIVE
        ).pack(side=RIGHT, padx=5, pady=5)

        self.bind(&#34;&lt;Return&gt;&#34;, self.ok)

        self.box.pack()

    def destroy(self):
        &#34;&#34;&#34;Restores root menu options to their original state, then
        destroys the window.

        &#34;&#34;&#34;
        self.initial_focus = None
        if self.initialMenuState:
            self.root.menuEnabled = True
        tk.Toplevel.destroy(self)

class ModalDialog(ModalMessage):
    &#34;&#34;&#34;A subclass of `ModalMessage` that has a &#39;Cancel&#39; button.

    Attributes:
        root (legends.ui.stlplanner.STLPlanner): The currently running
            `legends.ui.stlplanner.STLPlanner` instance.
        initialMenuState (bool): `True` if the root menu is enabled at
            the moment the dialog opens.
        box (tk.Frame): The frame that holds the &#39;OK&#39; and &#39;Cancel&#39;
            buttons.

    &#34;&#34;&#34;
    def __init__(self, root, parent=None, title=None):
        ModalMessage.__init__(self, root, parent, title)

    def buttonbox(self):
        &#34;&#34;&#34;Adds the standard &#39;Cancel&#39; button of the
        `tk.simpledialog.Dialog` class.

        &#34;&#34;&#34;
        ModalMessage.buttonbox(self)

        tk.Button(
            self.box, text=&#34;Cancel&#34;, width=10, command=self.cancel
        ).pack(side=RIGHT, padx=5, pady=5)

        self.bind(&#34;&lt;Escape&gt;&#34;, self.cancel)

class AskSlot(ModalDialog):
    &#34;&#34;&#34;A modal dialog that prompts the user to select a save slot.

    Save slots are denoted in the game data as 0, 1, or 2. In the
    `AskSlot` window, they are shown to the user as &#39;1&#39;, &#39;2&#39;, or &#39;3&#39;.

    Attributes:
        save (dict): A decrypted dictionary representation of the
            player&#39;s save file, as returned by the
            `legends.savefile.decryptSaveFile` function.
        displaySlot (tk.StringVar): The currently selected slot, as it
            is displayed in the window.
        result (SaveSlot or None): Inherited from `ModalDialog`, which
            inherited it from `tk.simpledialog.Dialog`. Defaults to
            `None`. Is set by the `AskSlot.validate` method to a
            `SaveSlot` instance created from the chosen slot number.

    &#34;&#34;&#34;
    def __init__(self, root, save, parent=None):
        self.save = save
        self.displaySlot = tk.StringVar(None, &#39;1&#39;)
        ModalDialog.__init__(self, root, parent, &#39;Choose a save slot&#39;)

    def body(self, master):
        &#34;&#34;&#34;Create the body of the dialog.

        &#34;&#34;&#34;
        # create an informational label
        msg = (
            &#34;Open Star Trek: Legends on this Mac and let it load to the &#34;
            + &#34;splash screen. This will allow your cloud save to sync to &#34;
            + &#34;the local hard drive. Then choose the save slot data you would &#34;
            + &#34;like to use.&#34;
        )
        tk.Label(master, wraplength=250, justify=LEFT, text=msg).pack()

        # create the subframe used for selecting the slot
        slotBar = tk.Frame(master)
        tk.Label(slotBar, text=&#39;Extract from save slot:&#39;).pack(side=LEFT)
        cbox = ttk.Combobox(
            slotBar,
            textvariable=self.displaySlot,
            values=[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;],
            state=&#39;readonly&#39;,
            width=1
        )
        cbox.pack()

        # pack the subframe and return the combobox for focus
        slotBar.pack(pady=10)
        return cbox

    def validate(self):
        &#34;&#34;&#34;Set the `result` attribute and return `True`.

        &#34;&#34;&#34;
        slot = int(self.displaySlot.get()) - 1
        key = &#39;{} data&#39;.format(slot)
        if key not in self.save or not self.save[key]:
            showerror(
                self.root,
                &#39;Slot Error&#39;,
                &#39;No save data found in slot {}.&#39;.format(slot + 1)
            )
            return False
        self.result = SaveSlot()
        self.result.fromFile(self.save, slot)
        return True

class RosterFilter():
    &#34;&#34;&#34;Stores information about filtering a
    `legends.ui.rostertab.RosterTab`.

    Attributes:
        rarities (dict): {`str`:`tk.BooleanVar`} A dictionary mapping
            rarities to `tkinter` boolean variables indicating whether
            the rarity is to be included in the
            `legends.ui.rostertab.RosterTab`.
        roles (dict): {`str`:`tk.BooleanVar`} A dictionary mapping roles
            to `tkinter` boolean variables indicating whether the role
            is to be included in the `legends.ui.rostertab.RosterTab`.
        ranks (tuple): (`tk.IntVar`, `tk.IntVar`) The first value is the
            minimum rank to include in the
            `legends.ui.rostertab.RosterTab`. The second is the maximum.
        levels (tuple): (`tk.IntVar`, `tk.IntVar`) The first value is
            the minimum level to include in the
            `legends.ui.rostertab.RosterTab`. The second is the maximum.

    &#34;&#34;&#34;

    def __init__(self, filt=None):
        &#34;&#34;&#34;The constructor creates a new `RosterFilter` object with the
        same values as the given `RosterFilter` object. If `None` is
        provided, the new filter will not omit anything.

        Args:
            filt (RosterFilter): The filter used to initialize the new
                filter.

        &#34;&#34;&#34;
        self.rarities = {
            rarity: tk.BooleanVar(None, True) for rarity in RARITIES
        }
        self.roles = {
            role: tk.BooleanVar(None, True) for role in ROLES
        }
        self.ranks = (tk.IntVar(None, 1), tk.IntVar(None, 9))
        self.levels = (tk.IntVar(None, 1), tk.IntVar(None, 99))
        if filt is not None:
            self.set(filt)

    def set(self, filt):
        &#34;&#34;&#34;Sets the values of the calling instance to match those of the
        given filter.

        Args:
            filt (RosterFilter): The filter from which to copy values.

        &#34;&#34;&#34;
        for rarity, var in self.rarities.items():
            var.set(filt.rarities[rarity].get())
        for role, var in self.roles.items():
            var.set(filt.roles[role].get())
        for j in (0, 1):
            self.ranks[j].set(filt.ranks[j].get())
        for j in (0, 1):
            self.levels[j].set(filt.levels[j].get())

    def dictify(self):
        &#34;&#34;&#34;Creates and returns a dictionary mapping the calling
        instance&#39;s attribute names to its values, with each `tkinter`
        variable replaced by its value.

        Returns:
            dict: The constructed dictionary.

        &#34;&#34;&#34;
        D = {}
        D[&#39;rarities&#39;] = {
            rarity: var.get() for rarity, var in self.rarities.items()
        }
        D[&#39;roles&#39;] = {
            role: var.get() for role, var in self.roles.items()
        }
        D[&#39;ranks&#39;] = (self.ranks[0].get(), self.ranks[1].get())
        D[&#39;levels&#39;] = (self.levels[0].get(), self.levels[1].get())
        return D

    def __eq__(self, other):
        return self.dictify() == other.dictify()

    def __repr__(self):
        return &#39;RosterFilter({})&#39;.format(self.dictify())

class AskRosterFilter(ModalDialog):
    &#34;&#34;&#34;A modal dialog used for adjusting `RosterFilter` objects.

    The constructor must be given a `RosterFilter` object. That object
    will be used to initialize the window, but will not be modified.

    Attributes:
        filt (RosterFilter): The `RosterFilter` object controlled and
            modified by the dialog window.
        result (RosterFilter or None): Inherited from `ModalDialog`,
            which inherited it from `tk.simpledialog.Dialog`. Defaults
            to `None`. Is set by the `AskRosterFilter.apply` method to
            the value of the `filt` attribute.

    &#34;&#34;&#34;
    def __init__(self, root, rosterFilter, parent=None):
        &#34;&#34;&#34;The constructor sets the `filt` attribute, then calls the
        `ModalDialog` constructor.

        Args:
            root (legends.ui.stlplanner.STLPlanner): The currently
                running `legends.ui.stlplanner.STLPlanner` instance.
                Passed to the `ModalDialog` constructor.
            rosterFilter (RosterFilter): The instance&#39;s `filt` attribute
                is assigned a copy of this argument.

        &#34;&#34;&#34;
        self.filt = RosterFilter(rosterFilter)
        ModalDialog.__init__(self, root, parent, &#39;Filter characters&#39;)

    def body(self, master):
        &#34;&#34;&#34;Create the body of the dialog.

        &#34;&#34;&#34;
        widgets = {}

        # create the rarity and role checkboxes
        widgets[&#39;rarityCheckboxes&#39;] = tk.Frame(master)
        for rarity in RARITIES:
            tk.Checkbutton(
                widgets[&#39;rarityCheckboxes&#39;], text=rarity,
                variable=self.filt.rarities[rarity]
            ).pack(side=LEFT)
        widgets[&#39;roleCheckboxes&#39;] = tk.Frame(master)
        for role in ROLES:
            tk.Checkbutton(
                widgets[&#39;roleCheckboxes&#39;], text=role,
                variable=self.filt.roles[role]
            ).pack(side=LEFT)

        # create the rank and level linked scales
        widgets[&#39;rankMinScale&#39;], widgets[&#39;rankMaxScale&#39;] = (
            self.makeLinkedScales(master, &#39;ranks&#39;, 9)
        )
        widgets[&#39;levelMinScale&#39;], widgets[&#39;levelMaxScale&#39;] = (
            self.makeLinkedScales(master, &#39;levels&#39;, 99)
        )

        # grid the body content
        labels = [
            &#39;Rarity:&#39;, &#39;Role:&#39;,
            &#39;Min rank:&#39;, &#39;Max rank:&#39;, &#39;Min level:&#39;, &#39;Max level:&#39;
        ]
        for row, label, widget in zip(range(6), labels, widgets.values()):
            tk.Label(master, text=label, font=(None, 13, &#39;bold&#39;)).grid(
                row=row, column=0, sticky=E
            )
            widget.grid(row=row, column=1, sticky=W)

    def makeLinkedScales(self, master, attrName, maxVal):
        &#34;&#34;&#34;Creates and returns a pair of linked Scale widgets. Each
        scale has values from 1 to `maxVal`. If `attrName` is &#39;ranks&#39;,
        the scales are associated with the `tkinter` variables stored in
        the `ranks` attribute of the calling instance&#39;s `filt`
        attribute. Similarly if `attrName` is &#39;levels&#39;.

        The first scale controls the minimum value; the second controls
        the maximum. The scales are configured so that the minimum value
        cannot exceed the maximum.

        The given `master` argument is assigned as the parent of both
        scales.

        Args:
            master (obj): The tkinter object to assign as parent.
            attrName (str): One of &#39;ranks&#39; or &#39;levels&#39;
            maxVal (int): The maximum value of the linked scales.

        Returns:
            list of tk.Scale: The two linked scales.

        &#34;&#34;&#34;
        varTuple = getattr(self.filt, attrName)
        funcs = [min, max]
        scales = [None, None]
        for j in (0, 1):
            k = 1 - j
            scales[j] = tk.Scale(
                master, variable=varTuple[j], from_=1, to=maxVal,
                length=400, orient=HORIZONTAL
            )
            scales[j].config(command=lambda val, k=k: varTuple[k].set(
                funcs[k](int(val), varTuple[k].get()))
            )
        return scales

    def buttonbox(self):
        &#34;&#34;&#34;Add a &#39;Clear All&#39; button to the button box.

        &#34;&#34;&#34;
        ModalDialog.buttonbox(self)
        self.box.pack_forget()
        tk.Button(
            self.box, text=&#34;Clear All&#34;, width=10, command=self.clear
        ).pack(side=LEFT, padx=5, pady=5)
        self.box.pack(expand=YES, fill=X)

    def clear(self):
        &#34;&#34;&#34;Reset the `filt` attribute to default values.

        &#34;&#34;&#34;
        self.filt.set(RosterFilter())

    def apply(self):
        &#34;&#34;&#34;Set the `result` attribute.

        &#34;&#34;&#34;
        self.result = self.filt

class AskMaxChars(ModalDialog):
    &#34;&#34;&#34;A modal dialog used for creating a maxed roster.

    Attributes:
        crew (tk.BooleanVar): True if the user wants to use the
            characters in the Crew screen (i.e. those that are not
            disabled).
        upcoming (tk.BooleanVar): True if the user wants to use upcoming
            characters.
        summonableOnly (tk.BooleanVar): True if the user wants to
            exclude characters that are not summonable.
        storeOnly (tk.BooleanVar): True if the user wants to exclude
            characters whose tokens are not in the daily store.
        maxGear (tk.BooleanVar): True if the user wants the maxed
            characters to also have maxed gear.
        result (tuple): ([`str`], `bool`) The first value in the tuple is
            the list of name IDs of characters the user wants to include
            in the roster. The second value is `True` if the user wants
            the maxed characters to also have maxed gear.

    &#34;&#34;&#34;
    def __init__(self, root, parent=None):
        self.crew = tk.BooleanVar(None, True)
        self.upcoming = tk.BooleanVar(None, False)
        self.summonableOnly = tk.BooleanVar(None, False)
        self.storeOnly = tk.BooleanVar(None, False)
        self.maxGear = tk.BooleanVar(None, True)
        ModalDialog.__init__(self, root, parent, &#39;Choose character options&#39;)

    def body(self, master):
        &#34;&#34;&#34;Create the body of the dialog.

        &#34;&#34;&#34;
        tk.Checkbutton(
            master, text=&#39;include characters in Crew screen&#39;,
            variable=self.crew
        ).pack(anchor=W, padx=5)
        tk.Checkbutton(
            master, text=&#39;include upcoming characters&#39;,
            variable=self.upcoming
        ).pack(anchor=W, padx=5)
        tk.Checkbutton(
            master, text=&#39;exclude non-summonable characters&#39;,
            variable=self.summonableOnly
        ).pack(anchor=W, padx=5, pady=(15,0))
        tk.Checkbutton(
            master, text=&#39;exclude characters not in daily store&#39;,
            variable=self.storeOnly
        ).pack(anchor=W, padx=5)
        tk.Checkbutton(
            master, text=&#39;equip max gear on characters&#39;,
            variable=self.maxGear
        ).pack(anchor=W, padx=5, pady=(15,0))

    def validate(self):
        &#34;&#34;&#34;Ensure that the user has selected at least one character,
        then set the result.

        &#34;&#34;&#34;
        include = ENABLED if self.crew.get() else []
        include.extend(UPCOMING if self.upcoming.get() else [])
        nameIDs = []
        for nameID in include:
            if (
                self.summonableOnly.get()
                and nameID not in SUMMON_POOL[&#39;Core&#39;][&#39;nameIDs&#39;]
            ):
                continue
            if (
                self.storeOnly.get()
                and not GSCharacter[nameID][&#39;DailyTokenVisible&#39;]
            ):
                continue
            nameIDs.append(nameID)
        if len(nameIDs) == 0:
            showerror(
                self.root, &#39;Empty Selection&#39;,
                &#39;These choices produce no characters.&#39;
            )
            return False
        self.result = nameIDs, self.maxGear.get()
        return True

class HelpScreen(ModalMessage):
    &#34;&#34;&#34;A message dialog giving help on the *STL Planner* app.

    &#34;&#34;&#34;
    def __init__(self, root, parent=None):
        ModalMessage.__init__(self, root, parent, &#39;Roster Help&#39;)

    def body(self, master):
        &#34;&#34;&#34;Create the body of the dialog.

        &#34;&#34;&#34;
        text = ScrolledText(master)
        glossary = &#39;\n&#39;.join(
            &#39;    {} = {}&#39;.format(v.rjust(3), k)
            for k,v in STAT_INITIALS.items()
        )
        glossary += (
            &#39;\n    MGL = Missing gear levels&#39;
            + &#39;\n    MGR = Missing gear ranks&#39;
            + &#39;\n    MSL = Missing skill levels&#39;
        )
        text.insert(&#39;1.0&#39;, HELP.format(glossary))
        text.config(state=DISABLED)
        text.focus()
        text.pack()

class OptimalSummons(ModalMessage):
    &#34;&#34;&#34;A message dialog showing the summon pool rates.

    Attributes:
        excludeCommons (tk.BooleanVar): `True` is the summon rate
            calculations should exclude Common characters.
        values (dict): {`str`:`tk.StringVar`} A dictionary mapping pool
            names to a formatted string representation of the average
            number of tokens per 150 orbs received from the pool.
        labels (dict): {`str`:(`tk.Label`,`tk.Label`)} A dictionary
            mapping pool names to the pair of labels associated with
            that pool in the body of the message dialog.

    &#34;&#34;&#34;
    def __init__(self, root, parent=None):
        self.excludeCommons = tk.BooleanVar(None, True)
        self.values = {}
        self.labels = {}
        for pool in SUMMON_POOL:
            self.values[pool] = tk.StringVar()
        ModalMessage.__init__(self, root, parent, &#39;Summon Rates&#39;)

    def body(self, master):
        &#34;&#34;&#34;Create the body of the dialog.

        &#34;&#34;&#34;
        tk.Label(
            master,
            text=&#39;Average Tokens per 150 Orbs&#39;,
            font=(None, 13, &#39;bold&#39;)
        ).pack(pady=(0,10))
        results = tk.Frame(master)
        results.pack()
        for row, pool in enumerate(SUMMON_POOL):
            self.labels[pool] = (
                tk.Label(
                    results, text=&#39;{} Pool:&#39;.format(pool)
                ),
                tk.Label(
                    results, textvariable=self.values[pool], width=5
                )
            )
            self.labels[pool][0].grid(row=row, column=0, sticky=W)
            self.labels[pool][1].grid(row=row, column=1, sticky=E)
        tk.Checkbutton(
            master,
            text=&#39;exclude Common characters&#39;,
            variable=self.excludeCommons, command=self.refresh
        ).pack(pady=(10,0))
        self.refresh()

    def refresh(self):
        &#34;&#34;&#34;Updates the values in the `values` attribute and sets the
        font emphasis of the labels so that the highest summon rate is
        bold and the others are normal.

        &#34;&#34;&#34;
        bestPool = &#39;&#39;
        bestPoolTokens = -1
        tokens = {}
        for pool in SUMMON_POOL:
            roster = self.root.session.saveslot.roster
            tokens[pool] = 150 * roster.tokensPerOrb(
                pool, self.excludeCommons.get()
            )
            self.values[pool].set(&#39;{:.2f}&#39;.format(tokens[pool]))
            self.setPoolEmphasis(pool, &#39;normal&#39;)
            if tokens[pool] &gt; bestPoolTokens:
                bestPool, bestPoolTokens = pool, tokens[pool]
        self.setPoolEmphasis(bestPool, &#39;bold&#39;)

    def setPoolEmphasis(self, pool, emphasis):
        &#34;&#34;&#34;Finds the labels associated with the given pool and sets
        their font to have the given emphasis.

        Args:
            pool (str): The name of a summon pool.
            emphasis (str): One of &#39;normal&#39; or &#39;bold&#39;.

        &#34;&#34;&#34;
        self.labels[pool][0].config(font=(None, 11, emphasis))
        self.labels[pool][1].config(font=(None, 11, emphasis))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="legends.ui.dialogs.addroot"><code class="name flex">
<span>def <span class="ident">addroot</span></span>(<span>func)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and returns a new function from the given function by
adding a <code>root</code> positional argument at the front, which should be
the currently running <code><a title="legends.ui.stlplanner.STLPlanner" href="stlplanner.html#legends.ui.stlplanner.STLPlanner">STLPlanner</a></code> instance.
The new function will ensure that the menus of <code>root</code> are disabled
before calling the given function, and will return the menus to
their original state after calling the given function.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addroot(func):
    &#34;&#34;&#34;Creates and returns a new function from the given function by
    adding a `root` positional argument at the front, which should be
    the currently running `legends.ui.stlplanner.STLPlanner` instance.
    The new function will ensure that the menus of `root` are disabled
    before calling the given function, and will return the menus to
    their original state after calling the given function.

    &#34;&#34;&#34;
    def newFunc(root, *args, **kargs):
        state = root.menuEnabled
        if state:
            root.menuEnabled = False
        result = func(*args, **kargs)
        if state:
            root.menuEnabled = True
        return result
    return newFunc</code></pre>
</details>
</dd>
<dt id="legends.ui.dialogs.askMaxChars"><code class="name flex">
<span>def <span class="ident">askMaxChars</span></span>(<span>root)</span>
</code></dt>
<dd>
<div class="desc"><p>Raises an <code><a title="legends.ui.dialogs.AskMaxChars" href="#legends.ui.dialogs.AskMaxChars">AskMaxChars</a></code> dialog window, prompting the user to
select from an array of options for creating a roster of maxed
characters.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>root</code></strong> :&ensp;<code><a title="legends.ui.stlplanner.STLPlanner" href="stlplanner.html#legends.ui.stlplanner.STLPlanner">STLPlanner</a></code></dt>
<dd>The currently running
<code><a title="legends.ui.stlplanner.STLPlanner" href="stlplanner.html#legends.ui.stlplanner.STLPlanner">STLPlanner</a></code> instance.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>([<code>str</code>], <code>bool</code>) The first value in the tuple is the
list of name IDs of characters the user wants to include in
the roster. The second value is <code>True</code> if the user wants the
maxed characters to also have maxed gear.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def askMaxChars(root):
    &#34;&#34;&#34;Raises an `AskMaxChars` dialog window, prompting the user to
    select from an array of options for creating a roster of maxed
    characters.

    Args:
        root (legends.ui.stlplanner.STLPlanner): The currently running
            `legends.ui.stlplanner.STLPlanner` instance.

    Returns:
        tuple: ([`str`], `bool`) The first value in the tuple is the
            list of name IDs of characters the user wants to include in
            the roster. The second value is `True` if the user wants the
            maxed characters to also have maxed gear.

    &#34;&#34;&#34;
    dialog = AskMaxChars(root)
    return dialog.result</code></pre>
</details>
</dd>
<dt id="legends.ui.dialogs.askRosterFilter"><code class="name flex">
<span>def <span class="ident">askRosterFilter</span></span>(<span>root, filt)</span>
</code></dt>
<dd>
<div class="desc"><p>Raises an <code><a title="legends.ui.dialogs.AskRosterFilter" href="#legends.ui.dialogs.AskRosterFilter">AskRosterFilter</a></code> dialog window, prompting the user to
adjust the filters for the roster tab. The dialog window is
initialized to display the filters passed by the <code>filt</code> argument.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>root</code></strong> :&ensp;<code><a title="legends.ui.stlplanner.STLPlanner" href="stlplanner.html#legends.ui.stlplanner.STLPlanner">STLPlanner</a></code></dt>
<dd>The currently running
<code><a title="legends.ui.stlplanner.STLPlanner" href="stlplanner.html#legends.ui.stlplanner.STLPlanner">STLPlanner</a></code> instance.</dd>
<dt><strong><code>filt</code></strong> :&ensp;<code><a title="legends.ui.dialogs.RosterFilter" href="#legends.ui.dialogs.RosterFilter">RosterFilter</a></code></dt>
<dd>The filter used to initialize the dialog
window. This filter is not modified.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="legends.ui.dialogs.RosterFilter" href="#legends.ui.dialogs.RosterFilter">RosterFilter</a></code> or <code>None</code></dt>
<dd>Returns a new <code><a title="legends.ui.dialogs.RosterFilter" href="#legends.ui.dialogs.RosterFilter">RosterFilter</a></code> object
representing the user's choices. Returns <code>None</code> if no
choices were confirmed.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def askRosterFilter(root, filt):
    &#34;&#34;&#34;Raises an `AskRosterFilter` dialog window, prompting the user to
    adjust the filters for the roster tab. The dialog window is
    initialized to display the filters passed by the `filt` argument.

    Args:
        root (legends.ui.stlplanner.STLPlanner): The currently running
            `legends.ui.stlplanner.STLPlanner` instance.
        filt (RosterFilter): The filter used to initialize the dialog
            window. This filter is not modified.

    Returns:
        RosterFilter or None: Returns a new `RosterFilter` object
            representing the user&#39;s choices. Returns `None` if no
            choices were confirmed.

    &#34;&#34;&#34;
    dialog = AskRosterFilter(root, filt)
    return dialog.result</code></pre>
</details>
</dd>
<dt id="legends.ui.dialogs.askSlot"><code class="name flex">
<span>def <span class="ident">askSlot</span></span>(<span>root, save)</span>
</code></dt>
<dd>
<div class="desc"><p>Raises an <code><a title="legends.ui.dialogs.AskSlot" href="#legends.ui.dialogs.AskSlot">AskSlot</a></code> dialog window, prompting the user to select a
save slot.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>root</code></strong> :&ensp;<code><a title="legends.ui.stlplanner.STLPlanner" href="stlplanner.html#legends.ui.stlplanner.STLPlanner">STLPlanner</a></code></dt>
<dd>The currently running
<code><a title="legends.ui.stlplanner.STLPlanner" href="stlplanner.html#legends.ui.stlplanner.STLPlanner">STLPlanner</a></code> instance.</dd>
<dt><strong><code>save</code></strong> :&ensp;<code>dict</code></dt>
<dd>A decrypted dictionary representation of the
player's save file, as returned by the
<code><a title="legends.savefile.decryptSaveFile" href="../savefile.html#legends.savefile.decryptSaveFile">decryptSaveFile()</a></code> function.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="legends.saveslot.SaveSlot" href="../saveslot.html#legends.saveslot.SaveSlot">SaveSlot</a></code> or <code>None</code></dt>
<dd>Returns a
<code><a title="legends.saveslot.SaveSlot" href="../saveslot.html#legends.saveslot.SaveSlot">SaveSlot</a></code> instance created from the chosen
slot number. Returns <code>None</code> if no slot was selected.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def askSlot(root, save):
    &#34;&#34;&#34;Raises an `AskSlot` dialog window, prompting the user to select a
    save slot.

    Args:
        root (legends.ui.stlplanner.STLPlanner): The currently running
            `legends.ui.stlplanner.STLPlanner` instance.
        save (dict): A decrypted dictionary representation of the
            player&#39;s save file, as returned by the
            `legends.savefile.decryptSaveFile` function.

    Returns:
        legends.saveslot.SaveSlot or None: Returns a
            `legends.saveslot.SaveSlot` instance created from the chosen
            slot number. Returns `None` if no slot was selected.

    &#34;&#34;&#34;
    dialog = AskSlot(root, save)
    return dialog.result</code></pre>
</details>
</dd>
<dt id="legends.ui.dialogs.askyesno"><code class="name flex">
<span>def <span class="ident">askyesno</span></span>(<span>root, *args, **kargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A wrapper around <code>tk.messagebox.askyesno</code> that disables the root
menu while the dialog is open.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>root</code></strong> :&ensp;<code><a title="legends.ui.stlplanner.STLPlanner" href="stlplanner.html#legends.ui.stlplanner.STLPlanner">STLPlanner</a></code></dt>
<dd>The currently running
<code><a title="legends.ui.stlplanner.STLPlanner" href="stlplanner.html#legends.ui.stlplanner.STLPlanner">STLPlanner</a></code> instance.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def askyesno(root, *args, **kargs):
    &#34;&#34;&#34;A wrapper around `tk.messagebox.askyesno` that disables the root
    menu while the dialog is open.

    Args:
        root (legends.ui.stlplanner.STLPlanner): The currently running
            `legends.ui.stlplanner.STLPlanner` instance.

    &#34;&#34;&#34;
    return addroot(_askyesno)(root, *args, **kargs)</code></pre>
</details>
</dd>
<dt id="legends.ui.dialogs.showerror"><code class="name flex">
<span>def <span class="ident">showerror</span></span>(<span>root, *args, **kargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A wrapper around <code>tk.messagebox.showerror</code> that disables the root
menu while the dialog is open.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>root</code></strong> :&ensp;<code><a title="legends.ui.stlplanner.STLPlanner" href="stlplanner.html#legends.ui.stlplanner.STLPlanner">STLPlanner</a></code></dt>
<dd>The currently running
<code><a title="legends.ui.stlplanner.STLPlanner" href="stlplanner.html#legends.ui.stlplanner.STLPlanner">STLPlanner</a></code> instance.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def showerror(root, *args, **kargs):
    &#34;&#34;&#34;A wrapper around `tk.messagebox.showerror` that disables the root
    menu while the dialog is open.

    Args:
        root (legends.ui.stlplanner.STLPlanner): The currently running
            `legends.ui.stlplanner.STLPlanner` instance.

    &#34;&#34;&#34;
    return addroot(_showerror)(root, *args, **kargs)</code></pre>
</details>
</dd>
<dt id="legends.ui.dialogs.showinfo"><code class="name flex">
<span>def <span class="ident">showinfo</span></span>(<span>root, *args, **kargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A wrapper around <code>tk.messagebox.showinfo</code> that disables the root
menu while the dialog is open.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>root</code></strong> :&ensp;<code><a title="legends.ui.stlplanner.STLPlanner" href="stlplanner.html#legends.ui.stlplanner.STLPlanner">STLPlanner</a></code></dt>
<dd>The currently running
<code><a title="legends.ui.stlplanner.STLPlanner" href="stlplanner.html#legends.ui.stlplanner.STLPlanner">STLPlanner</a></code> instance.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def showinfo(root, *args, **kargs):
    &#34;&#34;&#34;A wrapper around `tk.messagebox.showinfo` that disables the root
    menu while the dialog is open.

    Args:
        root (legends.ui.stlplanner.STLPlanner): The currently running
            `legends.ui.stlplanner.STLPlanner` instance.

    &#34;&#34;&#34;
    return addroot(_showinfo)(root, *args, **kargs)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="legends.ui.dialogs.AskMaxChars"><code class="flex name class">
<span>class <span class="ident">AskMaxChars</span></span>
<span>(</span><span>root, parent=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A modal dialog used for creating a maxed roster.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>crew</code></strong> :&ensp;<code>tk.BooleanVar</code></dt>
<dd>True if the user wants to use the
characters in the Crew screen (i.e. those that are not
disabled).</dd>
<dt><strong><code>upcoming</code></strong> :&ensp;<code>tk.BooleanVar</code></dt>
<dd>True if the user wants to use upcoming
characters.</dd>
<dt><strong><code>summonableOnly</code></strong> :&ensp;<code>tk.BooleanVar</code></dt>
<dd>True if the user wants to
exclude characters that are not summonable.</dd>
<dt><strong><code>storeOnly</code></strong> :&ensp;<code>tk.BooleanVar</code></dt>
<dd>True if the user wants to exclude
characters whose tokens are not in the daily store.</dd>
<dt><strong><code>maxGear</code></strong> :&ensp;<code>tk.BooleanVar</code></dt>
<dd>True if the user wants the maxed
characters to also have maxed gear.</dd>
<dt><strong><code>result</code></strong> :&ensp;<code>tuple</code></dt>
<dd>([<code>str</code>], <code>bool</code>) The first value in the tuple is
the list of name IDs of characters the user wants to include
in the roster. The second value is <code>True</code> if the user wants
the maxed characters to also have maxed gear.</dd>
</dl>
<p>The constructor disables the root menu before calling the
<code>tk.simpledialog.Dialog</code> constructor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AskMaxChars(ModalDialog):
    &#34;&#34;&#34;A modal dialog used for creating a maxed roster.

    Attributes:
        crew (tk.BooleanVar): True if the user wants to use the
            characters in the Crew screen (i.e. those that are not
            disabled).
        upcoming (tk.BooleanVar): True if the user wants to use upcoming
            characters.
        summonableOnly (tk.BooleanVar): True if the user wants to
            exclude characters that are not summonable.
        storeOnly (tk.BooleanVar): True if the user wants to exclude
            characters whose tokens are not in the daily store.
        maxGear (tk.BooleanVar): True if the user wants the maxed
            characters to also have maxed gear.
        result (tuple): ([`str`], `bool`) The first value in the tuple is
            the list of name IDs of characters the user wants to include
            in the roster. The second value is `True` if the user wants
            the maxed characters to also have maxed gear.

    &#34;&#34;&#34;
    def __init__(self, root, parent=None):
        self.crew = tk.BooleanVar(None, True)
        self.upcoming = tk.BooleanVar(None, False)
        self.summonableOnly = tk.BooleanVar(None, False)
        self.storeOnly = tk.BooleanVar(None, False)
        self.maxGear = tk.BooleanVar(None, True)
        ModalDialog.__init__(self, root, parent, &#39;Choose character options&#39;)

    def body(self, master):
        &#34;&#34;&#34;Create the body of the dialog.

        &#34;&#34;&#34;
        tk.Checkbutton(
            master, text=&#39;include characters in Crew screen&#39;,
            variable=self.crew
        ).pack(anchor=W, padx=5)
        tk.Checkbutton(
            master, text=&#39;include upcoming characters&#39;,
            variable=self.upcoming
        ).pack(anchor=W, padx=5)
        tk.Checkbutton(
            master, text=&#39;exclude non-summonable characters&#39;,
            variable=self.summonableOnly
        ).pack(anchor=W, padx=5, pady=(15,0))
        tk.Checkbutton(
            master, text=&#39;exclude characters not in daily store&#39;,
            variable=self.storeOnly
        ).pack(anchor=W, padx=5)
        tk.Checkbutton(
            master, text=&#39;equip max gear on characters&#39;,
            variable=self.maxGear
        ).pack(anchor=W, padx=5, pady=(15,0))

    def validate(self):
        &#34;&#34;&#34;Ensure that the user has selected at least one character,
        then set the result.

        &#34;&#34;&#34;
        include = ENABLED if self.crew.get() else []
        include.extend(UPCOMING if self.upcoming.get() else [])
        nameIDs = []
        for nameID in include:
            if (
                self.summonableOnly.get()
                and nameID not in SUMMON_POOL[&#39;Core&#39;][&#39;nameIDs&#39;]
            ):
                continue
            if (
                self.storeOnly.get()
                and not GSCharacter[nameID][&#39;DailyTokenVisible&#39;]
            ):
                continue
            nameIDs.append(nameID)
        if len(nameIDs) == 0:
            showerror(
                self.root, &#39;Empty Selection&#39;,
                &#39;These choices produce no characters.&#39;
            )
            return False
        self.result = nameIDs, self.maxGear.get()
        return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="legends.ui.dialogs.ModalDialog" href="#legends.ui.dialogs.ModalDialog">ModalDialog</a></li>
<li><a title="legends.ui.dialogs.ModalMessage" href="#legends.ui.dialogs.ModalMessage">ModalMessage</a></li>
<li>tkinter.simpledialog.Dialog</li>
<li>tkinter.Toplevel</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Wm</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="legends.ui.dialogs.AskMaxChars.body"><code class="name flex">
<span>def <span class="ident">body</span></span>(<span>self, master)</span>
</code></dt>
<dd>
<div class="desc"><p>Create the body of the dialog.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def body(self, master):
    &#34;&#34;&#34;Create the body of the dialog.

    &#34;&#34;&#34;
    tk.Checkbutton(
        master, text=&#39;include characters in Crew screen&#39;,
        variable=self.crew
    ).pack(anchor=W, padx=5)
    tk.Checkbutton(
        master, text=&#39;include upcoming characters&#39;,
        variable=self.upcoming
    ).pack(anchor=W, padx=5)
    tk.Checkbutton(
        master, text=&#39;exclude non-summonable characters&#39;,
        variable=self.summonableOnly
    ).pack(anchor=W, padx=5, pady=(15,0))
    tk.Checkbutton(
        master, text=&#39;exclude characters not in daily store&#39;,
        variable=self.storeOnly
    ).pack(anchor=W, padx=5)
    tk.Checkbutton(
        master, text=&#39;equip max gear on characters&#39;,
        variable=self.maxGear
    ).pack(anchor=W, padx=5, pady=(15,0))</code></pre>
</details>
</dd>
<dt id="legends.ui.dialogs.AskMaxChars.validate"><code class="name flex">
<span>def <span class="ident">validate</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Ensure that the user has selected at least one character,
then set the result.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate(self):
    &#34;&#34;&#34;Ensure that the user has selected at least one character,
    then set the result.

    &#34;&#34;&#34;
    include = ENABLED if self.crew.get() else []
    include.extend(UPCOMING if self.upcoming.get() else [])
    nameIDs = []
    for nameID in include:
        if (
            self.summonableOnly.get()
            and nameID not in SUMMON_POOL[&#39;Core&#39;][&#39;nameIDs&#39;]
        ):
            continue
        if (
            self.storeOnly.get()
            and not GSCharacter[nameID][&#39;DailyTokenVisible&#39;]
        ):
            continue
        nameIDs.append(nameID)
    if len(nameIDs) == 0:
        showerror(
            self.root, &#39;Empty Selection&#39;,
            &#39;These choices produce no characters.&#39;
        )
        return False
    self.result = nameIDs, self.maxGear.get()
    return True</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="legends.ui.dialogs.ModalDialog" href="#legends.ui.dialogs.ModalDialog">ModalDialog</a></b></code>:
<ul class="hlist">
<li><code><a title="legends.ui.dialogs.ModalDialog.buttonbox" href="#legends.ui.dialogs.ModalDialog.buttonbox">buttonbox</a></code></li>
<li><code><a title="legends.ui.dialogs.ModalDialog.destroy" href="#legends.ui.dialogs.ModalMessage.destroy">destroy</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="legends.ui.dialogs.AskRosterFilter"><code class="flex name class">
<span>class <span class="ident">AskRosterFilter</span></span>
<span>(</span><span>root, rosterFilter, parent=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A modal dialog used for adjusting <code><a title="legends.ui.dialogs.RosterFilter" href="#legends.ui.dialogs.RosterFilter">RosterFilter</a></code> objects.</p>
<p>The constructor must be given a <code><a title="legends.ui.dialogs.RosterFilter" href="#legends.ui.dialogs.RosterFilter">RosterFilter</a></code> object. That object
will be used to initialize the window, but will not be modified.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>filt</code></strong> :&ensp;<code><a title="legends.ui.dialogs.RosterFilter" href="#legends.ui.dialogs.RosterFilter">RosterFilter</a></code></dt>
<dd>The <code><a title="legends.ui.dialogs.RosterFilter" href="#legends.ui.dialogs.RosterFilter">RosterFilter</a></code> object controlled and
modified by the dialog window.</dd>
<dt><strong><code>result</code></strong> :&ensp;<code><a title="legends.ui.dialogs.RosterFilter" href="#legends.ui.dialogs.RosterFilter">RosterFilter</a></code> or <code>None</code></dt>
<dd>Inherited from <code><a title="legends.ui.dialogs.ModalDialog" href="#legends.ui.dialogs.ModalDialog">ModalDialog</a></code>,
which inherited it from <code>tk.simpledialog.Dialog</code>. Defaults
to <code>None</code>. Is set by the <code><a title="legends.ui.dialogs.AskRosterFilter.apply" href="#legends.ui.dialogs.AskRosterFilter.apply">AskRosterFilter.apply()</a></code> method to
the value of the <code>filt</code> attribute.</dd>
</dl>
<p>The constructor sets the <code>filt</code> attribute, then calls the
<code><a title="legends.ui.dialogs.ModalDialog" href="#legends.ui.dialogs.ModalDialog">ModalDialog</a></code> constructor.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>root</code></strong> :&ensp;<code><a title="legends.ui.stlplanner.STLPlanner" href="stlplanner.html#legends.ui.stlplanner.STLPlanner">STLPlanner</a></code></dt>
<dd>The currently
running <code><a title="legends.ui.stlplanner.STLPlanner" href="stlplanner.html#legends.ui.stlplanner.STLPlanner">STLPlanner</a></code> instance.
Passed to the <code><a title="legends.ui.dialogs.ModalDialog" href="#legends.ui.dialogs.ModalDialog">ModalDialog</a></code> constructor.</dd>
<dt><strong><code>rosterFilter</code></strong> :&ensp;<code><a title="legends.ui.dialogs.RosterFilter" href="#legends.ui.dialogs.RosterFilter">RosterFilter</a></code></dt>
<dd>The instance's <code>filt</code> attribute
is assigned a copy of this argument.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AskRosterFilter(ModalDialog):
    &#34;&#34;&#34;A modal dialog used for adjusting `RosterFilter` objects.

    The constructor must be given a `RosterFilter` object. That object
    will be used to initialize the window, but will not be modified.

    Attributes:
        filt (RosterFilter): The `RosterFilter` object controlled and
            modified by the dialog window.
        result (RosterFilter or None): Inherited from `ModalDialog`,
            which inherited it from `tk.simpledialog.Dialog`. Defaults
            to `None`. Is set by the `AskRosterFilter.apply` method to
            the value of the `filt` attribute.

    &#34;&#34;&#34;
    def __init__(self, root, rosterFilter, parent=None):
        &#34;&#34;&#34;The constructor sets the `filt` attribute, then calls the
        `ModalDialog` constructor.

        Args:
            root (legends.ui.stlplanner.STLPlanner): The currently
                running `legends.ui.stlplanner.STLPlanner` instance.
                Passed to the `ModalDialog` constructor.
            rosterFilter (RosterFilter): The instance&#39;s `filt` attribute
                is assigned a copy of this argument.

        &#34;&#34;&#34;
        self.filt = RosterFilter(rosterFilter)
        ModalDialog.__init__(self, root, parent, &#39;Filter characters&#39;)

    def body(self, master):
        &#34;&#34;&#34;Create the body of the dialog.

        &#34;&#34;&#34;
        widgets = {}

        # create the rarity and role checkboxes
        widgets[&#39;rarityCheckboxes&#39;] = tk.Frame(master)
        for rarity in RARITIES:
            tk.Checkbutton(
                widgets[&#39;rarityCheckboxes&#39;], text=rarity,
                variable=self.filt.rarities[rarity]
            ).pack(side=LEFT)
        widgets[&#39;roleCheckboxes&#39;] = tk.Frame(master)
        for role in ROLES:
            tk.Checkbutton(
                widgets[&#39;roleCheckboxes&#39;], text=role,
                variable=self.filt.roles[role]
            ).pack(side=LEFT)

        # create the rank and level linked scales
        widgets[&#39;rankMinScale&#39;], widgets[&#39;rankMaxScale&#39;] = (
            self.makeLinkedScales(master, &#39;ranks&#39;, 9)
        )
        widgets[&#39;levelMinScale&#39;], widgets[&#39;levelMaxScale&#39;] = (
            self.makeLinkedScales(master, &#39;levels&#39;, 99)
        )

        # grid the body content
        labels = [
            &#39;Rarity:&#39;, &#39;Role:&#39;,
            &#39;Min rank:&#39;, &#39;Max rank:&#39;, &#39;Min level:&#39;, &#39;Max level:&#39;
        ]
        for row, label, widget in zip(range(6), labels, widgets.values()):
            tk.Label(master, text=label, font=(None, 13, &#39;bold&#39;)).grid(
                row=row, column=0, sticky=E
            )
            widget.grid(row=row, column=1, sticky=W)

    def makeLinkedScales(self, master, attrName, maxVal):
        &#34;&#34;&#34;Creates and returns a pair of linked Scale widgets. Each
        scale has values from 1 to `maxVal`. If `attrName` is &#39;ranks&#39;,
        the scales are associated with the `tkinter` variables stored in
        the `ranks` attribute of the calling instance&#39;s `filt`
        attribute. Similarly if `attrName` is &#39;levels&#39;.

        The first scale controls the minimum value; the second controls
        the maximum. The scales are configured so that the minimum value
        cannot exceed the maximum.

        The given `master` argument is assigned as the parent of both
        scales.

        Args:
            master (obj): The tkinter object to assign as parent.
            attrName (str): One of &#39;ranks&#39; or &#39;levels&#39;
            maxVal (int): The maximum value of the linked scales.

        Returns:
            list of tk.Scale: The two linked scales.

        &#34;&#34;&#34;
        varTuple = getattr(self.filt, attrName)
        funcs = [min, max]
        scales = [None, None]
        for j in (0, 1):
            k = 1 - j
            scales[j] = tk.Scale(
                master, variable=varTuple[j], from_=1, to=maxVal,
                length=400, orient=HORIZONTAL
            )
            scales[j].config(command=lambda val, k=k: varTuple[k].set(
                funcs[k](int(val), varTuple[k].get()))
            )
        return scales

    def buttonbox(self):
        &#34;&#34;&#34;Add a &#39;Clear All&#39; button to the button box.

        &#34;&#34;&#34;
        ModalDialog.buttonbox(self)
        self.box.pack_forget()
        tk.Button(
            self.box, text=&#34;Clear All&#34;, width=10, command=self.clear
        ).pack(side=LEFT, padx=5, pady=5)
        self.box.pack(expand=YES, fill=X)

    def clear(self):
        &#34;&#34;&#34;Reset the `filt` attribute to default values.

        &#34;&#34;&#34;
        self.filt.set(RosterFilter())

    def apply(self):
        &#34;&#34;&#34;Set the `result` attribute.

        &#34;&#34;&#34;
        self.result = self.filt</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="legends.ui.dialogs.ModalDialog" href="#legends.ui.dialogs.ModalDialog">ModalDialog</a></li>
<li><a title="legends.ui.dialogs.ModalMessage" href="#legends.ui.dialogs.ModalMessage">ModalMessage</a></li>
<li>tkinter.simpledialog.Dialog</li>
<li>tkinter.Toplevel</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Wm</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="legends.ui.dialogs.AskRosterFilter.apply"><code class="name flex">
<span>def <span class="ident">apply</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the <code>result</code> attribute.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply(self):
    &#34;&#34;&#34;Set the `result` attribute.

    &#34;&#34;&#34;
    self.result = self.filt</code></pre>
</details>
</dd>
<dt id="legends.ui.dialogs.AskRosterFilter.body"><code class="name flex">
<span>def <span class="ident">body</span></span>(<span>self, master)</span>
</code></dt>
<dd>
<div class="desc"><p>Create the body of the dialog.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def body(self, master):
    &#34;&#34;&#34;Create the body of the dialog.

    &#34;&#34;&#34;
    widgets = {}

    # create the rarity and role checkboxes
    widgets[&#39;rarityCheckboxes&#39;] = tk.Frame(master)
    for rarity in RARITIES:
        tk.Checkbutton(
            widgets[&#39;rarityCheckboxes&#39;], text=rarity,
            variable=self.filt.rarities[rarity]
        ).pack(side=LEFT)
    widgets[&#39;roleCheckboxes&#39;] = tk.Frame(master)
    for role in ROLES:
        tk.Checkbutton(
            widgets[&#39;roleCheckboxes&#39;], text=role,
            variable=self.filt.roles[role]
        ).pack(side=LEFT)

    # create the rank and level linked scales
    widgets[&#39;rankMinScale&#39;], widgets[&#39;rankMaxScale&#39;] = (
        self.makeLinkedScales(master, &#39;ranks&#39;, 9)
    )
    widgets[&#39;levelMinScale&#39;], widgets[&#39;levelMaxScale&#39;] = (
        self.makeLinkedScales(master, &#39;levels&#39;, 99)
    )

    # grid the body content
    labels = [
        &#39;Rarity:&#39;, &#39;Role:&#39;,
        &#39;Min rank:&#39;, &#39;Max rank:&#39;, &#39;Min level:&#39;, &#39;Max level:&#39;
    ]
    for row, label, widget in zip(range(6), labels, widgets.values()):
        tk.Label(master, text=label, font=(None, 13, &#39;bold&#39;)).grid(
            row=row, column=0, sticky=E
        )
        widget.grid(row=row, column=1, sticky=W)</code></pre>
</details>
</dd>
<dt id="legends.ui.dialogs.AskRosterFilter.buttonbox"><code class="name flex">
<span>def <span class="ident">buttonbox</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a 'Clear All' button to the button box.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def buttonbox(self):
    &#34;&#34;&#34;Add a &#39;Clear All&#39; button to the button box.

    &#34;&#34;&#34;
    ModalDialog.buttonbox(self)
    self.box.pack_forget()
    tk.Button(
        self.box, text=&#34;Clear All&#34;, width=10, command=self.clear
    ).pack(side=LEFT, padx=5, pady=5)
    self.box.pack(expand=YES, fill=X)</code></pre>
</details>
</dd>
<dt id="legends.ui.dialogs.AskRosterFilter.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Reset the <code>filt</code> attribute to default values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self):
    &#34;&#34;&#34;Reset the `filt` attribute to default values.

    &#34;&#34;&#34;
    self.filt.set(RosterFilter())</code></pre>
</details>
</dd>
<dt id="legends.ui.dialogs.AskRosterFilter.makeLinkedScales"><code class="name flex">
<span>def <span class="ident">makeLinkedScales</span></span>(<span>self, master, attrName, maxVal)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and returns a pair of linked Scale widgets. Each
scale has values from 1 to <code>maxVal</code>. If <code>attrName</code> is 'ranks',
the scales are associated with the <code>tkinter</code> variables stored in
the <code>ranks</code> attribute of the calling instance's <code>filt</code>
attribute. Similarly if <code>attrName</code> is 'levels'.</p>
<p>The first scale controls the minimum value; the second controls
the maximum. The scales are configured so that the minimum value
cannot exceed the maximum.</p>
<p>The given <code>master</code> argument is assigned as the parent of both
scales.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>master</code></strong> :&ensp;<code>obj</code></dt>
<dd>The tkinter object to assign as parent.</dd>
<dt><strong><code>attrName</code></strong> :&ensp;<code>str</code></dt>
<dd>One of 'ranks' or 'levels'</dd>
<dt><strong><code>maxVal</code></strong> :&ensp;<code>int</code></dt>
<dd>The maximum value of the linked scales.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code> of <code>tk.Scale</code></dt>
<dd>The two linked scales.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def makeLinkedScales(self, master, attrName, maxVal):
    &#34;&#34;&#34;Creates and returns a pair of linked Scale widgets. Each
    scale has values from 1 to `maxVal`. If `attrName` is &#39;ranks&#39;,
    the scales are associated with the `tkinter` variables stored in
    the `ranks` attribute of the calling instance&#39;s `filt`
    attribute. Similarly if `attrName` is &#39;levels&#39;.

    The first scale controls the minimum value; the second controls
    the maximum. The scales are configured so that the minimum value
    cannot exceed the maximum.

    The given `master` argument is assigned as the parent of both
    scales.

    Args:
        master (obj): The tkinter object to assign as parent.
        attrName (str): One of &#39;ranks&#39; or &#39;levels&#39;
        maxVal (int): The maximum value of the linked scales.

    Returns:
        list of tk.Scale: The two linked scales.

    &#34;&#34;&#34;
    varTuple = getattr(self.filt, attrName)
    funcs = [min, max]
    scales = [None, None]
    for j in (0, 1):
        k = 1 - j
        scales[j] = tk.Scale(
            master, variable=varTuple[j], from_=1, to=maxVal,
            length=400, orient=HORIZONTAL
        )
        scales[j].config(command=lambda val, k=k: varTuple[k].set(
            funcs[k](int(val), varTuple[k].get()))
        )
    return scales</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="legends.ui.dialogs.ModalDialog" href="#legends.ui.dialogs.ModalDialog">ModalDialog</a></b></code>:
<ul class="hlist">
<li><code><a title="legends.ui.dialogs.ModalDialog.destroy" href="#legends.ui.dialogs.ModalMessage.destroy">destroy</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="legends.ui.dialogs.AskSlot"><code class="flex name class">
<span>class <span class="ident">AskSlot</span></span>
<span>(</span><span>root, save, parent=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A modal dialog that prompts the user to select a save slot.</p>
<p>Save slots are denoted in the game data as 0, 1, or 2. In the
<code><a title="legends.ui.dialogs.AskSlot" href="#legends.ui.dialogs.AskSlot">AskSlot</a></code> window, they are shown to the user as '1', '2', or '3'.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>save</code></strong> :&ensp;<code>dict</code></dt>
<dd>A decrypted dictionary representation of the
player's save file, as returned by the
<code><a title="legends.savefile.decryptSaveFile" href="../savefile.html#legends.savefile.decryptSaveFile">decryptSaveFile()</a></code> function.</dd>
<dt><strong><code>displaySlot</code></strong> :&ensp;<code>tk.StringVar</code></dt>
<dd>The currently selected slot, as it
is displayed in the window.</dd>
<dt><strong><code>result</code></strong> :&ensp;<code>SaveSlot</code> or <code>None</code></dt>
<dd>Inherited from <code><a title="legends.ui.dialogs.ModalDialog" href="#legends.ui.dialogs.ModalDialog">ModalDialog</a></code>, which
inherited it from <code>tk.simpledialog.Dialog</code>. Defaults to
<code>None</code>. Is set by the <code><a title="legends.ui.dialogs.AskSlot.validate" href="#legends.ui.dialogs.AskSlot.validate">AskSlot.validate()</a></code> method to a
<code>SaveSlot</code> instance created from the chosen slot number.</dd>
</dl>
<p>The constructor disables the root menu before calling the
<code>tk.simpledialog.Dialog</code> constructor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AskSlot(ModalDialog):
    &#34;&#34;&#34;A modal dialog that prompts the user to select a save slot.

    Save slots are denoted in the game data as 0, 1, or 2. In the
    `AskSlot` window, they are shown to the user as &#39;1&#39;, &#39;2&#39;, or &#39;3&#39;.

    Attributes:
        save (dict): A decrypted dictionary representation of the
            player&#39;s save file, as returned by the
            `legends.savefile.decryptSaveFile` function.
        displaySlot (tk.StringVar): The currently selected slot, as it
            is displayed in the window.
        result (SaveSlot or None): Inherited from `ModalDialog`, which
            inherited it from `tk.simpledialog.Dialog`. Defaults to
            `None`. Is set by the `AskSlot.validate` method to a
            `SaveSlot` instance created from the chosen slot number.

    &#34;&#34;&#34;
    def __init__(self, root, save, parent=None):
        self.save = save
        self.displaySlot = tk.StringVar(None, &#39;1&#39;)
        ModalDialog.__init__(self, root, parent, &#39;Choose a save slot&#39;)

    def body(self, master):
        &#34;&#34;&#34;Create the body of the dialog.

        &#34;&#34;&#34;
        # create an informational label
        msg = (
            &#34;Open Star Trek: Legends on this Mac and let it load to the &#34;
            + &#34;splash screen. This will allow your cloud save to sync to &#34;
            + &#34;the local hard drive. Then choose the save slot data you would &#34;
            + &#34;like to use.&#34;
        )
        tk.Label(master, wraplength=250, justify=LEFT, text=msg).pack()

        # create the subframe used for selecting the slot
        slotBar = tk.Frame(master)
        tk.Label(slotBar, text=&#39;Extract from save slot:&#39;).pack(side=LEFT)
        cbox = ttk.Combobox(
            slotBar,
            textvariable=self.displaySlot,
            values=[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;],
            state=&#39;readonly&#39;,
            width=1
        )
        cbox.pack()

        # pack the subframe and return the combobox for focus
        slotBar.pack(pady=10)
        return cbox

    def validate(self):
        &#34;&#34;&#34;Set the `result` attribute and return `True`.

        &#34;&#34;&#34;
        slot = int(self.displaySlot.get()) - 1
        key = &#39;{} data&#39;.format(slot)
        if key not in self.save or not self.save[key]:
            showerror(
                self.root,
                &#39;Slot Error&#39;,
                &#39;No save data found in slot {}.&#39;.format(slot + 1)
            )
            return False
        self.result = SaveSlot()
        self.result.fromFile(self.save, slot)
        return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="legends.ui.dialogs.ModalDialog" href="#legends.ui.dialogs.ModalDialog">ModalDialog</a></li>
<li><a title="legends.ui.dialogs.ModalMessage" href="#legends.ui.dialogs.ModalMessage">ModalMessage</a></li>
<li>tkinter.simpledialog.Dialog</li>
<li>tkinter.Toplevel</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Wm</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="legends.ui.dialogs.AskSlot.body"><code class="name flex">
<span>def <span class="ident">body</span></span>(<span>self, master)</span>
</code></dt>
<dd>
<div class="desc"><p>Create the body of the dialog.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def body(self, master):
    &#34;&#34;&#34;Create the body of the dialog.

    &#34;&#34;&#34;
    # create an informational label
    msg = (
        &#34;Open Star Trek: Legends on this Mac and let it load to the &#34;
        + &#34;splash screen. This will allow your cloud save to sync to &#34;
        + &#34;the local hard drive. Then choose the save slot data you would &#34;
        + &#34;like to use.&#34;
    )
    tk.Label(master, wraplength=250, justify=LEFT, text=msg).pack()

    # create the subframe used for selecting the slot
    slotBar = tk.Frame(master)
    tk.Label(slotBar, text=&#39;Extract from save slot:&#39;).pack(side=LEFT)
    cbox = ttk.Combobox(
        slotBar,
        textvariable=self.displaySlot,
        values=[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;],
        state=&#39;readonly&#39;,
        width=1
    )
    cbox.pack()

    # pack the subframe and return the combobox for focus
    slotBar.pack(pady=10)
    return cbox</code></pre>
</details>
</dd>
<dt id="legends.ui.dialogs.AskSlot.validate"><code class="name flex">
<span>def <span class="ident">validate</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the <code>result</code> attribute and return <code>True</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate(self):
    &#34;&#34;&#34;Set the `result` attribute and return `True`.

    &#34;&#34;&#34;
    slot = int(self.displaySlot.get()) - 1
    key = &#39;{} data&#39;.format(slot)
    if key not in self.save or not self.save[key]:
        showerror(
            self.root,
            &#39;Slot Error&#39;,
            &#39;No save data found in slot {}.&#39;.format(slot + 1)
        )
        return False
    self.result = SaveSlot()
    self.result.fromFile(self.save, slot)
    return True</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="legends.ui.dialogs.ModalDialog" href="#legends.ui.dialogs.ModalDialog">ModalDialog</a></b></code>:
<ul class="hlist">
<li><code><a title="legends.ui.dialogs.ModalDialog.buttonbox" href="#legends.ui.dialogs.ModalDialog.buttonbox">buttonbox</a></code></li>
<li><code><a title="legends.ui.dialogs.ModalDialog.destroy" href="#legends.ui.dialogs.ModalMessage.destroy">destroy</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="legends.ui.dialogs.HelpScreen"><code class="flex name class">
<span>class <span class="ident">HelpScreen</span></span>
<span>(</span><span>root, parent=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A message dialog giving help on the <em>STL Planner</em> app.</p>
<p>The constructor disables the root menu before calling the
<code>tk.simpledialog.Dialog</code> constructor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HelpScreen(ModalMessage):
    &#34;&#34;&#34;A message dialog giving help on the *STL Planner* app.

    &#34;&#34;&#34;
    def __init__(self, root, parent=None):
        ModalMessage.__init__(self, root, parent, &#39;Roster Help&#39;)

    def body(self, master):
        &#34;&#34;&#34;Create the body of the dialog.

        &#34;&#34;&#34;
        text = ScrolledText(master)
        glossary = &#39;\n&#39;.join(
            &#39;    {} = {}&#39;.format(v.rjust(3), k)
            for k,v in STAT_INITIALS.items()
        )
        glossary += (
            &#39;\n    MGL = Missing gear levels&#39;
            + &#39;\n    MGR = Missing gear ranks&#39;
            + &#39;\n    MSL = Missing skill levels&#39;
        )
        text.insert(&#39;1.0&#39;, HELP.format(glossary))
        text.config(state=DISABLED)
        text.focus()
        text.pack()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="legends.ui.dialogs.ModalMessage" href="#legends.ui.dialogs.ModalMessage">ModalMessage</a></li>
<li>tkinter.simpledialog.Dialog</li>
<li>tkinter.Toplevel</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Wm</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="legends.ui.dialogs.HelpScreen.body"><code class="name flex">
<span>def <span class="ident">body</span></span>(<span>self, master)</span>
</code></dt>
<dd>
<div class="desc"><p>Create the body of the dialog.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def body(self, master):
    &#34;&#34;&#34;Create the body of the dialog.

    &#34;&#34;&#34;
    text = ScrolledText(master)
    glossary = &#39;\n&#39;.join(
        &#39;    {} = {}&#39;.format(v.rjust(3), k)
        for k,v in STAT_INITIALS.items()
    )
    glossary += (
        &#39;\n    MGL = Missing gear levels&#39;
        + &#39;\n    MGR = Missing gear ranks&#39;
        + &#39;\n    MSL = Missing skill levels&#39;
    )
    text.insert(&#39;1.0&#39;, HELP.format(glossary))
    text.config(state=DISABLED)
    text.focus()
    text.pack()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="legends.ui.dialogs.ModalMessage" href="#legends.ui.dialogs.ModalMessage">ModalMessage</a></b></code>:
<ul class="hlist">
<li><code><a title="legends.ui.dialogs.ModalMessage.buttonbox" href="#legends.ui.dialogs.ModalMessage.buttonbox">buttonbox</a></code></li>
<li><code><a title="legends.ui.dialogs.ModalMessage.destroy" href="#legends.ui.dialogs.ModalMessage.destroy">destroy</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="legends.ui.dialogs.ModalDialog"><code class="flex name class">
<span>class <span class="ident">ModalDialog</span></span>
<span>(</span><span>root, parent=None, title=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A subclass of <code><a title="legends.ui.dialogs.ModalMessage" href="#legends.ui.dialogs.ModalMessage">ModalMessage</a></code> that has a 'Cancel' button.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>root</code></strong> :&ensp;<code><a title="legends.ui.stlplanner.STLPlanner" href="stlplanner.html#legends.ui.stlplanner.STLPlanner">STLPlanner</a></code></dt>
<dd>The currently running
<code><a title="legends.ui.stlplanner.STLPlanner" href="stlplanner.html#legends.ui.stlplanner.STLPlanner">STLPlanner</a></code> instance.</dd>
<dt><strong><code>initialMenuState</code></strong> :&ensp;<code>bool</code></dt>
<dd><code>True</code> if the root menu is enabled at
the moment the dialog opens.</dd>
<dt><strong><code>box</code></strong> :&ensp;<code>tk.Frame</code></dt>
<dd>The frame that holds the 'OK' and 'Cancel'
buttons.</dd>
</dl>
<p>The constructor disables the root menu before calling the
<code>tk.simpledialog.Dialog</code> constructor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ModalDialog(ModalMessage):
    &#34;&#34;&#34;A subclass of `ModalMessage` that has a &#39;Cancel&#39; button.

    Attributes:
        root (legends.ui.stlplanner.STLPlanner): The currently running
            `legends.ui.stlplanner.STLPlanner` instance.
        initialMenuState (bool): `True` if the root menu is enabled at
            the moment the dialog opens.
        box (tk.Frame): The frame that holds the &#39;OK&#39; and &#39;Cancel&#39;
            buttons.

    &#34;&#34;&#34;
    def __init__(self, root, parent=None, title=None):
        ModalMessage.__init__(self, root, parent, title)

    def buttonbox(self):
        &#34;&#34;&#34;Adds the standard &#39;Cancel&#39; button of the
        `tk.simpledialog.Dialog` class.

        &#34;&#34;&#34;
        ModalMessage.buttonbox(self)

        tk.Button(
            self.box, text=&#34;Cancel&#34;, width=10, command=self.cancel
        ).pack(side=RIGHT, padx=5, pady=5)

        self.bind(&#34;&lt;Escape&gt;&#34;, self.cancel)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="legends.ui.dialogs.ModalMessage" href="#legends.ui.dialogs.ModalMessage">ModalMessage</a></li>
<li>tkinter.simpledialog.Dialog</li>
<li>tkinter.Toplevel</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Wm</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="legends.ui.dialogs.AskMaxChars" href="#legends.ui.dialogs.AskMaxChars">AskMaxChars</a></li>
<li><a title="legends.ui.dialogs.AskRosterFilter" href="#legends.ui.dialogs.AskRosterFilter">AskRosterFilter</a></li>
<li><a title="legends.ui.dialogs.AskSlot" href="#legends.ui.dialogs.AskSlot">AskSlot</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="legends.ui.dialogs.ModalDialog.buttonbox"><code class="name flex">
<span>def <span class="ident">buttonbox</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds the standard 'Cancel' button of the
<code>tk.simpledialog.Dialog</code> class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def buttonbox(self):
    &#34;&#34;&#34;Adds the standard &#39;Cancel&#39; button of the
    `tk.simpledialog.Dialog` class.

    &#34;&#34;&#34;
    ModalMessage.buttonbox(self)

    tk.Button(
        self.box, text=&#34;Cancel&#34;, width=10, command=self.cancel
    ).pack(side=RIGHT, padx=5, pady=5)

    self.bind(&#34;&lt;Escape&gt;&#34;, self.cancel)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="legends.ui.dialogs.ModalMessage" href="#legends.ui.dialogs.ModalMessage">ModalMessage</a></b></code>:
<ul class="hlist">
<li><code><a title="legends.ui.dialogs.ModalMessage.destroy" href="#legends.ui.dialogs.ModalMessage.destroy">destroy</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="legends.ui.dialogs.ModalMessage"><code class="flex name class">
<span>class <span class="ident">ModalMessage</span></span>
<span>(</span><span>root, parent=None, title=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A subclass of <code>tk.simpledialog.Dialog</code> that disables menus. Has
an 'OK' button, but no 'Cancel' button.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>root</code></strong> :&ensp;<code><a title="legends.ui.stlplanner.STLPlanner" href="stlplanner.html#legends.ui.stlplanner.STLPlanner">STLPlanner</a></code></dt>
<dd>The currently running
<code><a title="legends.ui.stlplanner.STLPlanner" href="stlplanner.html#legends.ui.stlplanner.STLPlanner">STLPlanner</a></code> instance.</dd>
<dt><strong><code>initialMenuState</code></strong> :&ensp;<code>bool</code></dt>
<dd><code>True</code> if the root menu is enabled at
the moment the dialog opens.</dd>
<dt><strong><code>box</code></strong> :&ensp;<code>tk.Frame</code></dt>
<dd>The frame that holds the buttons.</dd>
</dl>
<p>The constructor disables the root menu before calling the
<code>tk.simpledialog.Dialog</code> constructor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ModalMessage(Dialog):
    &#34;&#34;&#34;A subclass of `tk.simpledialog.Dialog` that disables menus. Has
    an &#39;OK&#39; button, but no &#39;Cancel&#39; button.

    Attributes:
        root (legends.ui.stlplanner.STLPlanner): The currently running
            `legends.ui.stlplanner.STLPlanner` instance.
        initialMenuState (bool): `True` if the root menu is enabled at
            the moment the dialog opens.
        box (tk.Frame): The frame that holds the buttons.

    &#34;&#34;&#34;
    def __init__(self, root, parent=None, title=None):
        &#34;&#34;&#34;The constructor disables the root menu before calling the
        `tk.simpledialog.Dialog` constructor.

        &#34;&#34;&#34;
        self.root = root
        self.initialMenuState = self.root.menuEnabled
        if self.initialMenuState:
            self.root.menuEnabled = False
        if parent is None:
            parent = tk._default_root
        Dialog.__init__(self, parent, title)

    def buttonbox(self):
        &#34;&#34;&#34;Builds the standard &#39;OK&#39; button of the
        `tk.simpledialog.Dialog` class.

        &#34;&#34;&#34;
        self.box = tk.Frame(self)

        tk.Button(
            self.box, text=&#34;OK&#34;, width=10, command=self.ok, default=ACTIVE
        ).pack(side=RIGHT, padx=5, pady=5)

        self.bind(&#34;&lt;Return&gt;&#34;, self.ok)

        self.box.pack()

    def destroy(self):
        &#34;&#34;&#34;Restores root menu options to their original state, then
        destroys the window.

        &#34;&#34;&#34;
        self.initial_focus = None
        if self.initialMenuState:
            self.root.menuEnabled = True
        tk.Toplevel.destroy(self)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tkinter.simpledialog.Dialog</li>
<li>tkinter.Toplevel</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Wm</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="legends.ui.dialogs.HelpScreen" href="#legends.ui.dialogs.HelpScreen">HelpScreen</a></li>
<li><a title="legends.ui.dialogs.ModalDialog" href="#legends.ui.dialogs.ModalDialog">ModalDialog</a></li>
<li><a title="legends.ui.dialogs.OptimalSummons" href="#legends.ui.dialogs.OptimalSummons">OptimalSummons</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="legends.ui.dialogs.ModalMessage.buttonbox"><code class="name flex">
<span>def <span class="ident">buttonbox</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Builds the standard 'OK' button of the
<code>tk.simpledialog.Dialog</code> class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def buttonbox(self):
    &#34;&#34;&#34;Builds the standard &#39;OK&#39; button of the
    `tk.simpledialog.Dialog` class.

    &#34;&#34;&#34;
    self.box = tk.Frame(self)

    tk.Button(
        self.box, text=&#34;OK&#34;, width=10, command=self.ok, default=ACTIVE
    ).pack(side=RIGHT, padx=5, pady=5)

    self.bind(&#34;&lt;Return&gt;&#34;, self.ok)

    self.box.pack()</code></pre>
</details>
</dd>
<dt id="legends.ui.dialogs.ModalMessage.destroy"><code class="name flex">
<span>def <span class="ident">destroy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Restores root menu options to their original state, then
destroys the window.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def destroy(self):
    &#34;&#34;&#34;Restores root menu options to their original state, then
    destroys the window.

    &#34;&#34;&#34;
    self.initial_focus = None
    if self.initialMenuState:
        self.root.menuEnabled = True
    tk.Toplevel.destroy(self)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="legends.ui.dialogs.OptimalSummons"><code class="flex name class">
<span>class <span class="ident">OptimalSummons</span></span>
<span>(</span><span>root, parent=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A message dialog showing the summon pool rates.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>excludeCommons</code></strong> :&ensp;<code>tk.BooleanVar</code></dt>
<dd><code>True</code> is the summon rate
calculations should exclude Common characters.</dd>
<dt><strong><code>values</code></strong> :&ensp;<code>dict</code></dt>
<dd>{<code>str</code>:<code>tk.StringVar</code>} A dictionary mapping pool
names to a formatted string representation of the average
number of tokens per 150 orbs received from the pool.</dd>
<dt><strong><code>labels</code></strong> :&ensp;<code>dict</code></dt>
<dd>{<code>str</code>:(<code>tk.Label</code>,<code>tk.Label</code>)} A dictionary
mapping pool names to the pair of labels associated with
that pool in the body of the message dialog.</dd>
</dl>
<p>The constructor disables the root menu before calling the
<code>tk.simpledialog.Dialog</code> constructor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OptimalSummons(ModalMessage):
    &#34;&#34;&#34;A message dialog showing the summon pool rates.

    Attributes:
        excludeCommons (tk.BooleanVar): `True` is the summon rate
            calculations should exclude Common characters.
        values (dict): {`str`:`tk.StringVar`} A dictionary mapping pool
            names to a formatted string representation of the average
            number of tokens per 150 orbs received from the pool.
        labels (dict): {`str`:(`tk.Label`,`tk.Label`)} A dictionary
            mapping pool names to the pair of labels associated with
            that pool in the body of the message dialog.

    &#34;&#34;&#34;
    def __init__(self, root, parent=None):
        self.excludeCommons = tk.BooleanVar(None, True)
        self.values = {}
        self.labels = {}
        for pool in SUMMON_POOL:
            self.values[pool] = tk.StringVar()
        ModalMessage.__init__(self, root, parent, &#39;Summon Rates&#39;)

    def body(self, master):
        &#34;&#34;&#34;Create the body of the dialog.

        &#34;&#34;&#34;
        tk.Label(
            master,
            text=&#39;Average Tokens per 150 Orbs&#39;,
            font=(None, 13, &#39;bold&#39;)
        ).pack(pady=(0,10))
        results = tk.Frame(master)
        results.pack()
        for row, pool in enumerate(SUMMON_POOL):
            self.labels[pool] = (
                tk.Label(
                    results, text=&#39;{} Pool:&#39;.format(pool)
                ),
                tk.Label(
                    results, textvariable=self.values[pool], width=5
                )
            )
            self.labels[pool][0].grid(row=row, column=0, sticky=W)
            self.labels[pool][1].grid(row=row, column=1, sticky=E)
        tk.Checkbutton(
            master,
            text=&#39;exclude Common characters&#39;,
            variable=self.excludeCommons, command=self.refresh
        ).pack(pady=(10,0))
        self.refresh()

    def refresh(self):
        &#34;&#34;&#34;Updates the values in the `values` attribute and sets the
        font emphasis of the labels so that the highest summon rate is
        bold and the others are normal.

        &#34;&#34;&#34;
        bestPool = &#39;&#39;
        bestPoolTokens = -1
        tokens = {}
        for pool in SUMMON_POOL:
            roster = self.root.session.saveslot.roster
            tokens[pool] = 150 * roster.tokensPerOrb(
                pool, self.excludeCommons.get()
            )
            self.values[pool].set(&#39;{:.2f}&#39;.format(tokens[pool]))
            self.setPoolEmphasis(pool, &#39;normal&#39;)
            if tokens[pool] &gt; bestPoolTokens:
                bestPool, bestPoolTokens = pool, tokens[pool]
        self.setPoolEmphasis(bestPool, &#39;bold&#39;)

    def setPoolEmphasis(self, pool, emphasis):
        &#34;&#34;&#34;Finds the labels associated with the given pool and sets
        their font to have the given emphasis.

        Args:
            pool (str): The name of a summon pool.
            emphasis (str): One of &#39;normal&#39; or &#39;bold&#39;.

        &#34;&#34;&#34;
        self.labels[pool][0].config(font=(None, 11, emphasis))
        self.labels[pool][1].config(font=(None, 11, emphasis))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="legends.ui.dialogs.ModalMessage" href="#legends.ui.dialogs.ModalMessage">ModalMessage</a></li>
<li>tkinter.simpledialog.Dialog</li>
<li>tkinter.Toplevel</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Wm</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="legends.ui.dialogs.OptimalSummons.body"><code class="name flex">
<span>def <span class="ident">body</span></span>(<span>self, master)</span>
</code></dt>
<dd>
<div class="desc"><p>Create the body of the dialog.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def body(self, master):
    &#34;&#34;&#34;Create the body of the dialog.

    &#34;&#34;&#34;
    tk.Label(
        master,
        text=&#39;Average Tokens per 150 Orbs&#39;,
        font=(None, 13, &#39;bold&#39;)
    ).pack(pady=(0,10))
    results = tk.Frame(master)
    results.pack()
    for row, pool in enumerate(SUMMON_POOL):
        self.labels[pool] = (
            tk.Label(
                results, text=&#39;{} Pool:&#39;.format(pool)
            ),
            tk.Label(
                results, textvariable=self.values[pool], width=5
            )
        )
        self.labels[pool][0].grid(row=row, column=0, sticky=W)
        self.labels[pool][1].grid(row=row, column=1, sticky=E)
    tk.Checkbutton(
        master,
        text=&#39;exclude Common characters&#39;,
        variable=self.excludeCommons, command=self.refresh
    ).pack(pady=(10,0))
    self.refresh()</code></pre>
</details>
</dd>
<dt id="legends.ui.dialogs.OptimalSummons.refresh"><code class="name flex">
<span>def <span class="ident">refresh</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates the values in the <code>values</code> attribute and sets the
font emphasis of the labels so that the highest summon rate is
bold and the others are normal.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refresh(self):
    &#34;&#34;&#34;Updates the values in the `values` attribute and sets the
    font emphasis of the labels so that the highest summon rate is
    bold and the others are normal.

    &#34;&#34;&#34;
    bestPool = &#39;&#39;
    bestPoolTokens = -1
    tokens = {}
    for pool in SUMMON_POOL:
        roster = self.root.session.saveslot.roster
        tokens[pool] = 150 * roster.tokensPerOrb(
            pool, self.excludeCommons.get()
        )
        self.values[pool].set(&#39;{:.2f}&#39;.format(tokens[pool]))
        self.setPoolEmphasis(pool, &#39;normal&#39;)
        if tokens[pool] &gt; bestPoolTokens:
            bestPool, bestPoolTokens = pool, tokens[pool]
    self.setPoolEmphasis(bestPool, &#39;bold&#39;)</code></pre>
</details>
</dd>
<dt id="legends.ui.dialogs.OptimalSummons.setPoolEmphasis"><code class="name flex">
<span>def <span class="ident">setPoolEmphasis</span></span>(<span>self, pool, emphasis)</span>
</code></dt>
<dd>
<div class="desc"><p>Finds the labels associated with the given pool and sets
their font to have the given emphasis.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pool</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of a summon pool.</dd>
<dt><strong><code>emphasis</code></strong> :&ensp;<code>str</code></dt>
<dd>One of 'normal' or 'bold'.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setPoolEmphasis(self, pool, emphasis):
    &#34;&#34;&#34;Finds the labels associated with the given pool and sets
    their font to have the given emphasis.

    Args:
        pool (str): The name of a summon pool.
        emphasis (str): One of &#39;normal&#39; or &#39;bold&#39;.

    &#34;&#34;&#34;
    self.labels[pool][0].config(font=(None, 11, emphasis))
    self.labels[pool][1].config(font=(None, 11, emphasis))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="legends.ui.dialogs.ModalMessage" href="#legends.ui.dialogs.ModalMessage">ModalMessage</a></b></code>:
<ul class="hlist">
<li><code><a title="legends.ui.dialogs.ModalMessage.buttonbox" href="#legends.ui.dialogs.ModalMessage.buttonbox">buttonbox</a></code></li>
<li><code><a title="legends.ui.dialogs.ModalMessage.destroy" href="#legends.ui.dialogs.ModalMessage.destroy">destroy</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="legends.ui.dialogs.RosterFilter"><code class="flex name class">
<span>class <span class="ident">RosterFilter</span></span>
<span>(</span><span>filt=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Stores information about filtering a
<code><a title="legends.ui.rostertab.RosterTab" href="rostertab.html#legends.ui.rostertab.RosterTab">RosterTab</a></code>.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>rarities</code></strong> :&ensp;<code>dict</code></dt>
<dd>{<code>str</code>:<code>tk.BooleanVar</code>} A dictionary mapping
rarities to <code>tkinter</code> boolean variables indicating whether
the rarity is to be included in the
<code><a title="legends.ui.rostertab.RosterTab" href="rostertab.html#legends.ui.rostertab.RosterTab">RosterTab</a></code>.</dd>
<dt><strong><code>roles</code></strong> :&ensp;<code>dict</code></dt>
<dd>{<code>str</code>:<code>tk.BooleanVar</code>} A dictionary mapping roles
to <code>tkinter</code> boolean variables indicating whether the role
is to be included in the <code><a title="legends.ui.rostertab.RosterTab" href="rostertab.html#legends.ui.rostertab.RosterTab">RosterTab</a></code>.</dd>
<dt><strong><code>ranks</code></strong> :&ensp;<code>tuple</code></dt>
<dd>(<code>tk.IntVar</code>, <code>tk.IntVar</code>) The first value is the
minimum rank to include in the
<code><a title="legends.ui.rostertab.RosterTab" href="rostertab.html#legends.ui.rostertab.RosterTab">RosterTab</a></code>. The second is the maximum.</dd>
<dt><strong><code>levels</code></strong> :&ensp;<code>tuple</code></dt>
<dd>(<code>tk.IntVar</code>, <code>tk.IntVar</code>) The first value is
the minimum level to include in the
<code><a title="legends.ui.rostertab.RosterTab" href="rostertab.html#legends.ui.rostertab.RosterTab">RosterTab</a></code>. The second is the maximum.</dd>
</dl>
<p>The constructor creates a new <code><a title="legends.ui.dialogs.RosterFilter" href="#legends.ui.dialogs.RosterFilter">RosterFilter</a></code> object with the
same values as the given <code><a title="legends.ui.dialogs.RosterFilter" href="#legends.ui.dialogs.RosterFilter">RosterFilter</a></code> object. If <code>None</code> is
provided, the new filter will not omit anything.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filt</code></strong> :&ensp;<code><a title="legends.ui.dialogs.RosterFilter" href="#legends.ui.dialogs.RosterFilter">RosterFilter</a></code></dt>
<dd>The filter used to initialize the new
filter.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RosterFilter():
    &#34;&#34;&#34;Stores information about filtering a
    `legends.ui.rostertab.RosterTab`.

    Attributes:
        rarities (dict): {`str`:`tk.BooleanVar`} A dictionary mapping
            rarities to `tkinter` boolean variables indicating whether
            the rarity is to be included in the
            `legends.ui.rostertab.RosterTab`.
        roles (dict): {`str`:`tk.BooleanVar`} A dictionary mapping roles
            to `tkinter` boolean variables indicating whether the role
            is to be included in the `legends.ui.rostertab.RosterTab`.
        ranks (tuple): (`tk.IntVar`, `tk.IntVar`) The first value is the
            minimum rank to include in the
            `legends.ui.rostertab.RosterTab`. The second is the maximum.
        levels (tuple): (`tk.IntVar`, `tk.IntVar`) The first value is
            the minimum level to include in the
            `legends.ui.rostertab.RosterTab`. The second is the maximum.

    &#34;&#34;&#34;

    def __init__(self, filt=None):
        &#34;&#34;&#34;The constructor creates a new `RosterFilter` object with the
        same values as the given `RosterFilter` object. If `None` is
        provided, the new filter will not omit anything.

        Args:
            filt (RosterFilter): The filter used to initialize the new
                filter.

        &#34;&#34;&#34;
        self.rarities = {
            rarity: tk.BooleanVar(None, True) for rarity in RARITIES
        }
        self.roles = {
            role: tk.BooleanVar(None, True) for role in ROLES
        }
        self.ranks = (tk.IntVar(None, 1), tk.IntVar(None, 9))
        self.levels = (tk.IntVar(None, 1), tk.IntVar(None, 99))
        if filt is not None:
            self.set(filt)

    def set(self, filt):
        &#34;&#34;&#34;Sets the values of the calling instance to match those of the
        given filter.

        Args:
            filt (RosterFilter): The filter from which to copy values.

        &#34;&#34;&#34;
        for rarity, var in self.rarities.items():
            var.set(filt.rarities[rarity].get())
        for role, var in self.roles.items():
            var.set(filt.roles[role].get())
        for j in (0, 1):
            self.ranks[j].set(filt.ranks[j].get())
        for j in (0, 1):
            self.levels[j].set(filt.levels[j].get())

    def dictify(self):
        &#34;&#34;&#34;Creates and returns a dictionary mapping the calling
        instance&#39;s attribute names to its values, with each `tkinter`
        variable replaced by its value.

        Returns:
            dict: The constructed dictionary.

        &#34;&#34;&#34;
        D = {}
        D[&#39;rarities&#39;] = {
            rarity: var.get() for rarity, var in self.rarities.items()
        }
        D[&#39;roles&#39;] = {
            role: var.get() for role, var in self.roles.items()
        }
        D[&#39;ranks&#39;] = (self.ranks[0].get(), self.ranks[1].get())
        D[&#39;levels&#39;] = (self.levels[0].get(), self.levels[1].get())
        return D

    def __eq__(self, other):
        return self.dictify() == other.dictify()

    def __repr__(self):
        return &#39;RosterFilter({})&#39;.format(self.dictify())</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="legends.ui.dialogs.RosterFilter.dictify"><code class="name flex">
<span>def <span class="ident">dictify</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and returns a dictionary mapping the calling
instance's attribute names to its values, with each <code>tkinter</code>
variable replaced by its value.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>The constructed dictionary.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dictify(self):
    &#34;&#34;&#34;Creates and returns a dictionary mapping the calling
    instance&#39;s attribute names to its values, with each `tkinter`
    variable replaced by its value.

    Returns:
        dict: The constructed dictionary.

    &#34;&#34;&#34;
    D = {}
    D[&#39;rarities&#39;] = {
        rarity: var.get() for rarity, var in self.rarities.items()
    }
    D[&#39;roles&#39;] = {
        role: var.get() for role, var in self.roles.items()
    }
    D[&#39;ranks&#39;] = (self.ranks[0].get(), self.ranks[1].get())
    D[&#39;levels&#39;] = (self.levels[0].get(), self.levels[1].get())
    return D</code></pre>
</details>
</dd>
<dt id="legends.ui.dialogs.RosterFilter.set"><code class="name flex">
<span>def <span class="ident">set</span></span>(<span>self, filt)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the values of the calling instance to match those of the
given filter.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filt</code></strong> :&ensp;<code><a title="legends.ui.dialogs.RosterFilter" href="#legends.ui.dialogs.RosterFilter">RosterFilter</a></code></dt>
<dd>The filter from which to copy values.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set(self, filt):
    &#34;&#34;&#34;Sets the values of the calling instance to match those of the
    given filter.

    Args:
        filt (RosterFilter): The filter from which to copy values.

    &#34;&#34;&#34;
    for rarity, var in self.rarities.items():
        var.set(filt.rarities[rarity].get())
    for role, var in self.roles.items():
        var.set(filt.roles[role].get())
    for j in (0, 1):
        self.ranks[j].set(filt.ranks[j].get())
    for j in (0, 1):
        self.levels[j].set(filt.levels[j].get())</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="legends.ui" href="index.html">legends.ui</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="legends.ui.dialogs.addroot" href="#legends.ui.dialogs.addroot">addroot</a></code></li>
<li><code><a title="legends.ui.dialogs.askMaxChars" href="#legends.ui.dialogs.askMaxChars">askMaxChars</a></code></li>
<li><code><a title="legends.ui.dialogs.askRosterFilter" href="#legends.ui.dialogs.askRosterFilter">askRosterFilter</a></code></li>
<li><code><a title="legends.ui.dialogs.askSlot" href="#legends.ui.dialogs.askSlot">askSlot</a></code></li>
<li><code><a title="legends.ui.dialogs.askyesno" href="#legends.ui.dialogs.askyesno">askyesno</a></code></li>
<li><code><a title="legends.ui.dialogs.showerror" href="#legends.ui.dialogs.showerror">showerror</a></code></li>
<li><code><a title="legends.ui.dialogs.showinfo" href="#legends.ui.dialogs.showinfo">showinfo</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="legends.ui.dialogs.AskMaxChars" href="#legends.ui.dialogs.AskMaxChars">AskMaxChars</a></code></h4>
<ul class="">
<li><code><a title="legends.ui.dialogs.AskMaxChars.body" href="#legends.ui.dialogs.AskMaxChars.body">body</a></code></li>
<li><code><a title="legends.ui.dialogs.AskMaxChars.validate" href="#legends.ui.dialogs.AskMaxChars.validate">validate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="legends.ui.dialogs.AskRosterFilter" href="#legends.ui.dialogs.AskRosterFilter">AskRosterFilter</a></code></h4>
<ul class="">
<li><code><a title="legends.ui.dialogs.AskRosterFilter.apply" href="#legends.ui.dialogs.AskRosterFilter.apply">apply</a></code></li>
<li><code><a title="legends.ui.dialogs.AskRosterFilter.body" href="#legends.ui.dialogs.AskRosterFilter.body">body</a></code></li>
<li><code><a title="legends.ui.dialogs.AskRosterFilter.buttonbox" href="#legends.ui.dialogs.AskRosterFilter.buttonbox">buttonbox</a></code></li>
<li><code><a title="legends.ui.dialogs.AskRosterFilter.clear" href="#legends.ui.dialogs.AskRosterFilter.clear">clear</a></code></li>
<li><code><a title="legends.ui.dialogs.AskRosterFilter.makeLinkedScales" href="#legends.ui.dialogs.AskRosterFilter.makeLinkedScales">makeLinkedScales</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="legends.ui.dialogs.AskSlot" href="#legends.ui.dialogs.AskSlot">AskSlot</a></code></h4>
<ul class="">
<li><code><a title="legends.ui.dialogs.AskSlot.body" href="#legends.ui.dialogs.AskSlot.body">body</a></code></li>
<li><code><a title="legends.ui.dialogs.AskSlot.validate" href="#legends.ui.dialogs.AskSlot.validate">validate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="legends.ui.dialogs.HelpScreen" href="#legends.ui.dialogs.HelpScreen">HelpScreen</a></code></h4>
<ul class="">
<li><code><a title="legends.ui.dialogs.HelpScreen.body" href="#legends.ui.dialogs.HelpScreen.body">body</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="legends.ui.dialogs.ModalDialog" href="#legends.ui.dialogs.ModalDialog">ModalDialog</a></code></h4>
<ul class="">
<li><code><a title="legends.ui.dialogs.ModalDialog.buttonbox" href="#legends.ui.dialogs.ModalDialog.buttonbox">buttonbox</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="legends.ui.dialogs.ModalMessage" href="#legends.ui.dialogs.ModalMessage">ModalMessage</a></code></h4>
<ul class="">
<li><code><a title="legends.ui.dialogs.ModalMessage.buttonbox" href="#legends.ui.dialogs.ModalMessage.buttonbox">buttonbox</a></code></li>
<li><code><a title="legends.ui.dialogs.ModalMessage.destroy" href="#legends.ui.dialogs.ModalMessage.destroy">destroy</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="legends.ui.dialogs.OptimalSummons" href="#legends.ui.dialogs.OptimalSummons">OptimalSummons</a></code></h4>
<ul class="">
<li><code><a title="legends.ui.dialogs.OptimalSummons.body" href="#legends.ui.dialogs.OptimalSummons.body">body</a></code></li>
<li><code><a title="legends.ui.dialogs.OptimalSummons.refresh" href="#legends.ui.dialogs.OptimalSummons.refresh">refresh</a></code></li>
<li><code><a title="legends.ui.dialogs.OptimalSummons.setPoolEmphasis" href="#legends.ui.dialogs.OptimalSummons.setPoolEmphasis">setPoolEmphasis</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="legends.ui.dialogs.RosterFilter" href="#legends.ui.dialogs.RosterFilter">RosterFilter</a></code></h4>
<ul class="">
<li><code><a title="legends.ui.dialogs.RosterFilter.dictify" href="#legends.ui.dialogs.RosterFilter.dictify">dictify</a></code></li>
<li><code><a title="legends.ui.dialogs.RosterFilter.set" href="#legends.ui.dialogs.RosterFilter.set">set</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>